<?php

/**
 * VariationOrderItem
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    buildspace
 * @subpackage model
 * @author     1337 developers
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class VariationOrderItem extends BaseVariationOrderItem
{
    const TYPE_HEADER = 1;
    const TYPE_WORK_ITEM = 2;

    const TYPE_HEADER_TEXT = 'HEAD';
    const TYPE_WORK_ITEM_TEXT = 'ITEM';

    /*
    * This method is use when updating type column in variation order item.
    * We need to remove all information on build up quantity (if any) and uom if the type is not work item.
    */
    public function updateColumnByColumnName($columnName, $value)
    {
        switch($columnName)
        {
            case "type":
                if($value == self::TYPE_HEADER)
                {
                    if(!$this->isNew())
                    {
                        $this->deleteBuildUpQuantities();
                    }

                    $this->rate = 0;
                    $this->uom_id = NULL;

                    if($this->has_omission_build_up_quantity or $this->has_addition_build_up_quantity)
                    {
                        $this->has_omission_build_up_quantity = false;
                        $this->has_addition_build_up_quantity = false;

                        $this->addition_quantity = 0;
                        $this->omission_quantity = 0;
                    }
                }

                $this->type = (integer)$value;

                break;
            case "uom_id":
                if(!$this->isNew())
                {
                    $this->deleteBuildUpQuantities();
                }

                if($this->has_omission_build_up_quantity or $this->has_addition_build_up_quantity)
                {
                    $this->has_omission_build_up_quantity = false;
                    $this->has_addition_build_up_quantity = false;

                    $this->addition_quantity = 0;
                    $this->omission_quantity = 0;
                }

                $this->uom_id = $value;

                break;
            case "omission_quantity":
                if(!$this->isNew())
                {
                    $this->deleteBuildUpQuantities(VariationOrderBuildUpQuantityItem::TYPE_OMISSION_QTY);
                }

                $this->omission_quantity = round($value, 2);
                $this->has_omission_build_up_quantity = false;

                break;
            case "addition_quantity":
                if(!$this->isNew())
                {
                    $this->deleteBuildUpQuantities(VariationOrderBuildUpQuantityItem::TYPE_ADDITIONAL_QTY);
                }

                $this->addition_quantity = round($value, 2);
                $this->has_addition_build_up_quantity = false;

                break;
            case "reference_rate":
                $this->reference_rate = round($value, 2);
                $this->reference_amount = $this->reference_rate * $this->reference_quantity;
                break;
            case "reference_quantity":
                $this->reference_quantity = round($value, 2);
                $this->reference_amount = $this->reference_rate * $this->reference_quantity;
                break;
            default:
                throw new Exception('invalid column name');
        }
    }

    public function updateRootPriority($priority, $excludeId)
    {
        $pdo = $this->getTable()->getConnection()->getDbh();

        $sqlUpdateRoot = "UPDATE ".$this->getTable()->getTableName()." SET priority = priority + 1
            WHERE variation_order_id =".$this->variation_order_id." AND priority >=".$priority." AND id = root_id";

        if($excludeId and $excludeId > 0)
        {
            $sqlUpdateRoot .= " AND id <> ".$excludeId;
        }

        $sqlUpdateRoot .= " AND deleted_at IS NULL";

        $stmt = $pdo->prepare($sqlUpdateRoot);

        $stmt->execute();

        $stmt = $pdo->prepare("UPDATE ".$this->getTable()->getTableName()." AS i SET priority = r.priority
            FROM ".$this->getTable()->getTableName()." AS r
            WHERE i.root_id = r.id AND i.id <> r.id AND i.priority <> r.priority
            AND i.variation_order_id = ".$this->variation_order_id." AND i.deleted_at IS NULL");

        $stmt->execute();
    }

    public function deleteBuildUpQuantities($buildUpQuantityType = null, Doctrine_Connection $con = null)
    {
        VariationOrderItemTable::deleteBuildUpQuantitiesByVariationOrderItemId($this->id, $buildUpQuantityType, $con);
    }

    public function deleteVariationOrderUnitReference()
    {
        Doctrine_Query::create()
            ->delete('VariationOrderItemUnit u')
            ->where('u.variation_order_item_id = ?', $this->id)
            ->execute();
    }

    public function delete(Doctrine_Connection $conn = null)
    {
        if($this->type == VariationOrderItem::TYPE_HEADER)
        {
            Doctrine_Query::create()
                ->delete('VariationOrderItem i')
                ->where('i.root_id = ?', $this->root_id)
                ->andWhere('i.variation_order_id = ?', $this->variation_order_id)
                ->andWhere('i.lft > ?', $this->lft)
                ->andWhere('i.rgt < ?', $this->rgt)
                ->execute();
        }

        $this->deleteBuildUpQuantities(null, $conn);

        $this->deleteVariationOrderUnitReference();

        parent::delete($conn);

        //recalculate left-right values when deleting child nodes
        if(!$this->node->isRoot())
        {
            $first = $this->rgt + 1;
            $delta = $this->lft - $this->rgt - 1;

            Utilities::shiftRightLeftNestedSet(get_class($this), $first, $delta, $this->root_id, $conn);
        }
    }

    public function indent()
    {
        $indented = false;
        $previousRoot = $this->getPreviousRoot();

        if($this->node->isRoot() and $previousRoot and $previousRoot->type == VariationOrderItem::TYPE_HEADER)
        {
            $this->node->moveAsLastChildOf($previousRoot);
            $this->refresh();

            $pdo = $this->getTable()->getConnection()->getDbh();
            $sqlUpdatePriority = "UPDATE ".$this->getTable()->getTableName()." SET priority = ".$previousRoot->priority."
            WHERE root_id = ".$previousRoot->root_id." AND priority <> ".$previousRoot->priority."
            AND variation_order_id = ".$this->variation_order_id." AND deleted_at IS NULL";

            $stmt = $pdo->prepare($sqlUpdatePriority);
            $stmt->execute();

            $indented = true;
        }
        else if(!$this->node->isRoot() and $this->node->hasPrevSibling() and ($this->node->getPrevSibling()->type == VariationOrderItem::TYPE_HEADER))
        {
            $prevSibling = $this->node->getPrevSibling();
            $this->node->moveAsLastChildOf($prevSibling);

            $this->refresh();

            $indented = true;
        }

        return $indented;
    }

    public function outdent()
    {
        if(!$this->node->isRoot() and ($this->type == VariationOrderItem::TYPE_HEADER or ($this->type != VariationOrderItem::TYPE_HEADER and !$this->node->hasNextSibling())))
        {
            $parent = $this->node->getParent();

            if(!$parent || !$parent->node)
            {
                return false;
            }
            
            $siblings = Doctrine_Query::create()->select('i.id')
                ->from('VariationOrderItem i')
                ->where('i.root_id = ?',$this->root_id)
                ->andWhere('i.level = ?', $this->level)
                ->andWhere('i.lft BETWEEN ? AND ?', array($parent->lft, $parent->rgt))
                ->andWhere('i.lft > ?', $this->rgt)
                ->addOrderBy('i.lft ASC')
                ->execute();

            foreach($siblings as $sibling)
            {
                $sibling->node->moveAsLastChildOf($this);
                $this->refresh();
            }

            if(!$parent->node->isRoot())
            {
                $this->node->moveAsNextSiblingOf($parent);
            }
            else
            {
                $this->node->makeRoot($this->id);
                $this->save();

                $this->priority = $parent->priority + 1;
                $this->save();

                $this->updateRootPriority($parent->priority + 1, $this->id);
            }

            $this->refresh();

            return true;
        }
        else
        {
            return false;
        }
    }

    public function moveTo(VariationOrderItem $targetItem, $lastPosition=false)
    {
        $con = $this->getTable()->getConnection();

        try
        {
            $con->beginTransaction();

            if($targetItem->node->isRoot())
            {
                $priority       = $lastPosition ? $targetItem->priority + 1 : $targetItem->priority;
                $this->priority = $priority;
                $this->save();

                if(!$this->node->isRoot() and $this->node->isValidNode())
                {
                    $this->node->makeRoot($this->id);
                    $this->save();
                }

                if(!$lastPosition)
                {
                    $this->updateRootPriority($priority, $this->id);
                }
            }
            else
            {
                if($lastPosition)
                {
                    $this->node->moveAsNextSiblingOf($targetItem);
                }
                else
                {
                    $this->node->moveAsPrevSiblingOf($targetItem);
                }

                $this->priority = $targetItem->priority;
                $this->save();

                $this->refresh();
            }

            /*
             * Update priority for all nodes under the family to its root priority.
             * We exclude this step for case the target item is root node and $lastPosition is false
             * because the priority already been update by calling updateRootPriority()
             */
            if(($targetItem->node->isRoot() && $lastPosition) or !$targetItem->node->isRoot())
            {
                Doctrine_Query::create()->update('VariationOrderItem i')
                    ->set('priority', $this->priority)
                    ->where('i.lft BETWEEN ? AND ?', array($this->lft, $this->rgt))
                    ->andWhere('i.root_id = ?', $this->root_id)
                    ->andWhere('i.priority <> ?', $this->priority)
                    ->andWhere('i.variation_order_id = ?', $this->variation_order_id)
                    ->execute();
            }

            $con->commit();

            return true;
        }
        catch(Exception $e)
        {
            $con->rollback();
            throw $e;
        }
    }

    public function updateClaimItem($fieldName, $value)
    {
        $currentClaim = Doctrine_Query::create()->select('c.*')
            ->from('VariationOrderClaim c')
            ->where('c.variation_order_id = ?',$this->variation_order_id)
            ->andWhere('c.status = ?', VariationOrderClaim::STATUS_PROGRESSING)
            ->limit(1)
            ->addOrderBy('c.revision DESC')
            ->fetchOne();

        if($currentClaim)
        {
            if($fieldName == "remarks")
            {
                $value = $value;
            }
            else
            {
                $value = is_numeric($value) ? $value : 0;
            }

            $claimItem = DoctrineQuery::create()->select('i.*')
                ->from('VariationOrderClaimItem i')
                ->where('i.variation_order_claim_id = ?',$currentClaim->id)
                ->andWhere('i.variation_order_item_id = ?', $this->id)
                ->limit(1)
                ->fetchOne();

            if(!$claimItem)
            {
                $claimItem = new VariationOrderClaimItem();
                $claimItem->variation_order_claim_id = $currentClaim->id;
                $claimItem->variation_order_item_id = $this->id;
            }

            $claimItem->{'update'.sfInflector::camelize($fieldName)}($value);

            $claimItem->save();

            return $claimItem;
        }
        else
        {
            throw new Exception("There is no progressing claim for variation order with id: ".$this->variation_order_id);
        }

    }

    public function getNettOmissionAddition()
    {
        $omissionTotal = round($this->omission_quantity * $this->rate * $this->total_unit, 2);
        $additionTotal = round($this->addition_quantity * $this->rate * $this->total_unit, 2);

        if($omissionTotal > $additionTotal)
        {
            return ($omissionTotal - $additionTotal);
        }
        else
        {
            return ($additionTotal - $omissionTotal);
        }
    }

    public function getPreviousRoot()
    {
        $rootId = $this->root_id > 0 ? $this->root_id : $this->id;
        $root = $this->getTable()->find($rootId);

        return Doctrine_Core::getTable('VariationOrderItem')
            ->createQuery('i')
            ->select('i.id')
            ->where('i.root_id = i.id')
            ->addWhere('i.variation_order_id = ?', $this->variation_order_id)
            ->addWhere('i.priority < ?', $root->priority)
            ->orderBy('i.priority DESC')
            ->limit(1)
            ->fetchOne();
    }

    public function updateTotalUnit($ids, ProjectStructure $bill)
    {
        $pdo = $this->getTable()->getConnection()->getDbh();
        $postContractId = $bill->getRoot()->PostContract->id;

        try
        {
            $pdo->beginTransaction();

            /*
            * Delete all relations in VariationOrderItemUnitTable if empty ids been supplied
            */
            $stmt = $pdo->prepare("DELETE FROM ".VariationOrderItemUnitTable::getInstance()->getTableName()."
                WHERE variation_order_item_id = ".$this->id." AND type_reference_id IN (
                SELECT id FROM ".PostContractStandardClaimTypeReferenceTable::getInstance()->getTableName()."
                WHERE post_contract_id = ".$postContractId." AND bill_column_setting_id IN (SELECT id FROM ".BillColumnSettingTable::getInstance()->getTableName()."
                WHERE project_structure_id = ".$bill->id." AND deleted_at IS NULL))");

            $stmt->execute();

            $pdo->commit();

            /*
            * Update variation order item total_unit based on the count of relation in VariationOrderItemUnitTable
            */
            $this->refresh();
            $this->refreshRelated('TypeReferences');

            $numberOfUnitReferences = $this->TypeReferences->count();

            $totalUnit = 0;

            if($numberOfUnitReferences > 0)
            {
                $totalUnit = $numberOfUnitReferences;
            }
            elseif($numberOfUnitReferences == 0 and $this->bill_item_id == 0)
            {
                $totalUnit = 1;
            }

            $this->total_unit = $totalUnit;
            $this->save();
        }
        catch(PDOException $e)
        {
            $pdo->rollBack();
            throw $e;
        }

        $dirtyIds = explode(",", $ids);

        if(strlen($ids) == 0 or (count($dirtyIds) == 0 and array_search("", $dirtyIds) === true))
        {
            if($this->total_unit == 0)
            {
                $this->delete();
            }

            return false;
        }

        $billColumnSettings = array();

        $unselectableUnits = array();

        foreach(VariationOrderItemTable::getBillItemsTaggedToOtherVariationOrders($this->VariationOrder) as $item)
        {
            if( $item['bill_item_id'] == $this->bill_item_id ) $unselectableUnits[] = $item['counter'];
        }

        foreach($dirtyIds as $dirtyId)
        {
            $explodedId = explode("-", $dirtyId);

            if( in_array($explodedId[1], $unselectableUnits) ) continue;

            if(!array_key_exists($explodedId[0], $billColumnSettings))
            {
                $billColumnSettings[$explodedId[0]] = array();
            }

            array_push($billColumnSettings[$explodedId[0]], $explodedId[1]);
        }

        $newRecords = array();
        $typeReferenceIds = array();

        foreach($billColumnSettings as $billColumnSettingId => $counterList)
        {
            $stmt = $pdo->prepare("SELECT id, counter FROM ".PostContractStandardClaimTypeReferenceTable::getInstance()->getTableName()."
            WHERE bill_column_setting_id =".$billColumnSettingId." AND counter IN (".implode(',', $counterList).")");

            $stmt->execute();

            $records = $stmt->fetchAll(PDO::FETCH_ASSOC);

            foreach($records as $existedCounter)
            {
                if(($key = array_search($existedCounter['counter'], $counterList)) !== false) {
                    unset($counterList[$key]);
                    $typeReferenceIds[] = $existedCounter['id'];
                }
            }

            foreach($counterList as $counter)
            {
                $newRecords[] ="(".$billColumnSettingId.", ".$counter.", ".$postContractId.")";
            }
        }

        if(count($newRecords) > 0)
        {
            try
            {
                $pdo->beginTransaction();

                $stmt = $pdo->prepare('INSERT INTO '.PostContractStandardClaimTypeReferenceTable::getInstance()->getTableName().'
                (bill_column_setting_id, counter, post_contract_id) VALUES '.implode(',', $newRecords).' RETURNING id');

                $stmt->execute();

                $pdo->commit();

                $newIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                $newIds = Utilities::arrayValueRecursive("id", $newIds);

                $typeReferenceIds = array_merge($typeReferenceIds, $newIds);
            }
            catch(PDOException $e)
            {
                $pdo->rollBack();
                throw $e;
            }
        }

        if(count($typeReferenceIds) > 0)
        {
            $sqlInsertData = array();
            $userId = sfContext::getInstance()->getUser()->getAttribute('user_id', null, 'sfGuardSecurityUser');

            foreach($typeReferenceIds as $typeReferenceId)
            {
                $sqlInsertData[] = "(".$this->id.", ".$typeReferenceId.", NOW(), NOW(), ".$userId.", ".$userId.")";
            }

            /*
             * Tag all the type references to the variation order item. We always clear out the existing data
             * and insert the new data based on the passed type reference ids.
             */
            try
            {
                $pdo->beginTransaction();

                $stmt = $pdo->prepare('INSERT INTO '.VariationOrderItemUnitTable::getInstance()->getTableName().'
                (variation_order_item_id, type_reference_id, created_at, updated_at, created_by, updated_by) VALUES '.implode(',', $sqlInsertData));

                $stmt->execute();

                $pdo->commit();

                /*
                 * Update variation order item total_unit based on the count of relation in VariationOrderItemUnitTable
                 */
                $this->refresh();
                $this->refreshRelated('TypeReferences');

                $this->total_unit =  $this->TypeReferences->count();
                $this->save();

                return true;
            }
            catch(PDOException $e)
            {
                $pdo->rollBack();
                throw $e;
            }
        }

        return false;
    }

    public function getRoot()
    {
        if($this->node->isRoot())
        {
            return $this;
        }
        else
        {
            return $this->getTable()->find($this->root_id);
        }
    }

    public function copyQuantityFromLinkedBillItem(BillColumnSetting $billColumnSetting)
    {
        if($this->bill_item_id > 0)
        {
            $billItemQuantity = DoctrineQuery::create()
                ->select('t.id, t.qty_per_unit')
                ->from('PostContractBillItemType t')
                ->where('t.bill_item_id = ?', array($this->bill_item_id))
                ->andWhere('t.bill_column_setting_id = ?', array($billColumnSetting->id))
                ->andWhere('t.post_contract_id = ?', array($billColumnSetting->ProjectStructure->getRoot()->PostContract->id))
                ->limit(1)
                ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
                ->fetchOne();

            if($billItemQuantity)
            {
                $this->omission_quantity = $billItemQuantity['qty_per_unit'];
                $this->save();
            }

            return true;
        }
        else
        {
            return false;
        }
    }

    public function copyBuildUpQuantityFromLinkedBillItem(BillColumnSetting $billColumnSetting)
    {
        if($this->bill_item_id > 0)
        {
            $billBuildUpQuantityType = $billColumnSetting->use_original_quantity ? BillBuildUpQuantityItem::QUANTITY_PER_UNIT_ORIGINAL : BillBuildUpQuantityItem::QUANTITY_PER_UNIT_REMEASUREMENT;

            $billBuildUpQuantityItems = DoctrineQuery::create()
                ->select('i.id, i.bill_column_setting_id, i.description, i.total, i.sign, i.priority, t.type')
                ->from('BillBuildUpQuantityItem i')
                ->where('i.bill_item_id = ?', array($this->bill_item_id))
                ->andWhere('i.bill_column_setting_id = ?', array($billColumnSetting->id))
                ->andWhere('i.type = ?', array($billBuildUpQuantityType))
                ->addOrderBy('i.priority ASC')
                ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
                ->execute();

            $scheduleOfQuantityLinks = ScheduleOfQuantityBillItemXrefTable::getInstance()
                ->createQuery('x')->select('x.schedule_of_quantity_item_id')
                ->where('x.bill_item_id = ?',$this->bill_item_id)
                ->andWhere('x.bill_column_setting_id = ?', $billColumnSetting->id)
                ->andWhere('x.type = ?', $billBuildUpQuantityType)
                ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
                ->execute();

            if($billBuildUpQuantityItems or $scheduleOfQuantityLinks)
            {
                $pdo = $this->getTable()->getConnection()->getDbh();
                $userId = sfContext::getInstance()->getUser()->getAttribute('user_id', null, 'sfGuardSecurityUser');

                $this->deleteBuildUpQuantities();

                foreach($billBuildUpQuantityItems as $buildUpItem)
                {
                    $stmt = $pdo->prepare("INSERT INTO ".VariationOrderBuildUpQuantityItemTable::getInstance()->getTableName()." (variation_order_item_id, description, total, sign, priority, type, created_at, updated_at, created_by, updated_by)
                        VALUES
                        (:variation_order_item_id, :description, :total, :sign, :priority, ".VariationOrderBuildUpQuantityItem::TYPE_OMISSION_QTY.", NOW(), NOW(), ".$userId.", ".$userId.") RETURNING id");

                    $stmt->execute(array(
                        'variation_order_item_id' => $this->id,
                        'description' => $buildUpItem['description'],
                        'total' => $buildUpItem['total'],
                        'sign' => $buildUpItem['sign'],
                        'priority' => $buildUpItem['priority']
                    ));

                    $returnId = $stmt->fetch(PDO::FETCH_ASSOC);

                    $billBuildUpQtyFormulatedColumns = DoctrineQuery::create()->select('fc.column_name, fc.value, fc.final_value')
                        ->from('BillBuildUpQuantityFormulatedColumn fc')
                        ->where('fc.relation_id = ?', array($buildUpItem['id']))
                        ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
                        ->execute();

                    foreach($billBuildUpQtyFormulatedColumns as $formulatedColumn)
                    {
                        $stmt = $pdo->prepare("INSERT INTO ".VariationOrderBuildUpQuantityFormulatedColumnTable::getInstance()->getTableName()." (relation_id, column_name, value, final_value, created_at, updated_at, created_by, updated_by)
                            VALUES
                            (:returning_id, :column_name, :value, :final_value, NOW(), NOW(), ".$userId.", ".$userId.")");

                        $stmt->execute(array(
                            'returning_id' => $returnId['id'],
                            'column_name' => $formulatedColumn['column_name'],
                            'value' => $formulatedColumn['value'],
                            'final_value' => $formulatedColumn['final_value']
                        ));
                    }
                }

                $billBuildUpSummary = DoctrineQuery::create()->select('s.linked_total_quantity, s.total_quantity, s.final_quantity, s.apply_conversion_factor, s.conversion_factor_amount, s.conversion_factor_operator, s.rounding_type')
                    ->from('BillBuildUpQuantitySummary s')
                    ->where('s.bill_item_id = ?', array($this->bill_item_id))
                    ->andWhere('s.type = ?', array($billBuildUpQuantityType))
                    ->andWhere('s.bill_column_setting_id = ?', array($billColumnSetting->id))
                    ->limit(1)
                    ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
                    ->fetchOne();

                if($billBuildUpSummary)
                {
                    $applyConversionFactor = $billBuildUpSummary['apply_conversion_factor'] ? 1 : 0;

                    $targetBuildUpSummaryQuery = DoctrineQuery::create()->select('s.id')
                        ->from('VariationOrderBuildUpQuantitySummary s')
                        ->where('s.variation_order_item_id = ?', array($this->id))
                        ->limit(1)
                        ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY);

                    if($targetBuildUpSummaryQuery->count() == 0)
                    {
                        $sql = "INSERT INTO ".VariationOrderBuildUpQuantitySummaryTable::getInstance()->getTableName()." (variation_order_item_id, linked_total_quantity, total_quantity, final_quantity, apply_conversion_factor, conversion_factor_amount, conversion_factor_operator, rounding_type, type, created_at, updated_at, created_by, updated_by)
                        VALUES (".$this->id.", :linked_total_quantity, :total_quantity, :final_quantity, :apply_conversion_factor, :conversion_factor_amount, :conversion_factor_operator, :rounding_type, ".VariationOrderBuildUpQuantityItem::TYPE_OMISSION_QTY.", NOW(), NOW(), ".$userId.", ".$userId.")";
                    }
                    else
                    {
                        $sql = "UPDATE ".VariationOrderBuildUpQuantitySummaryTable::getInstance()->getTableName()." SET linked_total_quantity = :linked_total_quantity, total_quantity = :total_quantity, final_quantity = :final_quantity, apply_conversion_factor = :apply_conversion_factor, conversion_factor_amount = :conversion_factor_amount,
                        conversion_factor_operator = :conversion_factor_operator, rounding_type = :rounding_type, type = ".VariationOrderBuildUpQuantityItem::TYPE_OMISSION_QTY.", created_at = NOW(), updated_at = NOW(), created_by = ".$userId.", updated_by = ".$userId." WHERE variation_order_item_id = ".$this->id;
                    }

                    $stmt = $pdo->prepare($sql);

                    $stmt->execute(array(
                        'linked_total_quantity'      => $billBuildUpSummary['linked_total_quantity'],
                        'total_quantity'             => $billBuildUpSummary['total_quantity'],
                        'final_quantity'             => $billBuildUpSummary['final_quantity'],
                        'apply_conversion_factor'    => $applyConversionFactor,
                        'conversion_factor_amount'   => $billBuildUpSummary['conversion_factor_amount'],
                        'conversion_factor_operator' => $billBuildUpSummary['conversion_factor_operator'],
                        'rounding_type'              => $billBuildUpSummary['rounding_type']
                    ));
                }

                unset($billBuildUpRateItems);

                $this->has_omission_build_up_quantity = true;

                $this->copyQuantityFromLinkedBillItem($billColumnSetting);

                $multiRowsInsert = array();

                foreach($scheduleOfQuantityLinks as $data)
                {
                    $multiRowsInsert[] = "(".$data['schedule_of_quantity_item_id'].", ".$this->id.", ".VariationOrderBuildUpQuantityItem::TYPE_OMISSION_QTY.", NOW(), NOW(), ".$userId.", ".$userId.")";
                }

                if(count($multiRowsInsert) > 0)
                {
                    ScheduleOfQuantityVariationOrderItemXrefTable::getInstance()->getConnection()->fetchAssoc("INSERT INTO ".ScheduleOfQuantityVariationOrderItemXrefTable::getInstance()->getTableName()."
                    (schedule_of_quantity_item_id, variation_order_item_id, type, created_at, updated_at, created_by, updated_by) VALUES
                    ".implode(',', $multiRowsInsert));
                }

                return true;
            }
            else
            {
                return false;//no build up qty to be copied
            }
        }
        else
        {
            return false;
        }
    }

    public function getScheduleOfQuantitiesTotalAmount($type)
    {
        switch($type)
        {
            case VariationOrderBuildUpQuantityItem::TYPE_ADDITIONAL_QTY:
                break;
            case VariationOrderBuildUpQuantityItem::TYPE_OMISSION_QTY:
                break;
            default:
                throw new Exception("invalid type");
        }

        $pdo = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT COALESCE(SUM(xfc.final_value), 0) AS total FROM ".ScheduleOfQuantityItemFormulatedColumnTable::getInstance()->getTableName()." xfc
            JOIN ".ScheduleOfQuantityVariationOrderItemXrefTable::getInstance()->getTableName()." x ON x.schedule_of_quantity_item_id = xfc.relation_id WHERE
            x.variation_order_item_id = ".$this->id." AND x.type = ".$type."
            AND xfc.final_value <> 0 AND xfc.deleted_at IS NULL GROUP BY x.variation_order_item_id");

        $stmt->execute();

        $result = $stmt->fetch(PDO::FETCH_ASSOC);

        return $result['total'];
    }
}
