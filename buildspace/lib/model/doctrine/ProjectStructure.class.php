<?php

/**
 * ProjectStructure
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    buildspace
 * @subpackage model
 * @author     1337 developers
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class ProjectStructure extends BaseProjectStructure
{
    const TYPE_ROOT = 1;
    const TYPE_LEVEL = 2;
    const TYPE_BILL = 4;
    const TYPE_SUPPLY_OF_MATERIAL_BILL = 8;
    const TYPE_SCHEDULE_OF_RATE_BILL = 16;

    const TYPE_ROOT_TEXT = "ROOT";
    const TYPE_LEVEL_TEXT = "LEVEL";
    const TYPE_BILL_TEXT = "BILL";
    const TYPE_SUPPLY_OF_MATERIAL_BILL_TEXT = "SUPPLY OF MATERIAL";
    const TYPE_SCHEDULE_OF_RATE_BILL_TEXT = "SCHEDULE OF RATE";

    const NOTICE_CONTRACTOR_IS_ASSIGNED = "At least one contractor is assigned to Tender";
    const NOTICE_CONTRACTOR_IS_SELECTED = "Contractor Selected on Tenderer Setting";
    const NOTICE_TENDER_ALTERNATIVE_UNTAG_BILL = "All bills must be tagged to Tender Options";
    const NOTICE_TENDER_ALTERNATIVE_IS_SELECTED = "One of the Tender Options must be selected";
    const NOTICE_RATIONALIZE_RATE_IS_IMPORTED = "Latest Rationalized Rates must be imported";
    const NOTICE_SUBPACKAGE_RESOUCE_ASSIGNED = "Resource item assigned to every subpackages";
    const NOTICE_SUBPACKAGE_CONTRACTOR_ASSIGNED = "At least 1 contractor assigned to every subpackages ";
    const NOTICE_SUBPACKAGE_CONTRACTOR_SELECTED = "Contractor selected to every subpackages ";
    const NOTICE_PROJECT_NOT_IN_EBIDDING = "Project not in E-bidding mode";


    public static function getDefaultItemType($type = null)
    {
        $billType = ($type) ? $type : null;

        switch($billType)
        {
            case BillType::TYPE_STANDARD:
                $itemType = BillItem::TYPE_WORK_ITEM;
                break;
            case BillType::TYPE_PROVISIONAL:
                $itemType = BillItem::TYPE_WORK_ITEM;
                break;
            case BillType::TYPE_PRELIMINARY:
                $itemType = BillItem::TYPE_ITEM_LUMP_SUM;
                break;
            case BillType::TYPE_PRIMECOST:
                $itemType = BillItem::TYPE_ITEM_LUMP_SUM;
                break;
            default:
                $itemType = null;
        }

        return $itemType;
    }

    public function canPublishToTender()
    {
        $record = DoctrineQuery::create()->select('COUNT(b.id) AS count')
            ->from('BillType b')
            ->leftJoin('b.ProjectStructure s')
            ->where('s.root_id = ?', $this->id)
            ->andWhere('b.status <> ?', BillType::STATUS_OPEN)
            ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
            ->limit(1)
            ->fetchOne();

        return ($record['count'] > 0) ? false : true;
    }

    public function publishToTender(Doctrine_Connection $con=null)
    {
        $con = is_null($con) ? $this->getTable()->getConnection() : $con;
        $pdo = $con->getDbh();

        if($this->node->isRoot() and $this->canPublishToTender())
        {
            //Swap Remeasurement Qty and Original Qty if any
            $stmt = $pdo->prepare("SELECT DISTINCT bc.id FROM ".BillColumnSettingTable::getInstance()->getTableName()." bc
                JOIN ".ProjectStructureTable::getInstance()->getTableName()." b ON b.id = bc.project_structure_id
                WHERE b.root_id = ".$this->id." AND b.type = ".ProjectStructure::TYPE_BILL."
                AND bc.remeasurement_quantity_enabled IS TRUE AND bc.use_original_quantity IS FALSE
                AND b.deleted_at IS NULL AND bc.deleted_at IS NULL ORDER BY bc.id");

            $stmt->execute();

            $recordsToSwap = $stmt->fetchAll(PDO::FETCH_COLUMN);

            if($recordsToSwap)
            {
                $stmt = $pdo->prepare("UPDATE ".BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName()." fc SET column_name =
                CASE WHEN column_name = '".BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT."'
                THEN '".BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT."'
                ELSE '".BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT."'
                END
                FROM ".BillItemTypeReferenceTable::getInstance()->getTableName()." i
                WHERE i.bill_column_setting_id IN (".implode(',', $recordsToSwap).")
                AND fc.relation_id = i.id
                AND i.deleted_at IS NULL AND fc.deleted_at IS NULL");

                $stmt->execute();

                $stmt = $pdo->prepare("UPDATE ".BillBuildUpQuantityItemTable::getInstance()->getTableName()." SET type =
                CASE WHEN type = ".BillBuildUpQuantityItem::QUANTITY_PER_UNIT_ORIGINAL."
                THEN ".BillBuildUpQuantityItem::QUANTITY_PER_UNIT_REMEASUREMENT."
                ELSE ".BillBuildUpQuantityItem::QUANTITY_PER_UNIT_ORIGINAL."
                END
                WHERE bill_column_setting_id IN (".implode(',', $recordsToSwap).") AND deleted_at IS NULL");

                $stmt->execute();

                $stmt = $pdo->prepare("UPDATE ".BillBuildUpQuantitySummaryTable::getInstance()->getTableName()." SET type =
                CASE WHEN type = ".BillBuildUpQuantityItem::QUANTITY_PER_UNIT_ORIGINAL."
                THEN ".BillBuildUpQuantityItem::QUANTITY_PER_UNIT_REMEASUREMENT."
                ELSE ".BillBuildUpQuantityItem::QUANTITY_PER_UNIT_ORIGINAL."
                END
                WHERE bill_column_setting_id IN (".implode(',', $recordsToSwap).") AND deleted_at IS NULL");

                $stmt->execute();

                /*
                 * we set the remeasurement to 32767(max range for smallint) because of the unique constraint in ScheduleOfQuantityBillItemXrefTable
                 * so that we can successfully swap and save
                 */
                $stmt = $pdo->prepare("UPDATE ".ScheduleOfQuantityBillItemXrefTable::getInstance()->getTableName()." SET type =
                CASE WHEN type = ". BillBuildUpQuantityItem::QUANTITY_PER_UNIT_ORIGINAL."
                THEN 32767
                ELSE 32464
                END
                WHERE bill_column_setting_id IN (".implode(',', $recordsToSwap).")");

                $stmt->execute();

                $stmt = $pdo->prepare("UPDATE ".ScheduleOfQuantityBillItemXrefTable::getInstance()->getTableName()."
                SET type =
                CASE WHEN type = 32767
                THEN ".BillBuildUpQuantityItem::QUANTITY_PER_UNIT_REMEASUREMENT."
                ELSE ".BillBuildUpQuantityItem::QUANTITY_PER_UNIT_ORIGINAL."
                END
                WHERE type = 32767 OR type = 32464 AND bill_column_setting_id IN (".implode(',', $recordsToSwap).")");

                $stmt->execute();
                /*
                 * Reset bill column setting to use original qty since he have swapped the remeasurement qty to be original qty
                 */
                $stmt = $pdo->prepare("UPDATE ".BillColumnSettingTable::getInstance()->getTableName()."
                    SET use_original_quantity = TRUE
                    WHERE id IN (".implode(',', $recordsToSwap).")");

                $stmt->execute();
            }

            // change status
            $this->MainInformation->status         = ProjectMainInformation::STATUS_TENDERING;
            $this->MainInformation->tender_type_id = ProjectMainInformation::TENDER_TYPE_TENDERED;
            $this->MainInformation->published_at   = 'NOW()';
            $this->MainInformation->unique_id      = $this->generateProjectUniqueId();

            $this->MainInformation->save($con);

            //Create Tender
            $tender = $this->TenderSetting;

            if($tender->isNew())
            {
                $tender->project_structure_id = $this->id;
                $tender->save($con);
            }

            ProjectRevisionTable::updateProjectRevisionStatusToLocked($this);

            $this->setPrintFullDecimal();

            $sfBillRefGenerator = new sfBillReferenceGenerator($this);
            $sfBillRefGenerator->process();

            $assignedUsers = ProjectUserPermissionTable::getAssignedUserIdsByProjectAndStatus($this, ProjectUserPermission::STATUS_TENDERING);
            //if user permission for tendering is empty then we use user permission from pre tender as user permission for tendering
            if(empty($assignedUsers))
            {
                ProjectUserPermissionTable::copyExistingUsersPermissionByStatus($this, ProjectUserPermission::STATUS_PROJECT_BUILDER, ProjectUserPermission::STATUS_TENDERING);
            }
        }
        else
        {
            throw new Exception('Cannot publish to tender');
        }
    }

    public static function getDefaultItemTypeByElementId($elementId)
    {
        $element = DoctrineQuery::create()->select('e.id, p.id, t.id, t.type')
            ->from('BillElement e')
            ->leftJoin('e.ProjectStructure p')
            ->leftJoin('p.BillType t')
            ->where('e.id = ?', $elementId)
            ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
            ->fetchOne();

        return self::getDefaultItemType($element['ProjectStructure']['BillType']['type']);
    }

    public function updateProjectElementAndItemTotalAfterMarkup()
    {
        if(!$this->node->isRoot()) return;

        $bills = DoctrineQuery::create()
            ->from('ProjectStructure b')
            ->where('b.lft >= ? AND b.rgt <= ?', array( $this->lft, $this->rgt ))
            ->andWhere('b.root_id = ?', $this->id)
            ->andWhere('b.id <> ?', $this->id)
            ->andWhere('b.type <= ?', ProjectStructure::TYPE_BILL)
            ->andWhere('b.deleted_at IS NULL')
            ->addOrderBy('b.lft ASC')
            ->execute();

        foreach($bills as $bill)
        {
            $bill->updateAllItemTotalAfterMarkup();
        }
    }

    public function updateAllItemTotalAfterMarkup()
    {
        ProjectStructureTable::updateAllItemTotalAfterMarkupByBillId($this->id, $this->BillColumnSettings->toArray(), $this->BillMarkupSetting->toArray());

        foreach($this->Elements as $element)
        {
            if($element instanceof BillElement and !$element->isNew())
            {
                $element->updateMarkupAmount();
            }
        }
    }

    public function setAsDeleted()
    {
        return Doctrine_Query::create()
            ->delete('ProjectStructure p')
            ->where('p.root_id = ?', $this->root_id)
            ->andWhere('p.lft >= ? AND p.rgt <= ?', array($this->lft, $this->rgt))
            ->execute();
    }

    public function delete(Doctrine_Connection $conn = null)
    {
        if ( ! ProjectStructureTable::canBeDeletedById($this->id) )
        {
            throw new Exception('This project cannot be deleted due to it has been used in RFQ. Please remove it from RFQ before deleting again.');
        }

        $records = DoctrineQuery::create()->select('p.id')
            ->from('ProjectStructure p')
            ->where('p.root_id = ?', $this->root_id)
            ->andWhere('p.lft >= ? AND p.rgt <= ?', array($this->lft, $this->rgt))
            ->addOrderBy('p.lft ASC')
            ->execute();

        $deletedIds = array();

        foreach($records as $record)
        {
            switch($record->type)
            {
                case self::TYPE_LEVEL:
                    if(!$record->getLevel()->isNew())
                    {
                        $record->Level->delete();
                    }
                    break;
                case self::TYPE_BILL:
                    break;
                case self::TYPE_SUPPLY_OF_MATERIAL_BILL:
                    break;
                case self::TYPE_SCHEDULE_OF_RATE_BILL:
                    break;
                default:
                    break;
            }

            $deletedIds[] = array('id' => $record->id);
        }

        if($this->node->isRoot())
        {
            Doctrine_Query::create()
                ->delete('ProjectUserPermission p')
                ->where('p.project_structure_id = ?', $this->root_id)
                ->execute();
        }

        $this->setAsDeleted();

        //recalculate left-right values when deleting child nodes
        if(!$this->node->isRoot())
        {
            $first = $this->rgt + 1;
            $delta = $this->lft - $this->rgt - 1;

            Utilities::shiftRightLeftNestedSet(get_class($this), $first, $delta, $this->root_id, $conn);
        }

        return $deletedIds;
    }

    public function generateProjectUniqueId()
    {
        return ProjectStructureTable::generateProjectUniqueIdbyProjectId($this->id, $this->created_at, $this->created_by);
    }

    public function save(Doctrine_Connection $conn = null)
    {
        $isNew = $this->isNew() ? true : false;

        parent::save();

        if($isNew)
        {
            switch($this->type)
            {
                case self::TYPE_BILL:
                    $billColumnSetting = new BillColumnSetting();
                    $billColumnSetting->name = 'Default';
                    $billColumnSetting->quantity = 1;
                    $billColumnSetting->project_structure_id = $this->id;
                    $billColumnSetting->save($conn);

                    $billMarkupSetting = new BillMarkupSetting();
                    $billMarkupSetting->project_structure_id = $this->id;
                    $billMarkupSetting->rounding_type = BillMarkupSetting::ROUNDING_TYPE_DISABLED;
                    $billMarkupSetting->save($conn);
                    break;
                default:
                    break;
            }
        }
    }

    public function checkConsultantPostContractRequirement()
    {
        $success = true;

        $items = array();

        array_push($items, $this->checkContractorAssigned($success, 1));

        array_push($items, $this->checkContractorIsSelected($success, 2));

        array_push($items, $this->checkProjectNotInEbidding($success, 3));

        if(count($this->getTenderAlternatives(true)))
        {
            $success = (empty($this->getUntagTenderAlternativeBillIds()));
            $items[] = [
                'count' => 3,
                'notice' => ProjectStructure::NOTICE_TENDER_ALTERNATIVE_UNTAG_BILL,
                'success' => $success
            ];
        }
        
        return array(
            'success' => $success,
            'items' => $items
        );
    }

    public function getRoot()
    {
        if($this->node->isRoot())
        {
            return $this;
        }
        else
        {
            return $this->getTable()->find($this->root_id);
        }
    }

    public function checkContractorPostContractRequirement()
    {
        $items   = [];

        $pdo = ProjectStructureTable::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT COUNT(i.id)
        FROM ".ProjectStructureTable::getInstance()->getTableName()." p
        JOIN ".ProjectStructureTable::getInstance()->getTableName()." b ON b.root_id = p.id
        JOIN ".BillElementTable::getInstance()->getTableName()." e ON e.project_structure_id = b.id
        JOIN ".BillItemTable::getInstance()->getTableName()." i ON i.element_id = e.id
        JOIN ".TenderBillItemRationalizedRatesTable::getInstance()->getTableName()." r ON r.bill_item_id = i.id
        WHERE p.id = ".$this->id." AND p.type = " . ProjectStructure::TYPE_ROOT . "
        AND p.deleted_at IS NULL AND b.deleted_at IS NULL AND e.deleted_at IS NULL
        AND i.deleted_at IS NULL AND i.project_revision_deleted_at IS NULL
        GROUP BY p.id");

        $stmt->execute();

        $rationalizeRateCount = $stmt->fetch(PDO::FETCH_COLUMN, 0);

        
        $rationalizeRateSuccess = !empty($rationalizeRateCount);
        $tenderAlternativeSuccess = true;

        $items[] = [
            'count' => 1,
            'notice' => ProjectStructure::NOTICE_RATIONALIZE_RATE_IS_IMPORTED,
            'success' => $rationalizeRateSuccess
        ];
        
        if(!empty($this->getTenderAlternatives(true)))
        {
            $tenderAlternativeSuccess = !empty($this->getAwardedTenderAlternative(true));

            $items[] = [
                'count' => 2,
                'notice' => ProjectStructure::NOTICE_TENDER_ALTERNATIVE_IS_SELECTED,
                'success' => $tenderAlternativeSuccess
            ];
        }

        return [
            'success' => ($rationalizeRateSuccess && $tenderAlternativeSuccess),
            'items' => $items
        ];
    }

    public function checkSubPackagesContractor(&$success, $counter)
    {
        $item = array(
            'count' => $counter,
            'notice' => self::NOTICE_SUBPACKAGE_CONTRACTOR_ASSIGNED,
            'success' => true
        );

        foreach($this->SubPackages as $subpackage)
        {
            if(!count($subpackage->Companies->toArray()))
            {
                $success = $item['success'] = false;
            }
        }

        return $item;
    }

    public function checkSubPackagesContractorSelected(&$success, $counter)
    {
        $item = array(
            'count' => $counter,
            'notice' => self::NOTICE_SUBPACKAGE_CONTRACTOR_SELECTED,
            'success' => true
        );

        foreach($this->SubPackages as $subpackage)
        {
            if(!$subpackage->selected_company_id)
            {
                $success = $item['success'] = false;
            }
        }

        return $item;
    }

    public function checkSubPackagesResource(&$success, $counter)
    {
        $item = array(
            'count' => $counter,
            'notice' => self::NOTICE_SUBPACKAGE_RESOUCE_ASSIGNED,
            'success' => true
        );

        foreach($this->SubPackages as $subpackage)
        {
            if(!count($subpackage->ResourceItems->toArray()))
            {
                $success = $item['success'] = false;
            }
        }

        return $item;
    }

    public function checkContractorAssigned(&$success, $counter)
    {
        $item = array(
            'count' => $counter,
            'notice' => self::NOTICE_CONTRACTOR_IS_ASSIGNED,
            'success' => null
        );

        if(count($this->Companies->toArray()))
        {
            $item['success'] = true;
        }
        else
        {
            $success = $item['success'] = false;
        }

        return $item;
    }

    public function checkProjectNotInEbidding(&$success, $counter)
    {
        $item = array(
            'count' => $counter,
            'notice' => self::NOTICE_PROJECT_NOT_IN_EBIDDING,
            'success' => false
        );

        if($this->MainInformation->getEProjectProject()->status_id == EProjectProject::STATUS_TYPE_E_BIDDING)
        {
            $item['success'] = false;
        }
        else
        {
            $item['success'] = true;
        }

        return $item;
    }

    public function checkContractorIsSelected(&$success, $counter)
    {
        $item = array(
            'count' => $counter,
            'notice' => self::NOTICE_CONTRACTOR_IS_SELECTED,
            'success' => null
        );
        
        //Check Awarded Company
        if($this->TenderSetting->awarded_company_id)
        {
            $success = true;

            if(!empty($this->getTenderAlternatives(true)))
            {
               $success = !empty($this->getAwardedTenderAlternative(true));
            }
            
            $item['success'] = $success;
        }
        else
        {
            $success = $item['success'] = false;
        }

        return $item;
    }

    public function getDebitCreditNoteClaimOverallTotal($postContractRevision = null)
    {
        if($postContractRevision)
        {
            $postContractRevision = Doctrine_Core::getTable('PostContractClaimRevision')->find(intval($postContractRevision['id']));
        }

        return $this->getDebitCreditNoteTotalByClaimRevision($postContractRevision, '<=');
    }

    public function getDebitCreditNoteTotalByClaimRevision(PostContractClaimRevision $postContractRevision=null, $operator='=')
    {
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return false;
        }

        $whereClause = "";
        if($postContractRevision)
        {
            $whereClause = " AND rev.version ".$operator." ".$postContractRevision->version." ";
        }

        $pdo  = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("
            SELECT SUM((cni.rate * cni.quantity)) AS total
            FROM ".DebitCreditNoteClaimItemTable::getInstance()->getTableName()." cni
            JOIN ".DebitCreditNoteClaimTable::getInstance()->getTableName()." cn ON cni.debit_credit_note_claim_id = cn.id
            JOIN ".ClaimCertificateTable::getInstance()->getTableName()." c ON cn.claim_certificate_id = c.id
            JOIN ".PostContractClaimRevisionTable::getInstance()->getTableName()." rev ON c.post_contract_claim_revision_id = rev.id
            WHERE cn.project_structure_id = ".$this->id." AND rev.post_contract_id = ".$this->PostContract->id."
            {$whereClause}
            AND cni.deleted_at IS NULL AND cn.deleted_at IS NULL AND rev.deleted_at IS NULL
        ");
        
        $stmt->execute();
        
        return $stmt->fetch(PDO::FETCH_COLUMN, 0);
    }

    public function getDebitCreditNoteBreakdownTotalByClaimRevision(PostContractClaimRevision $postContractRevision=null, $operator='=')
    {
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return false;
        }

        $whereClause = "";
        if($postContractRevision)
        {
            $whereClause = " AND rev.version ".$operator." ".$postContractRevision->version." ";
        }

        $pdo  = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("
            SELECT a.id, a.description, SUM((cni.rate * cni.quantity)) AS total
            FROM ".AccountCodeTable::getInstance()->getTableName()." a
            JOIN ".DebitCreditNoteClaimItemTable::getInstance()->getTableName()." cni ON cni.account_code_id = a.id
            JOIN ".DebitCreditNoteClaimTable::getInstance()->getTableName()." cn ON cni.debit_credit_note_claim_id = cn.id
            JOIN ".ClaimCertificateTable::getInstance()->getTableName()." c ON cn.claim_certificate_id = c.id
            JOIN ".PostContractClaimRevisionTable::getInstance()->getTableName()." rev ON c.post_contract_claim_revision_id = rev.id
            WHERE cn.project_structure_id = ".$this->id." AND rev.post_contract_id = ".$this->PostContract->id."
            {$whereClause}
            AND a.deleted_at IS NULL AND cni.deleted_at IS NULL AND cn.deleted_at IS NULL AND rev.deleted_at IS NULL
            GROUP BY a.id
            ORDER BY a.priority ASC
        ");
        
        $stmt->execute();
        
        return $stmt->fetchAll(PDO::FETCH_UNIQUE|PDO::FETCH_ASSOC);
    }

    public function getRequestForVariationClaimOverallTotal($postContractRevision = null)
    {
        //request for variation only relates with root (project)
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return false;
        }

        $pdo = $this->getTable()->getConnection()->getDbh();
        
        $selectedRevisionClause = "";
        if($postContractRevision)
        {
            $claimCertificates = PostContractClaimRevisionTable::getClaimCertificates($postContractRevision['id'], '<=');

            if( count($certIds = array_column($claimCertificates, 'id')) > 0 ) $selectedRevisionClause = "AND xref.claim_certificate_id in (" . implode(',', $certIds) . ")";
        }

        $stmt = $pdo->prepare("SELECT DISTINCT vo.id
        FROM ".VariationOrderTable::getInstance()->getTableName()." vo
        JOIN ".VariationOrderClaimCertificateTable::getInstance()->getTableName()." xref on xref.variation_order_id = vo.id
        WHERE vo.project_structure_id = ".$this->id."
        {$selectedRevisionClause}
        AND vo.deleted_at IS NULL
        GROUP BY vo.id");

        $stmt->execute();

        $claimedVariationOrderIds = $stmt->fetchAll(PDO::FETCH_COLUMN, 0);

        $variationOrderIdsClause = "";
        if(!empty($claimedVariationOrderIds))
        {
            $variationOrderIdsClause = " AND vo.id NOT IN (" . implode(',', $claimedVariationOrderIds) . ")";
        }

        $stmt = $pdo->prepare("SELECT ROUND(COALESCE(SUM(c.amount), 0), 2) AS total_claim
        FROM ".RequestForVariationItemClaimTable::getInstance()->getTableName()." c 
        JOIN ".VariationOrderItemTable::getInstance()->getTableName()." i ON i.id = c.variation_order_item_id
        JOIN ".VariationOrderTable::getInstance()->getTableName()." vo ON i.variation_order_id = vo.id
        JOIN ".RequestForVariationItemClaimCertificateTable::getInstance()->getTableName()." xref on xref.variation_order_item_id = i.id
        WHERE vo.project_structure_id = ".$this->id."
        {$variationOrderIdsClause}
        AND vo.eproject_rfv_id IS NOT NULL
        AND i.is_from_rfv IS TRUE
        {$selectedRevisionClause}
        AND vo.deleted_at IS NULL AND i.deleted_at IS NULL GROUP BY vo.project_structure_id");

        $stmt->execute();

        $result = $stmt->fetch(PDO::FETCH_COLUMN, 0);

        return $result ? $result : 0;
    }

    public function getVariationOrderOverallTotal($postContractRevision = null)
    {
        //variation order only relates with root (project)
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return false;
        }

        $pdo = $this->getTable()->getConnection()->getDbh();

        $selectedRevisionClause = "";
        if($postContractRevision)
        {
            $claimCertificates = PostContractClaimRevisionTable::getClaimCertificates($postContractRevision->id, '<=');
            if( count($certIds = array_column($claimCertificates, 'id')) > 0 ) $selectedRevisionClause = "AND xref.claim_certificate_id in (" . implode(',', $certIds) . ")";
        }

        $stmt = $pdo->prepare("SELECT ROUND(COALESCE(SUM(
            ROUND((i.total_unit * i.addition_quantity * i.rate) - (i.total_unit * i.omission_quantity * i.rate), 2)
        ), 0), 2) AS nett_omission_addition
        FROM ".VariationOrderItemTable::getInstance()->getTableName()." i
        JOIN ".VariationOrderTable::getInstance()->getTableName()." vo ON i.variation_order_id = vo.id
        LEFT JOIN ".VariationOrderClaimCertificateTable::getInstance()->getTableName()." xref on xref.variation_order_id = vo.id
        WHERE vo.project_structure_id = ".$this->id." AND vo.is_approved IS TRUE
        AND i.type <> ".VariationOrderItem::TYPE_HEADER." AND i.rate <> 0
        {$selectedRevisionClause}
        AND vo.deleted_at IS NULL AND i.deleted_at IS NULL GROUP BY vo.project_structure_id");

        $stmt->execute();

        $result = $stmt->fetch(PDO::FETCH_COLUMN, 0);

        return $result ? $result : 0;
    }

    public function getVariationOrderOmissionTotal($postContractRevision = null)
    {
        //variation order only relates with root (project)
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return false;
        }

        $pdo = $this->getTable()->getConnection()->getDbh();

        $selectedRevisionClause = "";
        if($postContractRevision)
        {
            $claimCertificates = PostContractClaimRevisionTable::getClaimCertificates($postContractRevision['id'], '<=');
            if( count($certIds = array_column($claimCertificates, 'id')) > 0 ) $selectedRevisionClause = "AND xref.claim_certificate_id in (" . implode(',', $certIds) . ")";
        }

        $stmt = $pdo->prepare("SELECT ROUND(COALESCE(SUM(
            ROUND(i.total_unit * i.omission_quantity * i.rate, 2)
        ), 0), 2) AS nett_omission
        FROM ".VariationOrderItemTable::getInstance()->getTableName()." i
        JOIN ".VariationOrderTable::getInstance()->getTableName()." vo ON i.variation_order_id = vo.id
        LEFT JOIN ".VariationOrderClaimCertificateTable::getInstance()->getTableName()." xref on xref.variation_order_id = vo.id
        WHERE vo.project_structure_id = ".$this->id." AND vo.is_approved IS TRUE
        AND i.type <> ".VariationOrderItem::TYPE_HEADER." AND i.rate <> 0
        {$selectedRevisionClause}
        AND vo.deleted_at IS NULL AND i.deleted_at IS NULL GROUP BY vo.project_structure_id");

        $stmt->execute();

        $result = $stmt->fetch(PDO::FETCH_COLUMN, 0);

        return $result ? $result : 0;
    }

    public function getVariationOrderAdditionTotal($postContractRevision = null)
    {
        //variation order only relates with root (project)
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return false;
        }

        $pdo = $this->getTable()->getConnection()->getDbh();

        $selectedRevisionClause = "";
        if($postContractRevision)
        {
            $claimCertificates = PostContractClaimRevisionTable::getClaimCertificates($postContractRevision['id'], '<=');
            if( count($certIds = array_column($claimCertificates, 'id')) > 0 ) $selectedRevisionClause = "AND xref.claim_certificate_id in (" . implode(',', $certIds) . ")";
        }

        $stmt = $pdo->prepare("SELECT ROUND(COALESCE(SUM(
            ROUND(i.total_unit * i.addition_quantity * i.rate, 2)
        ), 0), 2) AS nett_addition
        FROM ".VariationOrderItemTable::getInstance()->getTableName()." i
        JOIN ".VariationOrderTable::getInstance()->getTableName()." vo ON i.variation_order_id = vo.id
        LEFT JOIN ".VariationOrderClaimCertificateTable::getInstance()->getTableName()." xref on xref.variation_order_id = vo.id
        WHERE vo.project_structure_id = ".$this->id." AND vo.is_approved IS TRUE
        AND i.type <> ".VariationOrderItem::TYPE_HEADER." AND i.rate <> 0
        {$selectedRevisionClause}
        AND vo.deleted_at IS NULL AND i.deleted_at IS NULL GROUP BY vo.project_structure_id");

        $stmt->execute();

        $result = $stmt->fetch(PDO::FETCH_COLUMN, 0);

        return $result ? $result : 0;
    }

    public function getVariationOrderUpToDateClaimAmountPercentage($postContractRevision = null)
    {
        return Utilities::percent($this->getVariationOrderUpToDateClaimAmount($postContractRevision), $this->getVariationOrderOverallTotal());
    }

    public function getVariationOrderUpToDateClaimAmount($postContractRevision = null)
    {
        //variation order only relates with root (project)
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return false;
        }

        if(is_null($postContractRevision)) $postContractRevision = PostContractClaimRevisionTable::getCurrentSelectedProjectRevision($this->PostContract, false);

        $voWorkDoneByVersions = $this->NewPostContractFormInformation->getVOWorkDoneGroupByVersions($postContractRevision);

        return $this->NewPostContractFormInformation->calculateVOWorkDoneAmount($voWorkDoneByVersions);
    }

    public function getVariationOrderImportedClaimAmount($postContractRevision = null)
    {
        //variation order only relates with root (project)
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return false;
        }

        $pdo = $this->getTable()->getConnection()->getDbh();

        if( ! $postContractRevision )
        {
            $postContractRevision = PostContractClaimRevisionTable::getCurrentProjectRevision($this->PostContract, false);
        }

        $stmt = $pdo->prepare("SELECT SUM(COALESCE(c.up_to_date_amount, 0)) as up_to_date_amount
            FROM " . ImportedVariationOrderTable::getInstance()->getTableName() . " vo
            JOIN " . PostContractClaimRevisionTable::getInstance()->getTableName() . " rev ON rev.id = vo.revision_id
            LEFT JOIN " . ImportedVariationOrderItemTable::getInstance()->getTableName() . " i ON vo.id = i.imported_variation_order_id
            LEFT JOIN (
                SELECT i.id, c.up_to_date_amount
                FROM " . ImportedVariationOrderClaimItemTable::getInstance()->getTableName() . " c
                JOIN " . PostContractClaimRevisionTable::getInstance()->getTableName() . " rev ON rev.id = c.revision_id
                JOIN " . ImportedVariationOrderItemTable::getInstance()->getTableName() . " i ON i.id = c.imported_variation_order_item_id
                JOIN " . ImportedVariationOrderTable::getInstance()->getTableName() . " vo ON vo.id = i.imported_variation_order_id
                WHERE vo.project_structure_id = {$this->id}
                AND rev.version = {$postContractRevision->version}
            ) c on c.id = i.id
            WHERE vo.project_structure_id = {$this->id}
            AND rev.version <= {$postContractRevision->version}");

        $stmt->execute();

        return $stmt->fetch(PDO::FETCH_COLUMN);
    }

    public function getMaterialOnSiteUpToDateClaimAmount()
    {
        //variation order only relates with root (project)
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return false;
        }

        $pdo = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT ROUND(COALESCE(SUM(mos.total_after_reduction), 0), 2) AS amount
        FROM ".MaterialOnSiteTable::getInstance()->getTableName()." mos
        WHERE mos.project_structure_id = ".$this->id." AND mos.status = ".MaterialOnSite::STATUS_TYPE_THIS_CLAIM."
        AND mos.deleted_at IS NULL
        GROUP BY mos.project_structure_id");

        $stmt->execute();

        return $stmt->fetch(PDO::FETCH_COLUMN, 0);
    }

    public function getMaterialOnSiteImportedClaimAmount($postContractRevision = null)
    {
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return false;
        }

        $pdo = $this->getTable()->getConnection()->getDbh();

        if( ! $postContractRevision )
        {
            $postContractRevision = PostContractClaimRevisionTable::getCurrentProjectRevision($this->PostContract);
        }

        $stmt = $pdo->prepare("SELECT SUM(COALESCE(mosi.final_amount, 0)) as final_amount
            FROM " . ImportedMaterialOnSiteTable::getInstance()->getTableName() . " mos
            JOIN " . PostContractClaimRevisionTable::getInstance()->getTableName() . " rev ON rev.id = mos.revision_id
            JOIN " . ImportedMaterialOnSiteItemTable::getInstance()->getTableName() . " mosi on mosi.imported_material_on_site_id = mos.id
            WHERE mos.project_structure_id = {$this->id}
            AND rev.version = {$postContractRevision['version']}");

        $stmt->execute();

        return $stmt->fetch(PDO::FETCH_COLUMN);
    }

    public function moveTo(ProjectStructure $targetItem, $lastPosition=false)
    {
        $con = $this->getTable()->getConnection();

        if($this->node->isRoot())
            return false;//root item (main project) cannot be moved

        try
        {
            $con->beginTransaction();

            if($targetItem->node->isRoot())
            {
                $this->node->moveAsFirstChildOf($targetItem);
            }
            else
            {
                if($lastPosition)
                {
                    $this->node->moveAsNextSiblingOf($targetItem);
                }
                else
                {
                    $this->node->moveAsPrevSiblingOf($targetItem);
                }

                $this->save();
            }

            $con->commit();

            return true;
        }
        catch(Exception $e)
        {
            $con->rollback();
            throw $e;
        }
    }

    public function indent()
    {
        $indented = false;

        if($this->node->hasPrevSibling() and $this->node->getPrevSibling()->type == ProjectStructure::TYPE_LEVEL)
        {
            $prevSibling = $this->node->getPrevSibling();

            $this->node->moveAsLastChildOf($prevSibling);

            $this->refresh();

            $indented = true;
        }

        return $indented;
    }

    public function outdent()
    {
        $parent = $this->node->getParent();

        if(!$parent || !$parent->node)
        {
            return false;
        }

        if(!$parent->node->isRoot() and (($this->type == ProjectStructure::TYPE_LEVEL) or ($this->type != ProjectStructure::TYPE_LEVEL and !$this->node->hasNextSibling())))
        {
            $parent = $this->node->getParent();

            $siblings = DoctrineQuery::create()->select('s.id')
                ->from('ProjectStructure s')
                ->where('s.root_id = ?',$this->root_id)
                ->andWhere('s.level = ?', $this->level)
                ->andWhere('s.lft BETWEEN ? AND ?', array($parent->lft, $parent->rgt))
                ->andWhere('s.lft > ?', $this->rgt)
                ->addOrderBy('s.lft ASC')
                ->execute();

            foreach($siblings as $sibling)
            {
                $sibling->node->moveAsLastChildOf($this);

                $this->refresh();
            }

            unset($siblings);

            $this->node->moveAsNextSiblingOf($parent);

            $this->refresh();

            return true;
        }
        else
        {
            return false;
        }
    }

    public function setPrintFullDecimal()
    {
        ProjectStructureTable::setPrintFullDecimalByProjectId($this->id);
    }

    public function getBills()
    {
        return DoctrineQuery::create()
            ->select('s.id, s.title, s.type, s.level, t.type, t.status, c.id, c.quantity, c.use_original_quantity, bls.id')
            ->from('ProjectStructure s')
            ->leftJoin('s.BillType t')
            ->leftJoin('s.BillColumnSettings c')
            ->leftJoin('s.BillLayoutSetting bls')
            ->where('s.lft >= ? AND s.rgt <= ?', array( $this->lft, $this->rgt ))
            ->andWhere('s.root_id = ?', $this->id)
            ->andWhere('s.type <= ?', self::TYPE_BILL)
            ->addOrderBy('s.lft ASC')
            ->fetchArray();
    }

    /*
     * Validation against data with qty value is set but grand total qty is empty(zero).
     * This probably happened during bill import which we couldn't replicate but it happened
     * quite few times at client site.
     */
    public function validateEmptyGrandTotalQty()
    {
        $pdo = $this->getTable()->getConnection()->getDbh();

        if($this->type == ProjectStructure::TYPE_ROOT)
        {
            $sqlExt = "bill.root_id = ".$this->id." ";
        }
        else
        {
            $sqlExt = "bill.id = ".$this->id." ";
        }

        $stmt = $pdo->prepare("SELECT DISTINCT item.id
            FROM " . BillItemTable::getInstance()->getTableName() . " AS item
            JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " AS type ON type.bill_item_id = item.id
            JOIN " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " AS type_fc ON type_fc.relation_id = type.id
            JOIN " . BillElementTable::getInstance()->getTableName() . " AS element ON item.element_id = element.id
            JOIN " . ProjectStructureTable::getInstance()->getTableName() . " AS bill ON element.project_structure_id = bill.id
            JOIN " . BillColumnSettingTable::getInstance()->getTableName() . " AS bill_column_setting ON bill.id = bill_column_setting.project_structure_id AND type.bill_column_setting_id = bill_column_setting.id
            WHERE ".$sqlExt."
            AND bill_column_setting.use_original_quantity IS TRUE
            AND type_fc.column_name = '" . BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT . "'
            AND item.grand_total_quantity = 0 AND type_fc.final_value <> 0
            AND item.project_revision_deleted_at IS NULL AND item.deleted_at IS NULL AND type.deleted_at IS NULL
            AND type_fc.deleted_at IS NULL AND type_fc.final_value IS NOT NULL
            AND element.deleted_at IS NULL AND bill.deleted_at IS NULL AND bill_column_setting.deleted_at IS NULL");

        $stmt->execute();

        $emptyGrandTotalQtyOriginalQtyItems = $stmt->fetchAll(PDO::FETCH_COLUMN, 0);

        $stmt = $pdo->prepare("SELECT DISTINCT item.id
            FROM " . BillItemTable::getInstance()->getTableName() . " AS item
            JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " AS type ON type.bill_item_id = item.id
            JOIN " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " AS type_fc ON type_fc.relation_id = type.id
            JOIN " . BillElementTable::getInstance()->getTableName() . " AS element ON item.element_id = element.id
            JOIN " . ProjectStructureTable::getInstance()->getTableName() . " AS bill ON element.project_structure_id = bill.id
            JOIN " . BillColumnSettingTable::getInstance()->getTableName() . " AS bill_column_setting ON bill.id = bill_column_setting.project_structure_id AND type.bill_column_setting_id = bill_column_setting.id
            WHERE ".$sqlExt."
            AND bill_column_setting.use_original_quantity IS FALSE
            AND type_fc.column_name = '" . BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT . "'
            AND item.grand_total_quantity = 0 AND type_fc.final_value <> 0
            AND item.project_revision_deleted_at IS NULL AND item.deleted_at IS NULL AND type.deleted_at IS NULL
            AND type_fc.deleted_at IS NULL AND type_fc.final_value IS NOT NULL
            AND element.deleted_at IS NULL AND bill.deleted_at IS NULL AND bill_column_setting.deleted_at IS NULL");

        $stmt->execute();

        $emptyGrandTotalQtyRemeasurementQtyItems = $stmt->fetchAll(PDO::FETCH_COLUMN, 0);

        return array_unique(array_merge($emptyGrandTotalQtyOriginalQtyItems, $emptyGrandTotalQtyRemeasurementQtyItems));
    }

    /*
     * To validate bill items with empty(zero) grand total qty. This validation validates against certain item types
     * because some item types are allowed to have empty grand total qty (before publish to tender).
     */
    public function validateZeroGrandTotalQty()
    {
        $pdo = $this->getTable()->getConnection()->getDbh();

        if($this->type == ProjectStructure::TYPE_ROOT)
        {
            $sqlExt = "bill.root_id = ".$this->id." ";
        }
        else
        {
            $sqlExt = "bill.id = ".$this->id." ";
        }

        $stmt = $pdo->prepare("SELECT DISTINCT item.id
        FROM " . BillItemTable::getInstance()->getTableName() . " AS item
        JOIN " . BillElementTable::getInstance()->getTableName() . " AS element ON item.element_id = element.id
        JOIN " . ProjectStructureTable::getInstance()->getTableName() . " AS bill ON element.project_structure_id = bill.id
        WHERE ".$sqlExt."
        AND item.grand_total_quantity = 0
        AND item.type NOT IN (".BillItem::TYPE_HEADER.", ".BillItem::TYPE_HEADER_N.", ".BillItem::TYPE_NOID.", ".BillItem::TYPE_ITEM_NOT_LISTED.", ".BillItem::TYPE_ITEM_RATE_ONLY.")
        AND item.project_revision_deleted_at IS NULL AND item.deleted_at IS NULL
        AND element.deleted_at IS NULL AND bill.deleted_at IS NULL");

        $stmt->execute();

        return $stmt->fetchAll(PDO::FETCH_COLUMN, 0);
    }

    public function getLatestProjectRevision()
    {
        return ProjectRevisionTable::getLatestProjectRevisionFromBillId($this->id);
    }

    public function getLatestLockedProjectRevision()
    {
        return ProjectRevisionTable::getLatestLockedProjectRevisionFromBillId($this->id);
    }

    public function getCurrentSelectedProjectRevision()
    {
        return ProjectRevisionTable::getCurrentSelectedProjectRevisionFromBillId($this->id);
    }

    public function getSelectedContractor()
    {
        $tenderSetting = $this->TenderSetting;
        $companyId     = $tenderSetting ? $tenderSetting->awarded_company_id : -1;

        if(!empty($this->getTenderAlternatives(true)))
        {
            //reset company id if there is an awarded company but no awarded tender alternative
            $companyId = $this->getAwardedTenderAlternative(true) ? $companyId : -1;
        }

        return Doctrine_Core::getTable('Company')->find($companyId);
    }

    public function getPostContractClaimUpToDatePercentage($type, $postContractRevision = null)
    {
        return Utilities::percent($this->getPostContractClaimUpToDateAmount($type, $postContractRevision), $this->getPostContractClaimOverallTotal($type, $postContractRevision));
    }

    public function getPostContractClaimUpToDateAmount($type, $postContractRevision = null)
    {
        $pdo  = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT pc.id AS post_contract_claim_id, i.up_to_date_amount AS up_to_date_amount, c.revision AS revision
        FROM " . PostContractClaimTable::getInstance()->getTableName() . " pc
        JOIN " . PostContractClaimClaimTable::getInstance()->getTableName() . " c ON c.post_contract_claim_id = pc.id
        JOIN " . PostContractClaimClaimItemTable::getInstance()->getTableName() . " i ON i.post_contract_claim_claim_id = c.id 
        WHERE pc.project_structure_id = " . $this->id . " 
        AND pc.status = ".PostContractClaim::STATUS_APPROVED."
        AND pc.type = ".$type."
        AND c.status = ".PostContractClaimClaim::STATUS_CLOSED."
        AND pc.deleted_at IS NULL AND c.deleted_at IS NULL AND i.deleted_at IS NULL");

        $stmt->execute();

        $upToDateClaims = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $selectedRevisionClause = "";
        if($postContractRevision)
        {
            $claimCertificates = PostContractClaimRevisionTable::getClaimCertificates($postContractRevision['id'], PostContractClaimTable::hasProgressClaim($type) ? '<=' : '=');
            if( count($certIds = array_column($claimCertificates, 'id')) > 0 ) $selectedRevisionClause = "AND c.claim_certificate_id in (" . implode(',', $certIds) . ")";
        }

        $stmt = $pdo->prepare("SELECT pc.id AS post_contract_claim_id, max(c.revision) AS latest_revision
        FROM " . PostContractClaimTable::getInstance()->getTableName() . " pc
        JOIN " . PostContractClaimClaimTable::getInstance()->getTableName() . " c ON c.post_contract_claim_id = pc.id
        WHERE pc.project_structure_id = " . $this->id . " 
        AND pc.type = ".$type."
        AND pc.status = ".PostContractClaim::STATUS_APPROVED."
        AND c.status = ".PostContractClaimClaim::STATUS_CLOSED."
        {$selectedRevisionClause}
        AND pc.deleted_at IS NULL AND c.deleted_at IS NULL GROUP BY pc.id");

        $stmt->execute();

        $latestRevisions = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $upToDateAmount = 0; 

        foreach($upToDateClaims as $claim)
        {
            foreach($latestRevisions as $latestRevision)
            {
                if($claim['post_contract_claim_id'] == $latestRevision['post_contract_claim_id'])
                {
                    if($claim['revision'] == $latestRevision['latest_revision'])
                    {
                         $upToDateAmount += $claim['up_to_date_amount']; 
                    }
                }
            }
        }

        return $upToDateAmount > 0 ? $upToDateAmount : 0; 
    }

    public function getPostContractClaimOverallTotal($type, $postContractRevision = null)
    {
        $pdo  = $this->getTable()->getConnection()->getDbh();

        $selectedRevisionClause = "";
        if($postContractRevision)
        {
            $claimCertificates = PostContractClaimRevisionTable::getClaimCertificates($postContractRevision['id'], PostContractClaimTable::hasProgressClaim($type) ? '<=' : '=');
            if( count($certIds = array_column($claimCertificates, 'id')) > 0 ) $selectedRevisionClause = "AND pc.claim_certificate_id in (" . implode(',', $certIds) . ")";
        }

        $stmt = $pdo->prepare("SELECT ROUND(COALESCE(SUM(i.quantity * i.rate), 0), 2) AS amount
        FROM " . PostContractClaimTable::getInstance()->getTableName() . " pc
        JOIN " . PostContractClaimItemTable::getInstance()->getTableName() . " i ON i.post_contract_claim_id = pc.id
        WHERE pc.project_structure_id = " . $this->id . " 
        AND pc.type = ".$type."
        AND pc.status = ".PostContractClaim::STATUS_APPROVED."
        {$selectedRevisionClause}
        AND pc.deleted_at IS NULL AND i.deleted_at IS NULL");

        $stmt->execute();

        $overallTotal = $stmt->fetch(PDO::FETCH_COLUMN, 0);

        if($type == PostContractClaim::TYPE_POST_CONTRACT_CLAIM_MATERIAL_ON_SITE)
        {
            $stmt = $pdo->prepare("SELECT ROUND(COALESCE(SUM(materialOnSite.final_amount), 0), 2) AS amount
            FROM " . PostContractClaimMaterialOnSiteTable::getInstance()->getTableName() . " materialOnSite
            JOIN " . PostContractClaimItemTable::getInstance()->getTableName() . " i ON i.id = materialOnSite.post_contract_claim_item_id
            LEFT JOIN " . PostContractClaimTable::getInstance()->getTableName() . " pc ON i.post_contract_claim_id = pc.id
            WHERE pc.project_structure_id = " . $this->id . "
            AND pc.status = ".PostContractClaim::STATUS_APPROVED." 
            {$selectedRevisionClause}
            AND pc.type = ".$type."
            AND pc.deleted_at IS NULL AND i.deleted_at IS NULL AND materialOnSite.deleted_at IS NULL");

            $stmt->execute();

            $overallTotal = $stmt->fetch(PDO::FETCH_COLUMN, 0);
        }

        return $overallTotal;
    }

    //to get formatted bill data based on revision. Mainly use in XML generator
    public function getBillRevisionData(ProjectRevision $currentRevision)
    {
        if( $this->type != ProjectStructure::TYPE_BILL )
            return false;

        $pdo = ProjectStructureTable::getInstance()->getConnection()->getDbh();

        $billStructure = [];

        //Get Bill and Its information
        $billColumnSettings = $this->BillColumnSettings->toArray();
        $billType           = $this->BillType->toArray();
        $billMarkupSetting  = $this->BillMarkupSetting->toArray();
        $billLayoutSetting  = $this->BillLayoutSetting->toArray();
        $billSetting        = $this->BillSetting->toArray();

        $billLayoutSetting['BillHeadSettings']  = ($this->BillLayoutSetting->BillHeadSettings) ? $this->BillLayoutSetting->BillHeadSettings->toArray() : [];
        $billLayoutSetting['BillPhrase']        = ($this->BillLayoutSetting->BillPhrase) ? $this->BillLayoutSetting->BillPhrase->toArray() : [];

        $elements = $this->Elements->toArray();

        $previousRevision = DoctrineQuery::create()
            ->select('r.id, r.project_structure_id, r.revision, r.version')
            ->from('ProjectRevision r')
            ->where('r.version = ?', $currentRevision->version - 1)
            ->andWhere('r.project_structure_id = ?', $currentRevision->project_structure_id)
            ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
            ->fetchOne();

        $stmt = $pdo->prepare("SELECT r.id
        FROM " . ProjectRevisionTable::getInstance()->getTableName() . " r
		WHERE r.version < " . $currentRevision->version . "
        AND r.project_structure_id = " . $currentRevision->project_structure_id."
        AND r.deleted_at IS NULL");

        $stmt->execute();

        $previousRevisionIds = $stmt->fetchAll(PDO::FETCH_COLUMN);

        if( $elements )
        {
            $stmt = $pdo->prepare("SELECT i.element_id, i.id
            FROM " . BillItemTable::getInstance()->getTableName() . " i
            JOIN ".BillElementTable::getInstance()->getTableName()." e ON i.element_id = e.id
			WHERE i.id = i.root_id
            AND e.project_structure_id = :bill_id
            AND e.deleted_at IS NULL
            AND i.deleted_at IS NULL
			ORDER BY i.priority");

            $stmt->execute(array(
                'bill_id' => $this->id
            ));

            $roots = $stmt->fetchAll(PDO::FETCH_COLUMN | PDO::FETCH_GROUP);

            foreach($elements as $element)
            {
                $result = [
                    'id'                   => $element['id'],
                    'project_structure_id' => $element['project_structure_id'],
                    'description'          => $element['description'],
                    'priority'             => $element['priority'],
                    'items'                => [],
                    'itemsToUpdate'        => [],
                    'priorityToUpdate'     => []
                ];

                //Get Bill Pages Information
                $query = DoctrineQuery::create()->select('p.id, p.element_id, p.page_no, p.revision_id,
					p.new_revision_id, i.id, i.bill_page_id, i.bill_item_id, i.new_item_from_new_revision')
                    ->from('BillPage p')
                    ->leftJoin('p.Items i')
                    ->where('(p.new_revision_id = ? OR p.revision_id = ?) AND p.element_id = ?', [$currentRevision->id, $previousRevision['id'], $element['id']])
                    ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY);

                $result['billPages'] = $query->execute();

                //Get Collection Pages Information
                $query = DoctrineQuery::create()->select('c.id, c.element_id, c.revision_id, c.page_no')
                    ->from('BillCollectionPage c')
                    ->whereIn('c.element_id', $element['id'])
                    ->andWhere('c.revision_id = ?', $previousRevision['id'])
                    ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY);

                $result['collectionPages'] = $query->execute();

                if( array_key_exists($element['id'], $roots) && $roots[ $element['id'] ] )
                {
                    $rootIds         = $roots[ $element['id'] ];
                    $implodedRootIds = implode(',', $rootIds);
                    $billItemIds     = [];
                    $affectedRootIds = [];

                    $stmt = $pdo->prepare("SELECT p.id, c.id FROM " . BillItemTable::getInstance()->getTableName() . " p
					JOIN " . BillItemTable::getInstance()->getTableName() . " c
					ON c.lft BETWEEN p.lft AND p.rgt
					WHERE p.id IN (" . $implodedRootIds . ") AND p.id = c.root_id
					AND (c.project_revision_id = :revision_id OR c.deleted_at_project_revision_id = :revision_id)
					AND c.deleted_at IS NULL ORDER BY p.priority, c.lft");

                    $stmt->execute(array(
                        'revision_id' => $currentRevision->id
                    ));

                    $affectedRootIdAndItems = $stmt->fetchAll(PDO::FETCH_COLUMN | PDO::FETCH_GROUP);

                    foreach($affectedRootIdAndItems as $rootId => $billIds)
                    {
                        $billItemIds = array_merge($billItemIds, $billIds);

                        array_push($affectedRootIds, $rootId);
                    }

                    $sqlCond = null;

                    //Get Node To Update
                    if( !empty($affectedRootIds) )
                    {
                        $stmt = $pdo->prepare("SELECT c.id, c.priority, c.lft, c.rgt, c.level
						FROM " . BillItemTable::getInstance()->getTableName() . " c
						WHERE c.root_id IN (" . implode(',', $affectedRootIds) . ")
						AND (c.project_revision_id != :revision_id OR c.deleted_at_project_revision_id != :revision_id)
						AND c.deleted_at IS NULL ORDER BY c.lft");

                        $stmt->execute(array(
                            'revision_id' => $currentRevision->id
                        ));

                        $result['itemsToUpdate'] = $stmt->fetchAll(PDO::FETCH_ASSOC);

                        $sqlCond = 'AND c.id NOT IN (' . implode(',', $affectedRootIds) . ')';
                    }

                    if( !empty($previousRevisionIds) && !empty($billItemIds) )
                    {
                        //Get Priority to update by previous version
                        $stmt = $pdo->prepare("SELECT c.id, c.priority, c.lft, c.rgt, c.level
                        FROM " . BillItemTable::getInstance()->getTableName() . " c
                        LEFT JOIN " . BillElementTable::getInstance()->getTableName() . " e ON e.id = c.element_id
                        WHERE c.id = c.root_id " . $sqlCond . "
                        AND (c.project_revision_id IN (" . implode(',', $previousRevisionIds) . ")
                        OR c.project_revision_id = " . $currentRevision->id . ")
                        AND e.id = " . $element['id'] . " AND c.deleted_at IS NULL
                        ORDER BY c.priority");

                        $stmt->execute();

                        $result['priorityToUpdate'] = $stmt->fetchAll(PDO::FETCH_ASSOC);
                    }

                    if( !empty($billItemIds) )
                    {
                        $query = DoctrineQuery::create()->select('c.id, c.description, c.type, c.uom_id, c.element_id, c.grand_total_after_markup, c.grand_total_quantity,
                        c.bill_ref_element_no, c.bill_ref_page_no, c.bill_ref_char, c.priority, c.root_id, c.lft, c.rgt, c.level, c.project_revision_id, c.deleted_at_project_revision_id, c.project_revision_deleted_at,
                        uom.id, uom.name, uom.symbol, uom.type, type.id, type.bill_item_id, type.bill_column_setting_id, type.include, type.total_quantity,
                        type_fc.id, type_fc.relation_id, type_fc.column_name, type_fc.final_value, type_fc.created_at, ls.*, pc.supply_rate, pc.bill_item_id')
                            ->from('BillItem c')
                            ->leftJoin('c.BillItemTypeReferences type')
                            ->leftJoin('c.LumpSumPercentage ls')
                            ->leftJoin('c.PrimeCostRate pc')
                            ->leftJoin('type.FormulatedColumns type_fc')
                            ->leftJoin('c.UnitOfMeasurement uom')
                            ->whereIn('c.id', $billItemIds)
                            ->andWhere('c.deleted_at IS NULL')
                            ->orderBy('c.priority, c.lft, c.level')
                            ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY);

                        $result['items'] = $query->execute();
                    }
                }

                unset( $element );

                array_push($billStructure, $result);
            }
        }

        if( $elements )
        {
            return [
                'elementsAndItems'   => ( $elements && count($elements) > 0 ) ? $billStructure : null,
                'billColumnSettings' => $billColumnSettings,
                'billMarkupSetting'  => $billMarkupSetting,
                'billLayoutSetting'  => $billLayoutSetting,
                'billType'           => $billType,
                'billSetting'        => $billSetting,
            ];
        }

        return false;
    }

    public function getBillsWithAddendums($includeInProgress=true)
    {
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return [];
        }
        $pdo = ProjectStructureTable::getInstance()->getConnection()->getDbh();
        $includeInProgressSql = (!$includeInProgress) ? " AND r.locked_status IS TRUE " : "";
        $stmt = $pdo->prepare("SELECT b.id, r.id AS revision_id, r.revision, r.version
        FROM " . ProjectStructureTable::getInstance()->getTableName() . " b
        JOIN " . BillElementTable::getInstance()->getTableName() . " e ON b.id = e.project_structure_id
        JOIN " . BillItemTable::getInstance()->getTableName() . " i ON e.id = i.element_id
        JOIN " . ProjectRevisionTable::getInstance()->getTableName() . " r ON r.id = i.project_revision_id 
        WHERE b.root_id = ".$this->id."
        AND r.version <> ".ProjectRevision::ORIGINAL_BILL_VERSION." ".$includeInProgressSql."
        AND r.project_structure_id = ".$this->id."
        AND b.deleted_at IS NULL AND e.deleted_at IS NULL AND i.deleted_at IS NULL
        AND r.deleted_at IS NULL
        GROUP BY b.id, r.id
        ORDER BY r.version, b.priority, b.lft, b.level");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_GROUP|PDO::FETCH_ASSOC);
    }
    
    public function getElementsWithAddendums($includeInProgress=true)
    {
        if($this->type != self::TYPE_BILL)
        {
            return [];
        }
        $pdo = ProjectStructureTable::getInstance()->getConnection()->getDbh();
        $includeInProgressSql = (!$includeInProgress) ? " AND r.locked_status IS TRUE " : "";
        $stmt = $pdo->prepare("SELECT e.id, r.id AS revision_id, r.revision, r.version
        FROM " . BillElementTable::getInstance()->getTableName() . " e
        JOIN " . BillItemTable::getInstance()->getTableName() . " i ON e.id = i.element_id
        JOIN " . ProjectRevisionTable::getInstance()->getTableName() . " r ON r.id = i.project_revision_id 
        WHERE e.project_structure_id = ".$this->id."
        AND r.version <> ".ProjectRevision::ORIGINAL_BILL_VERSION." ".$includeInProgressSql."
        AND r.project_structure_id = ".$this->root_id."
        AND e.deleted_at IS NULL AND i.deleted_at IS NULL
        AND r.deleted_at IS NULL
        GROUP BY e.id, r.id
        ORDER BY r.version, e.priority");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_GROUP|PDO::FETCH_ASSOC);
    }

    public function getAddendumInfo($includeInProgress=true)
    {
        if($this->type != self::TYPE_BILL)
        {
            return [];
        }
        $pdo = ProjectStructureTable::getInstance()->getConnection()->getDbh();
        $includeInProgressSql = (!$includeInProgress) ? " AND r.locked_status IS TRUE " : "";
        $stmt = $pdo->prepare("SELECT DISTINCT r.id, r.revision, r.version
        FROM " . ProjectStructureTable::getInstance()->getTableName() . " b
        JOIN " . BillElementTable::getInstance()->getTableName() . " e ON b.id = e.project_structure_id
        JOIN " . BillItemTable::getInstance()->getTableName() . " i ON e.id = i.element_id
        JOIN " . ProjectRevisionTable::getInstance()->getTableName() . " r ON r.id = i.project_revision_id 
        WHERE b.id = ".$this->id."
        AND r.version <> ".ProjectRevision::ORIGINAL_BILL_VERSION." ".$includeInProgressSql."
        AND r.project_structure_id = ".$this->root_id."
        AND b.deleted_at IS NULL AND e.deleted_at IS NULL AND i.deleted_at IS NULL
        AND r.deleted_at IS NULL
        ORDER BY r.version");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public function getBillsWithTenderAlternatives($includeInProgress=true)
    {
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return [];
        }

        $pdo = ProjectStructureTable::getInstance()->getConnection()->getDbh();
        
        $includeInProgressSql = (!$includeInProgress) ? " AND r.locked_status IS TRUE " : "";

        $currentSelectedProjectRevision = $this->getCurrentSelectedProjectRevision();

        $revisionSql = ($currentSelectedProjectRevision->version != ProjectRevision::ORIGINAL_BILL_VERSION) ? " AND r.version <= ".$currentSelectedProjectRevision->version." ".$includeInProgressSql." " : " AND r.version = ".ProjectRevision::ORIGINAL_BILL_VERSION." ";

        $stmt = $pdo->prepare("SELECT ta.id, ta.title, ta.is_awarded, b.id AS bill_id, r.id AS revision_id, r.revision, r.version
        FROM " . ProjectStructureTable::getInstance()->getTableName() . " p
        JOIN " . TenderAlternativeTable::getInstance()->getTableName() . " ta ON p.id = ta.project_structure_id
        JOIN " . TenderAlternativeBillTable::getInstance()->getTableName() . " x ON x.tender_alternative_id = ta.id
        JOIN " . ProjectStructureTable::getInstance()->getTableName() . " b ON x.project_structure_id = b.id and b.root_id = p.id
        JOIN " . ProjectRevisionTable::getInstance()->getTableName() . " r ON r.id = ta.project_revision_id
        WHERE p.id = ".$this->id."
        ".$revisionSql." AND r.project_structure_id = ".$this->id."
        AND p.deleted_at IS NULL AND ta.deleted_at IS NULL AND ta.project_revision_deleted_at IS NULL
        AND b.deleted_at IS NULL AND r.deleted_at IS NULL
        ORDER BY r.version, b.priority, b.lft, b.level");
        
        $stmt->execute();

        $records = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $data = [];

        foreach($records as $record)
        {
            if(!array_key_exists($record['bill_id'], $data))
            {
                $data[$record['bill_id']] = [];
            }

            if(!array_key_exists($record['id'], $data[$record['bill_id']]))
            {
                $data[$record['bill_id']][$record['id']] = $record;
            }
        }

        return $data;
    }

    public function getTenderAlternatives($hydrateArray=false)
    {
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return [];
        }

        $query = DoctrineQuery::create()
            ->from('TenderAlternative ta')
            ->where('ta.project_structure_id = ?', $this->id)
            ->andWhere('ta.deleted_at IS NULL')
            ->andWhere('ta.project_revision_deleted_at IS NULL')
            ->orderBy('ta.id');

        if($hydrateArray)
        {
            $query->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY);
        }
        
        return $query->execute();
    }

    public function getTenderAlternativesByLatestLockedRevision($hydrateArray=false)
    {
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return [];
        }

        $pdo = ProjectStructureTable::getInstance()->getConnection()->getDbh();
        
        $stmt = $pdo->prepare("SELECT ta.id
        FROM " . ProjectStructureTable::getInstance()->getTableName() . " p
        JOIN " . TenderAlternativeTable::getInstance()->getTableName() . " ta ON p.id = ta.project_structure_id
        JOIN " . ProjectRevisionTable::getInstance()->getTableName() . " r ON r.id = ta.project_revision_id 
        WHERE p.id = ".$this->id."
        AND r.locked_status IS TRUE AND r.project_structure_id = ".$this->id."
        AND p.deleted_at IS NULL AND ta.deleted_at IS NULL AND ta.project_revision_deleted_at IS NULL
        AND r.deleted_at IS NULL
        ORDER BY r.version, ta.id");
        
        $stmt->execute();

        $tenderAlternativeIds = $stmt->fetchAll(PDO::FETCH_COLUMN, 0);

        $tenderAlternatives = [];

        if(!empty($tenderAlternativeIds))
        {
            $query = DoctrineQuery::create()
            ->from('TenderAlternative ta')
            ->where('ta.project_structure_id = ?', $this->id)
            ->whereIn('ta.id', $tenderAlternativeIds)
            ->andWhere('ta.deleted_at IS NULL')
            ->andWhere('ta.project_revision_deleted_at IS NULL')
            ->orderBy('ta.id');

            if($hydrateArray)
            {
                $query->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY);
            }
            
            $tenderAlternatives = $query->execute();
        }
        
        return $tenderAlternatives;
    }

    public function getAwardedTenderAlternative($hydrateArray=false)
    {
        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return [];
        }

        $query = DoctrineQuery::create()
            ->from('TenderAlternative ta')
            ->where('ta.project_structure_id = ?', $this->id)
            ->andWhere('ta.is_awarded IS TRUE')
            ->andWhere('ta.deleted_at IS NULL')
            ->andWhere('ta.project_revision_deleted_at IS NULL');

        if($hydrateArray)
        {
            $query->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY);
        }
        
        return $query->fetchOne();
    }

    public function getTenderAlternativesInfo($includeInProgress=true)
    {
        if($this->type != self::TYPE_BILL)
        {
            return [];
        }

        $pdo = ProjectStructureTable::getInstance()->getConnection()->getDbh();
        $project = $this->getRoot();

        $includeInProgressSql = (!$includeInProgress) ? " AND r.locked_status IS TRUE " : "";

        $currentSelectedProjectRevision = $project->getCurrentSelectedProjectRevision();

        $stmt = $pdo->prepare("SELECT ta.id, ta.title, ta.is_awarded, b.id AS bill_id, r.id AS revision_id, r.revision, r.version
        FROM " . ProjectStructureTable::getInstance()->getTableName() . " p
        JOIN " . TenderAlternativeTable::getInstance()->getTableName() . " ta ON p.id = ta.project_structure_id
        JOIN " . TenderAlternativeBillTable::getInstance()->getTableName() . " x ON x.tender_alternative_id = ta.id
        JOIN " . ProjectStructureTable::getInstance()->getTableName() . " b ON x.project_structure_id = b.id and b.root_id = p.id
        JOIN " . ProjectRevisionTable::getInstance()->getTableName() . " r ON r.id = ta.project_revision_id 
        WHERE p.id = ".$project->id." AND b.id = ".$this->id."
        AND r.version <= ".$currentSelectedProjectRevision->version." ".$includeInProgressSql."
        AND p.deleted_at IS NULL AND ta.deleted_at IS NULL AND ta.project_revision_deleted_at IS NULL
        AND b.deleted_at IS NULL AND r.deleted_at IS NULL
        ORDER BY r.version, ta.id");
        
        $stmt->execute();

        $records = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $data = [];

        foreach($records as $record)
        {
            if(!array_key_exists($record['id'], $data))
            {
                $data[$record['id']] = $record;
            }
        }

        return array_values($data);
    }

    public function getUntagTenderAlternativeBillIds()
    {
        $billIds = [];

        if(!$this->node->isRoot() and $this->type != self::TYPE_ROOT)
        {
            return $billIds;
        }

        if(count($this->getTenderAlternatives(true)))
        {
            $pdo = ProjectStructureTable::getInstance()->getConnection()->getDbh();

            $stmt = $pdo->prepare("SELECT b.id
            FROM " . ProjectStructureTable::getInstance()->getTableName() . " b
            JOIN " . BillTypeTable::getInstance()->getTableName() . " t ON (t.project_structure_id = b.id AND t.deleted_at IS NULL)
            WHERE b.lft >= ".$this->lft." AND b.rgt <= ".$this->rgt."
            AND b.root_id = ".$this->id." AND b.type <> " . ProjectStructure::TYPE_ROOT . "
            AND b.deleted_at IS NULL
            AND NOT EXISTS (
                SELECT
                FROM ".TenderAlternativeBillTable::getInstance()->getTableName()." x
                JOIN ".TenderAlternativeTable::getInstance()->getTableName()." ta ON x.tender_alternative_id = ta.id
                WHERE ta.project_structure_id = ".$this->id."
                AND x.project_structure_id = b.id
                AND ta.deleted_at IS NULL AND ta.project_revision_deleted_at IS NULL
            )");

            $stmt->execute([]);

            $billIds = $stmt->fetchAll(PDO::FETCH_ASSOC|PDO::FETCH_COLUMN);
        }

        return $billIds;
    }

    public function validateHeadsWithoutItems()
    {
        $pdo = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("
            SELECT h.id
            FROM " . BillItemTable::getInstance()->getTableName() . " h
            JOIN " . BillElementTable::getInstance()->getTableName() . " e ON e.id = h.element_id
            JOIN " . ProjectStructureTable::getInstance()->getTableName() . " b ON b.id = e.project_structure_id
            WHERE h.type IN (?, ?)
            AND b.root_id = ".$this->root_id."
            AND not exists (
                SELECT 1
                FROM " . BillItemTable::getInstance()->getTableName() . " i
                WHERE i.root_id = h.root_id
                AND i.type IN (?, ?, ?, ?, ?, ?, ?, ?, ?)
                AND i.lft > h.lft
                AND i.rgt < h.rgt
                and i.level = (h.level + 1)
                AND i.element_id = e.id
            )");

        $stmt->execute([
            BillItem::TYPE_HEADER,
            BillItem::TYPE_HEADER_N,
            BillItem::TYPE_WORK_ITEM,
            BillItem::TYPE_ITEM_HTML_EDITOR,
            BillItem::TYPE_ITEM_PROVISIONAL,
            BillItem::TYPE_ITEM_RATE_ONLY,
            BillItem::TYPE_ITEM_NOT_LISTED,
            BillItem::TYPE_ITEM_PC_RATE,
            BillItem::TYPE_ITEM_LUMP_SUM,
            BillItem::TYPE_ITEM_LUMP_SUM_PERCENT,
            BillItem::TYPE_ITEM_LUMP_SUM_EXCLUDE]);

        return $stmt->fetchAll(PDO::FETCH_COLUMN, 0);
    }
}
