<?php

/**
 * SupplyOfMaterialItem
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    buildspace
 * @subpackage model
 * @author     1337 developers
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class SupplyOfMaterialItem extends BaseSupplyOfMaterialItem
{
    const TYPE_HEADER = 1;
    const TYPE_WORK_ITEM = 2;
    const TYPE_HEADER_N = 2048;

    const TYPE_HEADER_TEXT = 'HEAD';
    const TYPE_WORK_ITEM_TEXT = 'ITEM';
    const TYPE_HEADER_N_TEXT = 'HEAD-N';

    public $itemContainerAfterCopy = array();

    public function updateRootPriority($priority, $excludeId=null)
    {
        SupplyOfMaterialItemTable::updateRootPriority($priority, $this->element_id, $excludeId);
    }

    public function updateType($type)
    {
        if($type == self::TYPE_HEADER or $type == self::TYPE_HEADER_N)
        {
            $this->supply_rate = 0;
            $this->contractor_supply_rate = 0;
            $this->estimated_qty = 0;
            $this->percentage_of_wastage = 0;
            $this->difference = 0;
            $this->amount = 0;
            $this->uom_id = NULL;
        }

        $this->type = (integer)$type;

        $this->save();
    }

    public function delete(Doctrine_Connection $conn = null)
    {
        if($this->type == SupplyOfMaterialItem::TYPE_HEADER or $this->type == SupplyOfMaterialItem::TYPE_HEADER_N)
        {
            Doctrine_Query::create()
                ->delete('SupplyOfMaterialItem i')
                ->where('i.root_id = ?', $this->root_id)
                ->andWhere('i.element_id = ?', $this->element_id)
                ->andWhere('i.lft > ?', $this->lft)
                ->andWhere('i.rgt < ?', $this->rgt)
                ->execute();
        }

        parent::delete($conn);

        //recalculate left-right values when deleting child nodes
        if(!$this->node->isRoot())
        {
            $first = $this->rgt + 1;
            $delta = $this->lft - $this->rgt - 1;

            Utilities::shiftRightLeftNestedSet(get_class($this), $first, $delta, $this->root_id, $conn);
        }
    }

    public function moveTo(SupplyOfMaterialItem $targetItem, $lastPosition=false)
    {
        $con = $this->getTable()->getConnection();

        try
        {
            $con->beginTransaction();

            if($targetItem->node->isRoot())
            {
                $priority       = $lastPosition ? $targetItem->priority + 1 : $targetItem->priority;
                $this->priority = $priority;
                $this->save();

                if(!$this->node->isRoot() and $this->node->isValidNode())
                {
                    $this->node->makeRoot($this->id);
                    $this->save();
                }

                if(!$lastPosition)
                {
                    $this->updateRootPriority($priority, $this->id);
                }
            }
            else
            {
                if($lastPosition)
                {
                    $this->node->moveAsNextSiblingOf($targetItem);
                }
                else
                {
                    $this->node->moveAsPrevSiblingOf($targetItem);
                }

                $this->priority = $targetItem->priority;
                $this->save();

                $this->refresh();
            }

            /*
             * Update priority for all nodes under the family to its root priority.
             * We exclude this step for case the target item is root node and $lastPosition is false
             * because the priority already been update by calling updateRootPriority()
             */
            if(($targetItem->node->isRoot() && $lastPosition) or !$targetItem->node->isRoot())
            {
                Doctrine_Query::create()->update('SupplyOfMaterialItem i')
                    ->set('priority', $this->priority)
                    ->where('i.lft BETWEEN ? AND ?', array($this->lft, $this->rgt))
                    ->andWhere('i.root_id = ?', $this->root_id)
                    ->andWhere('i.priority <> ?', $this->priority)
                    ->execute();
            }

            $con->commit();

            return true;
        }
        catch(Exception $e)
        {
            $con->rollback();
            throw $e;
        }
    }

    public function copyTo(SupplyOfMaterialItem $targetItem, $lastPosition=false)
    {
        $con = $this->getTable()->getConnection();

        try
        {
            $con->beginTransaction();

            if($this->node->hasChildren())
            {
                $children = $this->getTable()
                    ->createQuery('i')
                    ->select('i.id, i.description, i.supply_rate, i.contractor_supply_rate, i.estimated_qty, i.percentage_of_wastage, i.difference, i.amount, i.note, i.uom_id, i.element_id, i.type, i.level')
                    ->where('i.root_id = ?', $this->root_id)
                    ->addWhere('i.lft > ? AND i.rgt < ?', array($this->lft, $this->rgt))
                    ->orderBy('i.lft ASC')
                    ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY_HIERARCHY)
                    ->execute();
            }
            else
            {
                $children = false;
            }

            $cloneItem                         = new SupplyOfMaterialItem();

            $cloneItem->description            = $this->description;
            $cloneItem->note                   = $this->note;
            $cloneItem->type                   = $this->type;
            $cloneItem->element_id             = $this->element_id;
            $cloneItem->uom_id                 = $this->uom_id;
            $cloneItem->supply_rate            = $this->supply_rate;
            $cloneItem->contractor_supply_rate = $this->contractor_supply_rate;
            $cloneItem->estimated_qty          = $this->estimated_qty;
            $cloneItem->percentage_of_wastage  = $this->percentage_of_wastage;
            $cloneItem->difference             = $this->difference;
            $cloneItem->amount                 = $this->amount;

            if($targetItem->node->isRoot())
            {
                $priority = $lastPosition ? $targetItem->priority + 1 : $targetItem->priority;
                $cloneItem->priority = $priority;
                $cloneItem->save($con);

                $cloneItem->getTable()->getTree()->createRoot($cloneItem);

                if(!$lastPosition)
                {
                    $this->updateRootPriority($priority, $cloneItem->id);
                }
            }
            else
            {
                if($lastPosition)
                {
                    $cloneItem->node->insertAsNextSiblingOf($targetItem);
                }
                else
                {
                    $cloneItem->node->insertAsPrevSiblingOf($targetItem);
                }

                $cloneItem->priority = $targetItem->priority;
                $cloneItem->save($con);
            }

            $cloneItem->refresh();

            array_push($this->itemContainerAfterCopy, array(
                'id' => $cloneItem->id,
                'origin' => $this->id
            ));

            if($children)
            {
                $this->_loadNestedSetData($children, $this, $cloneItem);
            }

            $con->commit();

            $cloneItem->refresh(true);

            return $cloneItem;
        }
        catch(Exception $e)
        {
            $con->rollback();
            throw $e;
        }
    }

    private function _loadNestedSetData(Array $nestedSetData, SupplyOfMaterialItem $containerScope, SupplyOfMaterialItem $parent)
    {
        $nestedSetData = array_reverse($nestedSetData, true);

        foreach($nestedSetData as $nestedSet)
        {
            $children = array();
            $originItem = $this->getTable()->find($nestedSet['id']);
            unset($nestedSet['id']);

            if(array_key_exists('__children', $nestedSet))
            {
                $children = (array) $nestedSet['__children'];
                unset($nestedSet['__children']);
            }

            $obj = new SupplyOfMaterialItem();

            foreach($nestedSet as $key => $value)
            {
                $func = 'set' . Doctrine_Inflector::classify($key);
                $obj->$func($value);
            }

            $parent->node->addChild($obj);

            $obj->priority = $parent->priority;
            $obj->save();

            array_push($containerScope->itemContainerAfterCopy, array(
                'id' => $obj->id,
                'origin' => $originItem->id
            ));

            if(is_array($children) and !empty($children))
            {
                $this->_loadNestedSetData($children, $containerScope, $obj);
            }
        }
    }

    public function indent()
    {
        $indented = false;
        $previousRoot = $this->getPreviousRoot();

        if($this->node->isRoot() and $previousRoot and ($previousRoot->type == SupplyOfMaterialItem::TYPE_HEADER or $previousRoot->type == SupplyOfMaterialItem::TYPE_HEADER_N))
        {
            $this->node->moveAsLastChildOf($previousRoot);
            $this->refresh();

            $pdo = $this->getTable()->getConnection()->getDbh();

            $stmt = $pdo->prepare("UPDATE ".$this->getTable()->getTableName()." SET priority = ".$previousRoot->priority."
            WHERE root_id = ".$previousRoot->root_id." AND priority <> ".$previousRoot->priority."
            AND element_id = ".$this->element_id." AND deleted_at IS NULL");

            $stmt->execute();

            $indented = true;
        }
        else if(!$this->node->isRoot() and $this->node->hasPrevSibling() and ($this->node->getPrevSibling()->type == SupplyOfMaterialItem::TYPE_HEADER or $this->node->getPrevSibling()->type == SupplyOfMaterialItem::TYPE_HEADER_N))
        {
            $this->node->moveAsLastChildOf($this->node->getPrevSibling());

            $this->refresh();

            $indented = true;
        }

        return $indented;
    }

    public function outdent()
    {
        if(!$this->node->isRoot() and (($this->type == SupplyOfMaterialItem::TYPE_HEADER or $this->type == SupplyOfMaterialItem::TYPE_HEADER_N) or ($this->type != SupplyOfMaterialItem::TYPE_HEADER and $this->type != SupplyOfMaterialItem::TYPE_HEADER_N and !$this->node->hasNextSibling())))
        {
            $parent = $this->node->getParent();

            if(!$parent || !$parent->node)
            {
                return false;
            }
            
            $siblings = $this->getTable()
                ->createQuery('i')
                ->select('i.id')
                ->where('i.root_id = ?',$this->root_id)
                ->andWhere('i.level = ?', $this->level)
                ->andWhere('i.lft BETWEEN ? AND ?', array($parent->lft, $parent->rgt))
                ->andWhere('i.lft > ?', $this->rgt)
                ->addOrderBy('i.lft ASC')
                ->execute();

            foreach($siblings as $sibling)
            {
                $sibling->node->moveAsLastChildOf($this);

                $this->refresh();
            }

            unset($siblings);

            if(!$parent->node->isRoot())
            {
                $this->node->moveAsNextSiblingOf($parent);
            }
            else
            {
                $this->node->makeRoot($this->id);

                parent::save();

                $this->priority = $parent->priority + 1;

                $this->save();

                $this->updateRootPriority($parent->priority + 1, $this->id);
            }

            $this->refresh();

            return true;
        }
        else
        {
            return false;
        }
    }

    public function getPreviousRoot()
    {
        $rootId = $this->root_id > 0 ? $this->root_id : $this->id;
        $root = $this->getTable()->find($rootId);

        return $this->getTable()
            ->createQuery('i')
            ->select('i.id')
            ->where('i.root_id = i.id')
            ->addWhere('i.element_id = ?', $this->element_id)
            ->addWhere('i.priority < ?', $root->priority)
            ->orderBy('i.priority DESC')
            ->limit(1)
            ->fetchOne();
    }

    public function postSave($event)
    {
        if($this->deleted_at == NULL and $this->type != self::TYPE_HEADER and $this->type != self::TYPE_HEADER_N)
        {
            DoctrineQuery::create()
                ->update('SupplyOfMaterialItem')
                ->set('difference', 'supply_rate - contractor_supply_rate')
                ->set('amount', 'estimated_qty * (supply_rate - contractor_supply_rate)')
                ->where('id = '.$this->id)
                ->execute();
        }

        return parent::postSave($event);
    }
}
