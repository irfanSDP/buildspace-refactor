<?php

/**
 * PostContract
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    buildspace
 * @subpackage model
 * @author     1337 developers
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class PostContract extends BasePostContract
{
    const RATE_TYPE_CONTRACTOR = 1;
    const RATE_TYPE_RATIONALIZED = 2;
    const RATE_TYPE_ORIGINAL = 4;

    const PUBLISHED_TYPE_NORMAL = 1;
    const PUBLISHED_TYPE_NEW = 2;

    public function cloneBillItemRates($withoutNotListedItem = false)
    {
        PostContractTable::cloneBillItemRatesByProject($this, $withoutNotListedItem);
    }

    public function getOpenClaimRevision()
    {
        return DoctrineQuery::create()->select('cr.*')
            ->from('PostContractClaimRevision cr')
            ->where('cr.post_contract_id = ?', $this->id)
            ->andWhere('cr.locked_status IS FALSE')
            ->fetchOne();
    }

    public function getLatestClaimRevision()
    {
        return DoctrineQuery::create()->select('cr.*')
            ->from('PostContractClaimRevision cr')
            ->where('cr.post_contract_id = ?', $this->id)
            ->orderBy('cr.version DESC')
            ->fetchOne();
    }

    public function getLatestApprovedClaimRevision()
    {
        return DoctrineQuery::create()->select('cr.*')
            ->from('PostContractClaimRevision cr')
            ->leftJoin('cr.ClaimCertificate c')
            ->where('cr.post_contract_id = ?', $this->id)
            ->andWhere('c.status = ?', ClaimCertificate::STATUS_TYPE_APPROVED)
            ->orderBy('cr.version DESC')
            ->fetchOne();
    }

    public function getPendingClaimRevision()
    {
        /*
         * Pending claim revision only valid for post contract with claim certificate
         * because claim cert can hold pending status for approval.
         * There is no approval for buildspacePro (only buildspaceSAML) but just to keep
         * both codes inline ClaimCertificate also has STATUS_TYPE_PENDING_FOR_APPROVAL
         * in buildspacePro. This method would never be used in buildspacePro
         */

        $claimRevisionId = null;
        
        if($this->published_type == self::PUBLISHED_TYPE_NEW)
        {
            $pdo = PostContractTable::getInstance()->getConnection()->getDbh();

            $stmt = $pdo->prepare("SELECT cr.id
            FROM bs_post_contract_claim_revisions cr
            JOIN bs_claim_certificates c ON c.post_contract_claim_revision_id = cr.id
            WHERE cr.post_contract_id = :postContractId
            AND c.status = :status
            AND cr.deleted_at IS NULL
            ORDER BY cr.version ASC limit 1");

            $stmt->execute(['postContractId' => $this->id, 'status' => ClaimCertificate::STATUS_TYPE_PENDING_FOR_APPROVAL]);

            $claimRevisionId = $stmt->fetch(PDO::FETCH_COLUMN);
        }

        return ( $claimRevisionId ) ? PostContractClaimRevisionTable::getInstance()->find($claimRevisionId) : null;
    }

    public function getInProgressClaimRevision()
    {
        switch($this->published_type)
        {
            case self::PUBLISHED_TYPE_NORMAL:
                $sql = "SELECT cr.id
                FROM bs_post_contract_claim_revisions cr
                WHERE cr.post_contract_id = :postContractId
                AND cr.claim_submission_locked IS FALSE
                AND cr.deleted_at IS NULL
                ORDER BY cr.version ASC limit 1";
                break;
            case self::PUBLISHED_TYPE_NEW:
                $sql = "SELECT cr.id
                FROM bs_post_contract_claim_revisions cr
                JOIN bs_claim_certificates c ON c.post_contract_claim_revision_id = cr.id
                WHERE cr.post_contract_id = :postContractId
                AND c.status = ".ClaimCertificate::STATUS_TYPE_IN_PROGRESS."
                AND cr.deleted_at IS NULL
                ORDER BY cr.version ASC limit 1";
                break;
            default:
                throw new Exception('Invalid Post Contract published_type');
        }
        
        $pdo = PostContractTable::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare($sql);

        $stmt->execute(['postContractId' => $this->id]);

        $claimRevisionId = $stmt->fetch(PDO::FETCH_COLUMN);

        return ( $claimRevisionId ) ? PostContractClaimRevisionTable::getInstance()->find($claimRevisionId) : null;
    }

    public function getEarliestUnapprovedClaimRevision()
    {
        $claimRevision = null;

        $pdo = PostContractTable::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT cr.id
        FROM bs_post_contract_claim_revisions cr
        LEFT JOIN bs_claim_certificates c ON c.post_contract_claim_revision_id = cr.id
        WHERE cr.post_contract_id = :postContractId
        AND c.status != :status
        AND cr.deleted_at IS NULL
        ORDER BY cr.version ASC limit 1");

        $stmt->execute(array( 'postContractId' => $this->id, 'status' => ClaimCertificate::STATUS_TYPE_APPROVED ));

        $claimRevisionId = $stmt->fetch(PDO::FETCH_COLUMN);

        if( $claimRevisionId ) $claimRevision = Doctrine_Core::getTable('PostContractClaimRevision')->find($claimRevisionId);

        return $claimRevision;
    }

    public function getCurrentSelectedClaimRevision()
    {
        return DoctrineQuery::create()->select('cr.*')
            ->from('PostContractClaimRevision cr')
            ->where('cr.post_contract_id = ?', $this->id)
            ->andWhere('cr.current_selected_revision IS TRUE')
            ->fetchOne();
    }

    public function getPreviousClaimRevision($claimRevision)
    {
        return DoctrineQuery::create()->select('cr.*')
            ->from('PostContractClaimRevision cr')
            ->where('cr.post_contract_id = ?', $this->id)
            ->andWhere('cr.version = ?', $claimRevision->version -1)
            ->fetchOne();
    }

    public function getContractSum()
    {
        return PostContractTable::getOverallTotalByProjectId($this->project_structure_id);
    }
}
