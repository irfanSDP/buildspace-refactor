<?php

/**
 * ResourceItemTable
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class ResourceItemTable extends Doctrine_Table
{
    private $importedBillItemsChildren = array();

    /**
     * Returns an instance of this class.
     *
     * @return object ResourceItemTable
     */
    public static function getInstance()
    {
        return Doctrine_Core::getTable('ResourceItem');
    }

    public static function updateTimeStamp(ResourceItem $resourceItem)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("UPDATE ".ResourceItemTable::getInstance()->getTableName()." SET updated_at = NOW() WHERE id = ".$resourceItem->id." AND deleted_at IS NULL");
        $stmt->execute(array());

        $stmt = $pdo->prepare("UPDATE ".ResourceTradeTable::getInstance()->getTableName()." SET updated_at = NOW() WHERE id = ".$resourceItem->resource_trade_id." AND deleted_at IS NULL");
        $stmt->execute(array());
    }

    public static function createItemFromLastRow($previousItem, $tradeId, $fieldName=null, $fieldValue=null)
    {
        $formulatedColumnConstants = Utilities::getAllFormulatedColumnConstants('ResourceItem');

        $item = new ResourceItem();

        $item->resource_trade_id = $tradeId;

        if($fieldName)
        {
            if(!in_array($fieldName, $formulatedColumnConstants))
            {
                $item->{'set'.sfInflector::camelize($fieldName)}($fieldValue);
            }
        }

        if($fieldName != 'type')
        {
            $item->type = ResourceItem::TYPE_WORK_ITEM;
        }

        $asRoot = true;
        $priority = 0;

        if($previousItem)
        {
            if($previousItem->node->isRoot())
            {
                $priority = $previousItem->priority + 1;
            }
            else
            {
                $asRoot = false;
                $item->node->insertAsNextSiblingOf($previousItem);

                $priority = $previousItem->priority;
            }
        }

        $item->priority = $priority;
        $item->save();

        if($asRoot)
        {
            $item->getTable()->getTree()->createRoot($item);

            $item->updateRootPriority($priority, $item->id);
        }

        return $item;
    }

    public static function createItem($nextItem, $tradeId)
    {
        $item                    = new ResourceItem();
        $item->resource_trade_id = $tradeId;
        $item->type              = ResourceItem::TYPE_WORK_ITEM;

        if($nextItem->node->isRoot())
        {
            $priority = $nextItem->priority;

            $item->priority = $priority;

            $item->save();

            $node = $item->node;

            if ($node->isValidNode())
            {
                $node->makeRoot($item->id);
            }
            else
            {
                $item->getTable()->getTree()->createRoot($item);
            }

            $item->updateRootPriority($priority, $item->id);
        }
        else
        {
            $item->node->insertAsPrevSiblingOf($nextItem);
            $item->priority = $nextItem->priority;
        }

        $item->save();

        return $item;
    }

    public static function getFormulatedColumnByRelationIdAndColumnName($id, $columnName, $hydrate=null)
    {
        $query = DoctrineQuery::create()->select('*')
            ->from('ResourceItemFormulatedColumn c')
            ->where('c.relation_id = ?', $id)
            ->andWhere('c.column_name = ?', $columnName)
            ->limit(1);

        if(!is_null($hydrate))
        {
            $query->setHydrationMode($hydrate);
        }

        return $query->fetchOne();
    }

    /*
     * To calculate total cost/quantity by list of resource item ids.
     */
    public static function calculateTotalForResourceAnalysis(Array $resourceItemIds, $resourceId, $projectId)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();
        $buildUpRateSummaries = array();

        if(count($resourceItemIds) == 0)
        {
            return false;
        }

        $stmt = $pdo->prepare("SELECT bur.bill_item_id, bur.resource_item_library_id, burfc.relation_id, burfc.final_value, burfc.column_name FROM
       ".BillBuildUpRateFormulatedColumnTable::getInstance()->getTableName()." AS burfc
        JOIN ".BillBuildUpRateItemTable::getInstance()->getTableName()." AS bur ON burfc.relation_id = bur.id
        JOIN ".BillBuildUpRateResourceTable::getInstance()->getTableName()." AS r ON bur.build_up_rate_resource_id = r.id
        JOIN ".BillBuildUpRateResourceTradeTable::getInstance()->getTableName()." AS t ON bur.build_up_rate_resource_trade_id = t.id
        JOIN ".ResourceTradeTable::getInstance()->getTableName()." r_trade ON r_trade.id = t.resource_trade_library_id
        JOIN ".ResourceItemTable::getInstance()->getTableName()." r_item ON r_item.id =  bur.resource_item_library_id AND r_trade.id = r_item.resource_trade_id
        JOIN ".BillItemTable::getInstance()->getTableName()." AS i ON r.bill_item_id = i.id
        JOIN ".BillElementTable::getInstance()->getTableName()." AS e ON i.element_id = e.id
        JOIN ".ProjectStructureTable::getInstance()->getTableName()." AS s ON e.project_structure_id = s.id
        WHERE s.root_id = ".$projectId." AND r.resource_library_id = ".$resourceId."
        AND burfc.column_name <> '".BillBuildUpRateItem::FORMULATED_COLUMN_WASTAGE."'
        AND burfc.final_value IS NOT NULL AND burfc.final_value <> 0
        AND bur.resource_item_library_id IN (".implode(',', $resourceItemIds).")
        AND r_trade.deleted_at IS NULL AND r_item.deleted_at is NULL
        AND burfc.deleted_at IS NULL AND bur.deleted_at IS NULL AND r.deleted_at IS NULL AND t.deleted_at IS NULL
        AND i.project_revision_deleted_at IS NULL AND i.deleted_at IS NULL
        AND e.deleted_at IS NULL AND s.deleted_at IS NULL ORDER BY burfc.relation_id");

        $stmt->execute();

        $billBuildUpRateFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $billItemIds = array();

        foreach($billBuildUpRateFormulatedColumns as $billBuildUpRateFormulatedColumn)
        {
            $billItemIds[] = $billBuildUpRateFormulatedColumn['bill_item_id'];
        }

        if(count($billItemIds) > 0)
        {
            $stmt = $pdo->prepare("SELECT DISTINCT sum.bill_item_id, sum.conversion_factor_operator, sum.conversion_factor_amount FROM
            ".BillBuildUpRateSummaryTable::getInstance()->getTableName()." AS sum
            WHERE sum.bill_item_id IN (".implode(',', array_unique($billItemIds)).")
            AND sum.apply_conversion_factor IS TRUE
            AND sum.deleted_at IS NULL ORDER BY sum.bill_item_id");

            $stmt->execute();

            $buildUpRateSummaryRecords = $stmt->fetchAll(PDO::FETCH_ASSOC);

            foreach($buildUpRateSummaryRecords as $buildUpRateSummary)
            {
                $buildUpRateSummaries[$buildUpRateSummary['bill_item_id']] = array(
                    'conversion_factor_operator' => $buildUpRateSummary['conversion_factor_operator'],
                    'conversion_factor_amount' => $buildUpRateSummary['conversion_factor_amount']
                );
            }

            $stmt = $pdo->prepare("SELECT DISTINCT i.id, i.grand_total_quantity FROM
            ".BillItemTable::getInstance()->getTableName()." AS i
            WHERE i.id IN (".implode(',', array_unique($billItemIds)).")
            AND i.grand_total_quantity IS NOT NULL AND i.grand_total_quantity <> 0
            AND i.project_revision_deleted_at IS NULL AND i.deleted_at IS NULL
            GROUP BY i.id, i.grand_total_quantity ORDER BY i.id");

            $stmt->execute();

            $billItems = $stmt->fetchAll(PDO::FETCH_COLUMN|PDO::FETCH_GROUP);

            $billBuildUpRateItems = array();

            foreach($billBuildUpRateFormulatedColumns as $billBuildUpRateFormulatedColumn)
            {
                $billBuildUpRateItems[$billBuildUpRateFormulatedColumn['relation_id']]['bill_item_id'] = $billBuildUpRateFormulatedColumn['bill_item_id'];
                $billBuildUpRateItems[$billBuildUpRateFormulatedColumn['relation_id']][$billBuildUpRateFormulatedColumn['column_name']] = $billBuildUpRateFormulatedColumn['final_value'];

                $billBuildUpRateItems[$billBuildUpRateFormulatedColumn['relation_id']]['resource_item_library_id'] = $billBuildUpRateFormulatedColumn['resource_item_library_id'];
            }

            unset($billBuildUpRateFormulatedColumns);

            $resultContainer = array();
            foreach($resourceItemIds as $resourceItemId)
            {
                $totalQuantity = 0;
                $totalCost = 0;

                if(!array_key_exists($resourceItemId, $resultContainer))
                {
                    $resultContainer[$resourceItemId] = array(
                        'total_cost' => 0,
                        'total_quantity' => 0
                    );
                }

                foreach($billBuildUpRateItems as $billBuildUpRateItem)
                {
                    if(array_key_exists(BillBuildUpRateItem::FORMULATED_COLUMN_QUANTITY, $billBuildUpRateItem) && $billBuildUpRateItem['resource_item_library_id'] == $resourceItemId)
                    {
                        $quantity = $billBuildUpRateItem[BillBuildUpRateItem::FORMULATED_COLUMN_QUANTITY];
                        $number = array_key_exists(BillBuildUpRateItem::FORMULATED_COLUMN_NUMBER, $billBuildUpRateItem) ? $billBuildUpRateItem[BillBuildUpRateItem::FORMULATED_COLUMN_NUMBER] : 1;
                        $constant = array_key_exists(BillBuildUpRateItem::FORMULATED_COLUMN_CONSTANT, $billBuildUpRateItem) ? $billBuildUpRateItem[BillBuildUpRateItem::FORMULATED_COLUMN_CONSTANT] : 1;
                        $rate = array_key_exists(BillBuildUpRateItem::FORMULATED_COLUMN_RATE, $billBuildUpRateItem) ? $billBuildUpRateItem[BillBuildUpRateItem::FORMULATED_COLUMN_RATE] : 0;

                        $billItemQuantity = array_key_exists($billBuildUpRateItem['bill_item_id'], $billItems) ? $billItems[$billBuildUpRateItem['bill_item_id']][0] : 0;

                        if(array_key_exists($billBuildUpRateItem['bill_item_id'], $buildUpRateSummaries))
                        {
                            switch($buildUpRateSummaries[$billBuildUpRateItem['bill_item_id']]['conversion_factor_operator'])
                            {
                                case '/':
                                    if($buildUpRateSummaries[$billBuildUpRateItem['bill_item_id']]['conversion_factor_amount'] == 0)
                                    {
                                        $rate = 0;
                                        $quantityOnly = 0;
                                        break;
                                    }
                                    $rate = $number * $constant * $quantity / $buildUpRateSummaries[$billBuildUpRateItem['bill_item_id']]['conversion_factor_amount'] * $rate;
                                    $quantityOnly = $number * $constant * $quantity / $buildUpRateSummaries[$billBuildUpRateItem['bill_item_id']]['conversion_factor_amount'] * $billItemQuantity;
                                    break;
                                case '*':
                                    $rate = $number * $constant * $quantity * $buildUpRateSummaries[$billBuildUpRateItem['bill_item_id']]['conversion_factor_amount'] * $rate;
                                    $quantityOnly = $number * $constant * $quantity * $buildUpRateSummaries[$billBuildUpRateItem['bill_item_id']]['conversion_factor_amount'] * $billItemQuantity;
                                    break;
                                default:
                                    throw new Exception('Invalid conversion factor operator');
                            }
                        }
                        else
                        {
                            $rate = $number * $constant * $quantity * $rate;
                            $quantityOnly = $number * $constant * $quantity * $billItemQuantity;
                        }

                        $cost = number_format($rate, 2, '.', '') * $billItemQuantity;

                        $totalQuantity += $quantityOnly;
                        $totalCost += $cost;
                    }
                }

                $resultContainer[$resourceItemId]['total_cost'] = $totalCost;
                $resultContainer[$resourceItemId]['total_quantity'] = $totalQuantity;
            }

            unset($billBuildUpRateItems, $buildUpRateSummaries);

            return $resultContainer;
        }

        return false;
    }

    public static function getAncestorsById($id, $includeNode = false)
    {
        $leftOperator  = $includeNode ? '>=' : '>';
        $rightOperator = $includeNode ? '<=' : '<';

        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT p.id, p.description, p.priority, p.lft, p.level FROM ".self::getInstance()->getTableName()." c
        JOIN ".self::getInstance()->getTableName()." p
        ON c.lft ".$leftOperator." p.lft AND c.rgt ".$rightOperator." p.rgt
        WHERE c.id = ".$id." AND c.root_id = p.root_id AND p.type = ".BillItem::TYPE_HEADER." AND p.deleted_at IS NULL
        ORDER BY p.priority, p.lft, p.level ASC");

        $stmt->execute();

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public static function getSelectedItemsByItemIds(Resource $resource, array $itemIds)
    {
        $pdo               = self::getInstance()->getConnection()->getDbh();
        $newItemIds        = array();
        $tradeIds          = array();
        $newItems          = array();
        $formulatedColumns = array();

        if ( empty($itemIds) )
        {
            return array(array(), array(), array());
        }

        // will get selected item(s) first, then only get affected trade(s)
        // so that we can display it in print preview
        $stmt = $pdo->prepare("SELECT DISTINCT p.id, p.resource_trade_id, p.description, p.type, uom.id as uom_id, p.priority, p.lft, p.level,
        p.updated_at, uom.symbol AS uom_symbol, risr.id as resource_item_selected_rate_id
        FROM ".ResourceItemTable::getInstance()->getTableName()." i
        JOIN ".ResourceItemTable::getInstance()->getTableName()." p ON (i.lft BETWEEN p.lft AND p.rgt AND p.deleted_at IS NULL)
        JOIN ".ResourceTradeTable::getInstance()->getTableName()." sort ON p.resource_trade_id = sort.id AND sort.deleted_at IS NULL
        LEFT JOIN ".UnitOfMeasurementTable::getInstance()->getTableName()." uom ON p.uom_id = uom.id AND uom.deleted_at IS NULL
        LEFT JOIN ".ResourceItemSelectedRateTable::getInstance()->getTableName()." risr ON p.id = risr.resource_item_id
        WHERE sort.resource_id = ".$resource->id." AND i.id IN (".implode(',', $itemIds).") AND i.type <> ".ResourceItem::TYPE_HEADER."
        AND i.root_id = p.root_id ORDER BY p.priority, p.lft, p.level");

        $stmt->execute();
        $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if ( empty($items) )
        {
            return array(array(), array(), array());
        }

        foreach ( $items as $item )
        {
            $newItems[$item['resource_trade_id']][] = $item;

            $newItemIds[$item['id']]              = $item['id'];
            $tradeIds[$item['resource_trade_id']] = $item['resource_trade_id'];

            unset($item);
        }

        unset($items);

        $stmt = $pdo->prepare("SELECT ifc.relation_id, ifc.column_name, ifc.final_value, ifc.value
        FROM ".ResourceItemFormulatedColumnTable::getInstance()->getTableName()." ifc
        JOIN ".ResourceItemTable::getInstance()->getTableName()." i ON i.id = ifc.relation_id
        WHERE i.id IN (".implode(',', $newItemIds).") AND ifc.deleted_at IS NULL AND i.deleted_at IS NULL AND ifc.final_value <> 0");

        $stmt->execute();
        $itemFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach($itemFormulatedColumns as $itemFormulatedColumn)
        {
            if(!array_key_exists($itemFormulatedColumn['relation_id'], $formulatedColumns))
            {
                $formulatedColumns[$itemFormulatedColumn['relation_id']] = array();
            }

            array_push($formulatedColumns[$itemFormulatedColumn['relation_id']], $itemFormulatedColumn);

            unset($itemFormulatedColumn);
        }

        unset($itemFormulatedColumns);

        $trades = ResourceTradeTable::getRecordsByBQLibraryAndIds($resource, $tradeIds);

        return array($trades, $newItems, $formulatedColumns);
    }

    public static function getSelectedItemsWithSupplierRatesByItemIds(Resource $resource, array $itemIds)
    {
        $pdo               = self::getInstance()->getConnection()->getDbh();
        $newItemIds        = array();
        $tradeIds          = array();
        $newItems          = array();
        $formulatedColumns = array();

        if ( empty($itemIds) )
        {
            return array(array(), array(), array());
        }

        // get item(s) with supplier rates
        $stmt = $pdo->prepare('SELECT risr.resource_item_id FROM '.ResourceItemSelectedRateTable::getInstance()->getTableName().' risr
        WHERE risr.resource_item_id IN ('.implode(',', $itemIds).')');

        $stmt->execute();
        $resourceItemIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if ( empty($resourceItemIds) )
        {
            return array(array(), array(), array());
        }

        foreach ( $resourceItemIds as $resourceItemId )
        {
            $newItemIds[$resourceItemId['resource_item_id']] = $resourceItemId['resource_item_id'];

            unset($resourceItemIds);
        }

        unset($resourceItemIds);

        // will get selected item(s) first, then only get affected trade(s)
        // so that we can display it in print preview
        $stmt = $pdo->prepare("SELECT DISTINCT p.id, p.resource_trade_id, p.description, p.type, uom.id as uom_id, p.priority, p.lft, p.level,
        p.updated_at, uom.symbol AS uom_symbol, risr.id as resource_item_selected_rate_id, risr.sorting_type
        FROM ".ResourceItemTable::getInstance()->getTableName()." i
        JOIN ".ResourceItemTable::getInstance()->getTableName()." p ON (i.lft BETWEEN p.lft AND p.rgt AND p.deleted_at IS NULL)
        JOIN ".ResourceTradeTable::getInstance()->getTableName()." sort ON p.resource_trade_id = sort.id AND sort.deleted_at IS NULL
        LEFT JOIN ".UnitOfMeasurementTable::getInstance()->getTableName()." uom ON p.uom_id = uom.id AND uom.deleted_at IS NULL
        LEFT JOIN ".ResourceItemSelectedRateTable::getInstance()->getTableName()." risr ON p.id = risr.resource_item_id
        WHERE sort.resource_id = ".$resource->id." AND i.id IN (".implode(',', $newItemIds).") AND i.type <> ".ResourceItem::TYPE_HEADER."
        AND i.root_id = p.root_id ORDER BY p.priority, p.lft, p.level ASC");

        $stmt->execute();
        $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ( $items as $item )
        {
            $newItems[$item['resource_trade_id']][] = $item;
            $tradeIds[$item['resource_trade_id']]   = $item['resource_trade_id'];

            unset($item);
        }

        unset($items);

        $stmt = $pdo->prepare("SELECT ifc.relation_id, ifc.column_name, ifc.final_value, ifc.value
        FROM ".ResourceItemFormulatedColumnTable::getInstance()->getTableName()." ifc
        JOIN ".ResourceItemTable::getInstance()->getTableName()." i ON i.id = ifc.relation_id
        WHERE i.id IN (".implode(',', $newItemIds).") AND ifc.deleted_at IS NULL AND i.deleted_at IS NULL AND ifc.final_value <> 0");

        $stmt->execute();
        $itemFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach($itemFormulatedColumns as $itemFormulatedColumn)
        {
            if(!array_key_exists($itemFormulatedColumn['relation_id'], $formulatedColumns))
            {
                $formulatedColumns[$itemFormulatedColumn['relation_id']] = array();
            }

            array_push($formulatedColumns[$itemFormulatedColumn['relation_id']], $itemFormulatedColumn);

            unset($itemFormulatedColumn);
        }

        unset($itemFormulatedColumns);

        $trades = ResourceTradeTable::getRecordsByBQLibraryAndIds($resource, $tradeIds);

        return array($trades, $newItems, $formulatedColumns);
    }

    public static function updateRootPriority($priority, $resourceTradeId, $excludeId = null)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $sqlUpdateRoot = "UPDATE ".self::getInstance()->getTableName()." SET priority = priority + 1
            WHERE resource_trade_id =".$resourceTradeId." AND priority >=".$priority." AND id = root_id";

        if($excludeId and $excludeId > 0)
        {
            $sqlUpdateRoot .= " AND id <> ".$excludeId;
        }

        $sqlUpdateRoot .= " AND deleted_at IS NULL";

        $stmt = $pdo->prepare($sqlUpdateRoot);

        $stmt->execute();

        //update children priority same as root priority
        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." AS i SET priority = r.priority
            FROM ".self::getInstance()->getTableName()." AS r
            WHERE i.root_id = r.id AND i.id <> r.id AND i.priority <> r.priority AND i.resource_trade_id = ".$resourceTradeId."
            AND i.deleted_at IS NULL");

        $stmt->execute();
    }

    public static function importResourceItems(Doctrine_Connection $conn, $targetItemId, ResourceTrade $resourceTrade, Array $resourceItemIds, $withRate = false)
    {
        if(count($resourceItemIds) > 0 && array_search("", $resourceItemIds) === false)
        {
            $pdo = $conn->getDbh();

            $targetItem = $targetItemId > 0 ? self::getInstance()->find($targetItemId) : false;

            $stmt = $pdo->prepare('SELECT c.id, c.description, c.type, c.uom_id, c.level FROM
            '.ResourceItemTable::getInstance()->getTableName().' AS c
            LEFT JOIN '.ResourceItemTable::getInstance()->getTableName().' AS r ON c.root_id = r.id
            WHERE c.id IN ('.implode(",", $resourceItemIds).') AND c.deleted_at IS NULL AND r.deleted_at IS NULL
            ORDER BY r.priority, c.lft, c.level ASC');

            $stmt->execute();

            $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

            $priority = self::getTargetedResourceItemPriority($resourceTrade, $targetItem);

            $trees = array();

            if($items and !empty($items))
            {
                // Node Stack. Used to help building the hierarchy
                $stack = array();

                foreach($items as $item)
                {
                    $item['resource_trade_id']       = $resourceTrade->id;
                    $item['import_resource_item_id'] = $item['id'];
                    $item['__children']              = array();

                    // Number of stack items
                    $l = count($stack);

                    // Check if we're dealing with different levels
                    while($l > 0 && $stack[$l - 1]['level'] >= $item['level'])
                    {
                        array_pop($stack);
                        $l--;
                    }

                    // Stack is empty (we are inspecting the root)
                    if ($l == 0)
                    {
                        // Assigning the root child
                        $i         = count($trees);
                        $trees[$i] = $item;
                        $stack[]   = & $trees[$i];
                    }
                    else
                    {
                        // Add child to parent
                        $i                               = count($stack[$l - 1]['__children']);
                        $stack[$l - 1]['__children'][$i] = $item;
                        $stack[]                         = & $stack[$l - 1]['__children'][$i];
                    }
                }

                $firstLevelData        = array();
                $shiftExistingRLValues = false;

                foreach($trees as $key => $tree)
                {
                    if(!$targetItem)
                    {
                        ResourceItemTable::updateRootPriority($priority, $resourceTrade->id);

                        $trees[$key]['priority'] = $priority;
                        $trees[$key]['root_id']  = 0;
                        $trees[$key]['lft']      = 1;
                        $trees[$key]['rgt']      = 2;
                        $trees[$key]['level']    = 0;

                        $priority += 1;
                    }
                    else if($targetItem->type == ResourceItem::TYPE_HEADER)
                    {
                        if($key == 0)
                        {
                            $lft = $targetItem->lft + 1;
                        }
                        else
                        {
                            $__childrenCount = 0;
                            array_walk_recursive($trees[$key-1]['__children'], function($v, $k) use(&$__childrenCount){
                                if($k == "id") $__childrenCount++;
                            });

                            $lft = $__childrenCount * 2 + $trees[$key-1]['rgt'] + 1;
                        }

                        $trees[$key]['priority'] = $targetItem->priority;
                        $trees[$key]['root_id']  = $targetItem->root_id;
                        $trees[$key]['lft']      = $lft;
                        $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                        $trees[$key]['level']    = $targetItem->level + 1;
                        $shiftExistingRLValues   = true;
                    }
                    else if($targetItem->node->isRoot() && ($targetItem->type != ResourceItem::TYPE_HEADER))
                    {
                        //Update Priority
                        $targetItem->updateRootPriority($priority);

                        $trees[$key]['priority'] = $priority;
                        $trees[$key]['root_id']  = 0;
                        $trees[$key]['lft']      = 1;
                        $trees[$key]['rgt']      = 2;
                        $trees[$key]['level']    = 0;

                        $priority += 1;
                    }
                    else
                    {
                        if($key == 0)
                        {
                            $lft = $targetItem->rgt + 1;
                        }
                        else
                        {
                            $__childrenCount = 0;
                            array_walk_recursive($trees[$key-1]['__children'], function($v, $k) use(&$__childrenCount){
                                if($k == "id") $__childrenCount++;
                            });

                            $lft = $__childrenCount * 2 + $trees[$key-1]['rgt'] + 1;
                        }

                        $trees[$key]['priority'] = $targetItem->priority;
                        $trees[$key]['root_id']  = $targetItem->root_id;
                        $trees[$key]['lft']      = $lft;
                        $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                        $trees[$key]['level']    = $targetItem->level;

                        $shiftExistingRLValues = true;
                    }

                    $uomId = $tree['uom_id'] > 0 ? $tree['uom_id'] : 'NULL';

                    $firstLevelData[] = "(
                        '".pg_escape_string(trim($tree['description']))."',
                        ".$tree['type'].",
                        ".$uomId.",
                        ".$tree['resource_trade_id'].",
                        ".$tree['import_resource_item_id'].",
                        ".$trees[$key]['priority'].",
                        ".$trees[$key]['lft'].",
                        ".$trees[$key]['rgt'].",
                        ".$trees[$key]['level'].",
                        NOW(),
                        NOW()
                    )";

                    unset($tree);
                }

                $stmt = $pdo->prepare("INSERT INTO ".self::getInstance()->getTableName()." (description, type, uom_id, resource_trade_id, import_resource_item_id, priority, lft, rgt, level, created_at, updated_at) VALUES ".implode(",", $firstLevelData)." RETURNING id, import_resource_item_id, type");
                $stmt->execute();

                $returnIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                $rootIds = array();
                $rgtValues = array();

                $hasChildrenToInsert = false;

                foreach($returnIds as $key => $returnId)
                {
                    $itemCount = 1;

                    $rootId = $trees[$key]['root_id'] > 0 ? $trees[$key]['root_id'] : $returnId['id'];

                    $rootIds[] = "WHEN ".$returnId['id']." THEN ".$rootId;

                    $firstLevelNodeRightVal = $trees[$key]['rgt'];

                    if(count($trees[$key]['__children']) > 0)
                    {
                        list($firstLevelNodeRightVal, $itemCount) = self::resourceLoadNestedSetData($trees[$key]['__children'], $trees[$key], $rootId, $firstLevelNodeRightVal, $itemCount);

                        $hasChildrenToInsert = true;
                    }

                    $rgtValues[] = "WHEN ".$returnId['id']." THEN ".$firstLevelNodeRightVal;

                    /*
                    * If items were inserted at the middle of tree then we need to update the left and right values for the existing items
                    */
                    if($shiftExistingRLValues && $targetItem)
                    {
                        $delta = $itemCount * 2;
                        //shift all existing siblings
                        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET lft = (".$delta." + lft), rgt = (".$delta." + rgt) WHERE lft > ".$targetItem->lft." AND root_id = ".$targetItem->root_id." AND resource_trade_id = ".$resourceTrade->id." AND deleted_at IS NULL");
                        $stmt->execute();

                        if($targetItem->type == ResourceItem::TYPE_HEADER)
                        {
                            $lftSign = "<=";
                            $rgtSign = ">=";
                        }
                        else
                        {
                            $lftSign = "<";
                            $rgtSign = ">";
                        }

                        //update ancestors right values since the family is getting bigger!
                        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET rgt = (".$delta." + rgt) WHERE lft ".$lftSign." ".$targetItem->lft." AND rgt ".$rgtSign." ".$targetItem->rgt." AND root_id = ".$targetItem->root_id." AND resource_trade_id = ".$resourceTrade->id." AND deleted_at IS NULL");
                        $stmt->execute();
                    }

                    if($withRate and ($returnId['type'] != ResourceItem::TYPE_HEADER AND $returnId['type'] != ResourceItem::TYPE_NOID))
                    {
                        self::copyFormulatedColumnFromResourceItemByType($returnId['id'], $returnId['import_resource_item_id'], ResourceItem::FORMULATED_COLUMN_CONSTANT);
                        self::copyFormulatedColumnFromResourceItemByType($returnId['id'], $returnId['import_resource_item_id'], ResourceItem::FORMULATED_COLUMN_RATE);
                        self::copyFormulatedColumnFromResourceItemByType($returnId['id'], $returnId['import_resource_item_id'], ResourceItem::FORMULATED_COLUMN_WASTAGE);
                    }
                }

                $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET root_id = CASE id ".implode(" ", $rootIds)." END, rgt = CASE id ".implode(" ", $rgtValues)." END WHERE root_id IS NULL AND resource_trade_id = ".$resourceTrade->id." AND deleted_at IS NULL");
                $stmt->execute();

                if($hasChildrenToInsert)
                {
                    $stmt = $pdo->prepare("INSERT INTO " . self::getInstance()->getTableName() . " (description, type, uom_id, resource_trade_id, import_resource_item_id, root_id, priority, lft, rgt, level, created_at, updated_at) VALUES " . implode(",", self::getInstance()->importedBillItemsChildren) . " RETURNING id, import_resource_item_id, type");
                    $stmt->execute();

                    if ( $withRate )
                    {
                        $returnChildrenIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                        foreach ( $returnChildrenIds as $returnChildrenId )
                        {
                            if ( $returnChildrenId['type'] != ResourceItem::TYPE_HEADER and $returnChildrenId['type'] != ResourceItem::TYPE_NOID )
                            {
                                self::copyFormulatedColumnFromResourceItemByType($returnChildrenId['id'], $returnChildrenId['import_resource_item_id'], ResourceItem::FORMULATED_COLUMN_CONSTANT);
                                self::copyFormulatedColumnFromResourceItemByType($returnChildrenId['id'], $returnChildrenId['import_resource_item_id'], ResourceItem::FORMULATED_COLUMN_RATE);
                                self::copyFormulatedColumnFromResourceItemByType($returnChildrenId['id'], $returnChildrenId['import_resource_item_id'], ResourceItem::FORMULATED_COLUMN_WASTAGE);
                            }

                            unset( $returnChildrenId );
                        }

                        unset( $returnChildrenIds );
                    }
                }
            }

            unset($trees, $families, self::getInstance()->importedBillItemsChildren);
        }
    }

    public static function resourceLoadNestedSetData(Array $nestedSetData, Array $parent, $rootId, $parentRgtVal, $itemCount)
    {
        $functionName = __FUNCTION__;

        foreach($nestedSetData as $nestedSet)
        {
            unset($nestedSet['id']);

            /*
             * Since this will only be called when the node (parent) has children under it so we just add
             * all nodes in nested set as children for the parent node
             */
            $nestedSet['lft']   = $parentRgtVal;
            $nestedSet['rgt']   = $nestedSet['lft'] + 1;
            $nestedSet['level'] = $parent['level'] + 1;

            $parentRgtVal = $nestedSet['rgt'];

            $nestedSet['priority'] = $parent['priority'];

            $itemCount +=1;

            if(array_key_exists('__children', $nestedSet) and !empty($nestedSet['__children']))
            {
                list($parentRgtVal, $itemCount) = self::$functionName($nestedSet['__children'], $nestedSet, $rootId, $parentRgtVal, $itemCount);

                $nestedSet['rgt'] = $parentRgtVal;
            }

            $parentRgtVal += 1;

            $uomId = $nestedSet['uom_id'] > 0 ? $nestedSet['uom_id'] : 'NULL';

            self::getInstance()->importedBillItemsChildren[] = "(
                '".pg_escape_string(trim($nestedSet['description']))."',
                ".$nestedSet['type'].",
                ".$uomId.",
                ".$nestedSet['resource_trade_id'].",
                ".$nestedSet['import_resource_item_id'].",
                ".$rootId.",
                ".$nestedSet['priority'].",
                ".$nestedSet['lft'].",
                ".$nestedSet['rgt'].",
                ".$nestedSet['level'].",
                NOW(),
                NOW()
            )";
        }

        return array($parentRgtVal, $itemCount);
    }

    public static function importSORItems(Doctrine_Connection $conn, $targetItemId, ResourceTrade $resourceTrade, Array $sorItemIds, $withRate = false)
    {
        if(count($sorItemIds) > 0 && array_search("", $sorItemIds) === false)
        {
            $pdo = $conn->getDbh();

            $targetItem = $targetItemId > 0 ? self::getInstance()->find($targetItemId) : false;

            $stmt = $pdo->prepare('SELECT c.id, c.description, c.type, c.uom_id, c.level FROM
            '.ScheduleOfRateItemTable::getInstance()->getTableName().' AS c
            LEFT JOIN '.ScheduleOfRateItemTable::getInstance()->getTableName().' AS r ON c.root_id = r.id
            WHERE c.id IN ('.implode(",", $sorItemIds).') AND c.deleted_at IS NULL AND r.deleted_at IS NULL
            ORDER BY r.priority, c.lft, c.level ASC');

            $stmt->execute();

            $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

            $priority = self::getTargetedResourceItemPriority($resourceTrade, $targetItem);

            $trees = array();

            if($items and !empty($items))
            {
                // Node Stack. Used to help building the hierarchy
                $stack = array();

                foreach($items as $item)
                {
                    $item['resource_trade_id']  = $resourceTrade->id;
                    $item['import_sor_item_id'] = $item['id'];
                    $item['__children']         = array();

                    // Number of stack items
                    $l = count($stack);

                    // Check if we're dealing with different levels
                    while($l > 0 && $stack[$l - 1]['level'] >= $item['level'])
                    {
                        array_pop($stack);
                        $l--;
                    }

                    // Stack is empty (we are inspecting the root)
                    if ($l == 0)
                    {
                        // Assigning the root child
                        $i         = count($trees);
                        $trees[$i] = $item;
                        $stack[]   = & $trees[$i];
                    }
                    else
                    {
                        // Add child to parent
                        $i                               = count($stack[$l - 1]['__children']);
                        $stack[$l - 1]['__children'][$i] = $item;
                        $stack[]                         = & $stack[$l - 1]['__children'][$i];
                    }
                }

                $firstLevelData        = array();
                $shiftExistingRLValues = false;

                foreach($trees as $key => $tree)
                {
                    if(!$targetItem)
                    {
                        ResourceItemTable::updateRootPriority($priority, $resourceTrade->id);

                        $trees[$key]['priority'] = $priority;
                        $trees[$key]['root_id']  = 0;
                        $trees[$key]['lft']      = 1;
                        $trees[$key]['rgt']      = 2;
                        $trees[$key]['level']    = 0;

                        $priority += 1;
                    }
                    else if($targetItem->type == ResourceItem::TYPE_HEADER)
                    {
                        if($key == 0)
                        {
                            $lft = $targetItem->lft + 1;
                        }
                        else
                        {
                            $__childrenCount = 0;
                            array_walk_recursive($trees[$key-1]['__children'], function($v, $k) use(&$__childrenCount){
                                if($k == "id") $__childrenCount++;
                            });

                            $lft = $__childrenCount * 2 + $trees[$key-1]['rgt'] + 1;
                        }

                        $trees[$key]['priority'] = $targetItem->priority;
                        $trees[$key]['root_id']  = $targetItem->root_id;
                        $trees[$key]['lft']      = $lft;
                        $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                        $trees[$key]['level']    = $targetItem->level + 1;
                        $shiftExistingRLValues   = true;
                    }
                    else if($targetItem->node->isRoot() && ($targetItem->type != ResourceItem::TYPE_HEADER))
                    {
                        //Update Priority
                        $targetItem->updateRootPriority($priority);

                        $trees[$key]['priority'] = $priority;
                        $trees[$key]['root_id']  = 0;
                        $trees[$key]['lft']      = 1;
                        $trees[$key]['rgt']      = 2;
                        $trees[$key]['level']    = 0;

                        $priority += 1;
                    }
                    else
                    {
                        if($key == 0)
                        {
                            $lft = $targetItem->rgt + 1;
                        }
                        else
                        {
                            $__childrenCount = 0;
                            array_walk_recursive($trees[$key-1]['__children'], function($v, $k) use(&$__childrenCount){
                                if($k == "id") $__childrenCount++;
                            });

                            $lft = $__childrenCount * 2 + $trees[$key-1]['rgt'] + 1;
                        }

                        $trees[$key]['priority'] = $targetItem->priority;
                        $trees[$key]['root_id']  = $targetItem->root_id;
                        $trees[$key]['lft']      = $lft;
                        $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                        $trees[$key]['level']    = $targetItem->level;

                        $shiftExistingRLValues = true;
                    }

                    $uomId = $tree['uom_id'] > 0 ? $tree['uom_id'] : 'NULL';

                    $firstLevelData[] = "(
                        '".pg_escape_string(trim($tree['description']))."',
                        ".$tree['type'].",
                        ".$uomId.",
                        ".$tree['resource_trade_id'].",
                        ".$tree['import_sor_item_id'].",
                        ".$trees[$key]['priority'].",
                        ".$trees[$key]['lft'].",
                        ".$trees[$key]['rgt'].",
                        ".$trees[$key]['level'].",
                        NOW(),
                        NOW()
                    )";

                    unset($tree);
                }

                $stmt = $pdo->prepare("INSERT INTO ".self::getInstance()->getTableName()." (description, type, uom_id, resource_trade_id, import_sor_item_id, priority, lft, rgt, level, created_at, updated_at) VALUES ".implode(",", $firstLevelData)." RETURNING id, import_sor_item_id, type");
                $stmt->execute();

                $returnIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                $rootIds = array();
                $rgtValues = array();

                $hasChildrenToInsert = false;

                foreach($returnIds as $key => $returnId)
                {
                    $itemCount = 1;

                    $rootId = $trees[$key]['root_id'] > 0 ? $trees[$key]['root_id'] : $returnId['id'];

                    $rootIds[] = "WHEN ".$returnId['id']." THEN ".$rootId;

                    $firstLevelNodeRightVal = $trees[$key]['rgt'];

                    if(count($trees[$key]['__children']) > 0)
                    {
                        list($firstLevelNodeRightVal, $itemCount) = self::sorLoadNestedSetData($trees[$key]['__children'], $trees[$key], $rootId, $firstLevelNodeRightVal, $itemCount);

                        $hasChildrenToInsert = true;
                    }

                    $rgtValues[] = "WHEN ".$returnId['id']." THEN ".$firstLevelNodeRightVal;

                    /*
                    * If items were inserted at the middle of tree then we need to update the left and right values for the existing items
                    */
                    if($shiftExistingRLValues && $targetItem)
                    {
                        $delta = $itemCount * 2;
                        //shift all existing siblings
                        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET lft = (".$delta." + lft), rgt = (".$delta." + rgt) WHERE lft > ".$targetItem->lft." AND root_id = ".$targetItem->root_id." AND resource_trade_id = ".$resourceTrade->id." AND deleted_at IS NULL");
                        $stmt->execute();

                        if($targetItem->type == ResourceItem::TYPE_HEADER)
                        {
                            $lftSign = "<=";
                            $rgtSign = ">=";
                        }
                        else
                        {
                            $lftSign = "<";
                            $rgtSign = ">";
                        }

                        //update ancestors right values since the family is getting bigger!
                        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET rgt = (".$delta." + rgt) WHERE lft ".$lftSign." ".$targetItem->lft." AND rgt ".$rgtSign." ".$targetItem->rgt." AND root_id = ".$targetItem->root_id." AND resource_trade_id = ".$resourceTrade->id." AND deleted_at IS NULL");
                        $stmt->execute();
                    }

                    if($withRate and ($returnId['type'] != ResourceItem::TYPE_HEADER AND $returnId['type'] != ResourceItem::TYPE_NOID))
                    {
                        self::copyFormulatedColumnFromSORItemByType($returnId['id'], $returnId['import_sor_item_id'], ScheduleOfRateItem::FORMULATED_COLUMN_RATE);
                    }
                }

                $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET root_id = CASE id ".implode(" ", $rootIds)." END, rgt = CASE id ".implode(" ", $rgtValues)." END WHERE root_id IS NULL AND resource_trade_id = ".$resourceTrade->id." AND deleted_at IS NULL");
                $stmt->execute();

                if($hasChildrenToInsert)
                {
                    $stmt = $pdo->prepare("INSERT INTO ".self::getInstance()->getTableName()." (description, type, uom_id, resource_trade_id, import_sor_item_id, root_id, priority, lft, rgt, level, created_at, updated_at) VALUES ".implode(",", self::getInstance()->importedBillItemsChildren)." RETURNING id, import_sor_item_id, type");
                    $stmt->execute();

                    if($withRate)
                    {
                        $returnChildrenIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                        foreach($returnChildrenIds as $returnChildrenId)
                        {
                            if($returnChildrenId['type'] != ResourceItem::TYPE_HEADER and $returnChildrenId['type'] != ResourceItem::TYPE_NOID)
                            {
                                self::copyFormulatedColumnFromSORItemByType($returnChildrenId['id'], $returnChildrenId['import_sor_item_id'], ScheduleOfRateItem::FORMULATED_COLUMN_RATE);
                            }

                            unset($returnChildrenId);
                        }

                        unset($returnChildrenIds);
                    }
                }
            }

            unset($trees, $families, self::getInstance()->importedBillItemsChildren);
        }
    }

    public static function sorLoadNestedSetData(Array $nestedSetData, Array $parent, $rootId, $parentRgtVal, $itemCount)
    {
        $functionName = __FUNCTION__;

        foreach($nestedSetData as $nestedSet)
        {
            unset($nestedSet['id']);

            /*
             * Since this will only be called when the node (parent) has children under it so we just add
             * all nodes in nested set as children for the parent node
             */
            $nestedSet['lft']   = $parentRgtVal;
            $nestedSet['rgt']   = $nestedSet['lft'] + 1;
            $nestedSet['level'] = $parent['level'] + 1;

            $parentRgtVal = $nestedSet['rgt'];

            $nestedSet['priority'] = $parent['priority'];

            $itemCount +=1;

            if(array_key_exists('__children', $nestedSet) and !empty($nestedSet['__children']))
            {
                list($parentRgtVal, $itemCount) = self::$functionName($nestedSet['__children'], $nestedSet, $rootId, $parentRgtVal, $itemCount);

                $nestedSet['rgt'] = $parentRgtVal;
            }

            $parentRgtVal += 1;

            $uomId = $nestedSet['uom_id'] > 0 ? $nestedSet['uom_id'] : 'NULL';

            self::getInstance()->importedBillItemsChildren[] = "(
                '".pg_escape_string(trim($nestedSet['description']))."',
                ".$nestedSet['type'].",
                ".$uomId.",
                ".$nestedSet['resource_trade_id'].",
                ".$nestedSet['import_sor_item_id'].",
                ".$rootId.",
                ".$nestedSet['priority'].",
                ".$nestedSet['lft'].",
                ".$nestedSet['rgt'].",
                ".$nestedSet['level'].",
                NOW(),
                NOW()
            )";
        }

        return array($parentRgtVal, $itemCount);
    }

    public static function importBQLibraryItems(Doctrine_Connection $conn, $targetItemId, ResourceTrade $resourceTrade, Array $bqLibraryItemIds, $withRate = false)
    {
        if(count($bqLibraryItemIds) > 0 && array_search("", $bqLibraryItemIds) === false)
        {
            $pdo = $conn->getDbh();

            $targetItem = $targetItemId > 0 ? self::getInstance()->find($targetItemId) : false;

            $stmt = $pdo->prepare('SELECT c.id, c.description, c.type, c.uom_id, c.level FROM
            '.BQItemTable::getInstance()->getTableName().' AS c
            LEFT JOIN '.BQItemTable::getInstance()->getTableName().' AS r ON c.root_id = r.id
            WHERE c.id IN ('.implode(",", $bqLibraryItemIds).') AND c.deleted_at IS NULL AND r.deleted_at IS NULL
            ORDER BY r.priority, c.lft, c.level ASC');

            $stmt->execute();

            $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

            $priority = self::getTargetedResourceItemPriority($resourceTrade, $targetItem);

            $trees = array();

            if($items and !empty($items))
            {
                // Node Stack. Used to help building the hierarchy
                $stack = array();

                foreach($items as $item)
                {
                    $item['resource_trade_id'] = $resourceTrade->id;
                    $item['import_bq_item_id'] = $item['id'];
                    $item['__children']        = array();

                    // Number of stack items
                    $l = count($stack);

                    // Check if we're dealing with different levels
                    while($l > 0 && $stack[$l - 1]['level'] >= $item['level'])
                    {
                        array_pop($stack);
                        $l--;
                    }

                    // Stack is empty (we are inspecting the root)
                    if ($l == 0)
                    {
                        // Assigning the root child
                        $i         = count($trees);
                        $trees[$i] = $item;
                        $stack[]   = & $trees[$i];
                    }
                    else
                    {
                        // Add child to parent
                        $i                               = count($stack[$l - 1]['__children']);
                        $stack[$l - 1]['__children'][$i] = $item;
                        $stack[]                         = & $stack[$l - 1]['__children'][$i];
                    }
                }

                $firstLevelData        = array();
                $shiftExistingRLValues = false;

                foreach($trees as $key => $tree)
                {
                    if(!$targetItem)
                    {
                        ResourceItemTable::updateRootPriority($priority, $resourceTrade->id);

                        $trees[$key]['priority'] = $priority;
                        $trees[$key]['root_id']  = 0;
                        $trees[$key]['lft']      = 1;
                        $trees[$key]['rgt']      = 2;
                        $trees[$key]['level']    = 0;

                        $priority += 1;
                    }
                    else if($targetItem->type == ResourceItem::TYPE_HEADER)
                    {
                        if($key == 0)
                        {
                            $lft = $targetItem->lft + 1;
                        }
                        else
                        {
                            $__childrenCount = 0;
                            array_walk_recursive($trees[$key-1]['__children'], function($v, $k) use(&$__childrenCount){
                                if($k == "id") $__childrenCount++;
                            });

                            $lft = $__childrenCount * 2 + $trees[$key-1]['rgt'] + 1;
                        }

                        $trees[$key]['priority'] = $targetItem->priority;
                        $trees[$key]['root_id']  = $targetItem->root_id;
                        $trees[$key]['lft']      = $lft;
                        $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                        $trees[$key]['level']    = $targetItem->level + 1;
                        $shiftExistingRLValues   = true;
                    }
                    else if($targetItem->node->isRoot() && ($targetItem->type != ResourceItem::TYPE_HEADER))
                    {
                        //Update Priority
                        $targetItem->updateRootPriority($priority);

                        $trees[$key]['priority'] = $priority;
                        $trees[$key]['root_id']  = 0;
                        $trees[$key]['lft']      = 1;
                        $trees[$key]['rgt']      = 2;
                        $trees[$key]['level']    = 0;

                        $priority += 1;
                    }
                    else
                    {
                        if($key == 0)
                        {
                            $lft = $targetItem->rgt + 1;
                        }
                        else
                        {
                            $__childrenCount = 0;
                            array_walk_recursive($trees[$key-1]['__children'], function($v, $k) use(&$__childrenCount){
                                if($k == "id") $__childrenCount++;
                            });

                            $lft = $__childrenCount * 2 + $trees[$key-1]['rgt'] + 1;
                        }

                        $trees[$key]['priority'] = $targetItem->priority;
                        $trees[$key]['root_id']  = $targetItem->root_id;
                        $trees[$key]['lft']      = $lft;
                        $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                        $trees[$key]['level']    = $targetItem->level;

                        $shiftExistingRLValues = true;
                    }

                    $uomId = $tree['uom_id'] > 0 ? $tree['uom_id'] : 'NULL';

                    $firstLevelData[] = "(
                        '".pg_escape_string(trim($tree['description']))."',
                        ".$tree['type'].",
                        ".$uomId.",
                        ".$tree['resource_trade_id'].",
                        ".$tree['import_bq_item_id'].",
                        ".$trees[$key]['priority'].",
                        ".$trees[$key]['lft'].",
                        ".$trees[$key]['rgt'].",
                        ".$trees[$key]['level'].",
                        NOW(),
                        NOW()
                    )";

                    unset($tree);
                }

                $stmt = $pdo->prepare("INSERT INTO ".self::getInstance()->getTableName()." (description, type, uom_id, resource_trade_id, import_bq_item_id, priority, lft, rgt, level, created_at, updated_at) VALUES ".implode(",", $firstLevelData)." RETURNING id, import_bq_item_id, type");
                $stmt->execute();

                $returnIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                $rootIds = array();
                $rgtValues = array();

                $hasChildrenToInsert = false;

                foreach($returnIds as $key => $returnId)
                {
                    $itemCount = 1;

                    $rootId = $trees[$key]['root_id'] > 0 ? $trees[$key]['root_id'] : $returnId['id'];

                    $rootIds[] = "WHEN ".$returnId['id']." THEN ".$rootId;

                    $firstLevelNodeRightVal = $trees[$key]['rgt'];

                    if(count($trees[$key]['__children']) > 0)
                    {
                        list($firstLevelNodeRightVal, $itemCount) = self::bqLibraryLoadNestedSetData($trees[$key]['__children'], $trees[$key], $rootId, $firstLevelNodeRightVal, $itemCount);

                        $hasChildrenToInsert = true;
                    }

                    $rgtValues[] = "WHEN ".$returnId['id']." THEN ".$firstLevelNodeRightVal;

                    /*
                    * If items were inserted at the middle of tree then we need to update the left and right values for the existing items
                    */
                    if($shiftExistingRLValues && $targetItem)
                    {
                        $delta = $itemCount * 2;
                        //shift all existing siblings
                        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET lft = (".$delta." + lft), rgt = (".$delta." + rgt) WHERE lft > ".$targetItem->lft." AND root_id = ".$targetItem->root_id." AND resource_trade_id = ".$resourceTrade->id." AND deleted_at IS NULL");
                        $stmt->execute();

                        if($targetItem->type == ResourceItem::TYPE_HEADER)
                        {
                            $lftSign = "<=";
                            $rgtSign = ">=";
                        }
                        else
                        {
                            $lftSign = "<";
                            $rgtSign = ">";
                        }

                        //update ancestors right values since the family is getting bigger!
                        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET rgt = (".$delta." + rgt) WHERE lft ".$lftSign." ".$targetItem->lft." AND rgt ".$rgtSign." ".$targetItem->rgt." AND root_id = ".$targetItem->root_id." AND resource_trade_id = ".$resourceTrade->id." AND deleted_at IS NULL");
                        $stmt->execute();
                    }

                    if($withRate and ($returnId['type'] != ResourceItem::TYPE_HEADER AND $returnId['type'] != ResourceItem::TYPE_NOID))
                    {
                        self::copyFormulatedColumnFromBQLibraryItemByType($returnId['id'], $returnId['import_bq_item_id'], BQItem::FORMULATED_COLUMN_RATE);
                    }
                }

                $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET root_id = CASE id ".implode(" ", $rootIds)." END, rgt = CASE id ".implode(" ", $rgtValues)." END WHERE root_id IS NULL AND resource_trade_id = ".$resourceTrade->id." AND deleted_at IS NULL");
                $stmt->execute();

                if($hasChildrenToInsert)
                {
                    $stmt = $pdo->prepare("INSERT INTO ".self::getInstance()->getTableName()." (description, type, uom_id, resource_trade_id, import_bq_item_id, root_id, priority, lft, rgt, level, created_at, updated_at) VALUES ".implode(",", self::getInstance()->importedBillItemsChildren)." RETURNING id, import_bq_item_id, type");
                    $stmt->execute();

                    if($withRate)
                    {
                        $returnChildrenIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                        foreach($returnChildrenIds as $returnChildrenId)
                        {
                            if($returnChildrenId['type'] != ResourceItem::TYPE_HEADER and $returnChildrenId['type'] != ResourceItem::TYPE_NOID)
                            {
                                self::copyFormulatedColumnFromBQLibraryItemByType($returnChildrenId['id'], $returnChildrenId['import_bq_item_id'], BQItem::FORMULATED_COLUMN_RATE);
                            }

                            unset($returnChildrenId);
                        }

                        unset($returnChildrenIds);
                    }
                }
            }

            unset($trees, $families, self::getInstance()->importedBillItemsChildren);
        }
    }

    public static function bqLibraryLoadNestedSetData(Array $nestedSetData, Array $parent, $rootId, $parentRgtVal, $itemCount)
    {
        $functionName = __FUNCTION__;

        foreach($nestedSetData as $nestedSet)
        {
            unset($nestedSet['id']);

            /*
             * Since this will only be called when the node (parent) has children under it so we just add
             * all nodes in nested set as children for the parent node
             */
            $nestedSet['lft']   = $parentRgtVal;
            $nestedSet['rgt']   = $nestedSet['lft'] + 1;
            $nestedSet['level'] = $parent['level'] + 1;

            $parentRgtVal = $nestedSet['rgt'];

            $nestedSet['priority'] = $parent['priority'];

            $itemCount +=1;

            if(array_key_exists('__children', $nestedSet) and !empty($nestedSet['__children']))
            {
                list($parentRgtVal, $itemCount) = self::$functionName($nestedSet['__children'], $nestedSet, $rootId, $parentRgtVal, $itemCount);

                $nestedSet['rgt'] = $parentRgtVal;
            }

            $parentRgtVal += 1;

            $uomId = $nestedSet['uom_id'] > 0 ? $nestedSet['uom_id'] : 'NULL';

            self::getInstance()->importedBillItemsChildren[] = "(
                '".pg_escape_string(trim($nestedSet['description']))."',
                ".$nestedSet['type'].",
                ".$uomId.",
                ".$nestedSet['resource_trade_id'].",
                ".$nestedSet['import_bq_item_id'].",
                ".$rootId.",
                ".$nestedSet['priority'].",
                ".$nestedSet['lft'].",
                ".$nestedSet['rgt'].",
                ".$nestedSet['level'].",
                NOW(),
                NOW()
            )";
        }

        return array($parentRgtVal, $itemCount);
    }

    public static function copyFormulatedColumnFromResourceItemByType($newResourceItemId, $oldResourceItemId, $type = ResourceItem::FORMULATED_COLUMN_RATE)
    {
        $formulatedColumn = ResourceItemTable::getFormulatedColumnByRelationIdAndColumnName($oldResourceItemId, $type, Doctrine_Core::HYDRATE_ARRAY);

        self::insertFormulatedColumnRow($newResourceItemId, $formulatedColumn);
    }

    public static function copyFormulatedColumnFromSORItemByType($newResourceItemId, $oldResourceItemId, $type = ScheduleOfRateItem::FORMULATED_COLUMN_RATE)
    {
        $formulatedColumn = ScheduleOfRateItemTable::getFormulatedColumnByRelationIdAndColumnName($oldResourceItemId, $type, Doctrine_Core::HYDRATE_ARRAY);

        self::insertFormulatedColumnRow($newResourceItemId, $formulatedColumn);
    }

    public static function copyFormulatedColumnFromBQLibraryItemByType($newResourceItemId, $oldResourceItemId, $type = BQItem::FORMULATED_COLUMN_RATE)
    {
        $formulatedColumn = BQItemTable::getFormulatedColumnByRelationIdAndColumnName($oldResourceItemId, $type, Doctrine_Core::HYDRATE_ARRAY);

        self::insertFormulatedColumnRow($newResourceItemId, $formulatedColumn);
    }

    private static function insertFormulatedColumnRow($newResourceItemId, $formulatedColumn)
    {
        if ( $formulatedColumn )
        {
            $pdo = self::getInstance()->getConnection()->getDbh();

            $userId     = sfContext::getInstance()->getUser()->getAttribute('user_id', null, 'sfGuardSecurityUser');
            $finalValue = ( $formulatedColumn['final_value'] ) ? $formulatedColumn['final_value'] : 0;

            $stmt = $pdo->prepare("INSERT INTO " . ResourceItemFormulatedColumnTable::getInstance()->getTableName() . " (relation_id, column_name, value, final_value, created_at, updated_at, created_by, updated_by)
                VALUES (" . $newResourceItemId . ", '" . $formulatedColumn['column_name'] . "', '" . $finalValue . "', " . $finalValue . ", NOW(), NOW(), " . $userId . ", " . $userId . ")");

            $stmt->execute();
        }
    }

    private static function getTargetedResourceItemPriority(ResourceTrade $resourceTrade, $targetItem)
    {
        if ( !$targetItem )
        {
            /* If No Target Item Specify We Get First Root Item as target Item */
            $rootItem = DoctrineQuery::create()->select('i.id')
                ->from('ResourceItem i')
                ->where('i.resource_trade_id = ?', array( $resourceTrade->id ))
                ->andWhere('i.root_id = i.id')
                ->limit(1)
                ->addOrderBy('i.priority ASC')
                ->fetchOne();

            /*
             * we get target item (assumed root) priority first because later we will increment the priority
             * when we are creating root items.
             */
            $priority = $rootItem ? $rootItem->priority : 0;
        }
        else
        {
            $record = DoctrineQuery::create()->select('i.priority')
                ->from('ResourceItem i')
                ->where('i.resource_trade_id = ?', array( $resourceTrade->id ))
                ->andWhere('i.root_id = i.id')
                ->andWhere('i.id = ? ', $targetItem->id)
                ->limit(1)
                ->addOrderBy('i.priority ASC')
                ->fetchOne();

            $priority = $record ? $record->priority + 1 : 0;
        }

        return $priority;
    }

    public static function getRecordsWithDeliveryOrderQuantities(ProjectStructure $project, ResourceTrade $resourceTrade)
    {
        $newDOQuantities             = StockInDeliveryOrderItemQuantityTable::getOverAllItemQuantitiesFilterByResourceItemIdByProject($project);
        $newSOQuantities             = StockOutUsedQuantityItemQuantityTable::getOverAllItemQuantitiesFilterByResourceItemIdByProject($project);
        $totalCostsByResourceItemIds = StockInInvoiceItemTable::getTotalCost($project, $resourceTrade);
        $invoiceItemRemarks          = StockInInvoiceItemTable::getInvoiceRemarks($project, $resourceTrade);
        $resourceItemIds             = array_keys($totalCostsByResourceItemIds);
        $resourceItems               = StockInInvoiceItemTable::queryToGetResourceItemHierarchy($resourceItemIds);

        foreach ( $resourceItems as $key => $item )
        {
            $generatedRemarks = null;
            $totalCost        = 0;
            $doQuantity       = 0;
            $soQuantity       = 0;

            if ( isset($totalCostsByResourceItemIds[$item['id']]) )
            {
                $totalCost = $totalCostsByResourceItemIds[$item['id']];
            }

            if ( isset($newDOQuantities[$item['id']]) )
            {
                $doQuantity = $newDOQuantities[$item['id']];
            }

            if ( isset($newSOQuantities[$item['id']]) )
            {
                $soQuantity = $newSOQuantities[$item['id']];
            }

            if ( isset($invoiceItemRemarks[$item['id']]) )
            {
                $remarks = array_unique($invoiceItemRemarks[$item['id']]);

                $generatedRemarks = StockInInvoiceItemTable::formatRemark($remarks);

                unset($remarks, $invoiceItemRemarks[$item['id']]);
            }

            $resourceItems[$key]['description']        = $resourceItems[$key]['description'] . $generatedRemarks;
            $resourceItems[$key]['uom_symbol']         = $item['uom'];
            $resourceItems[$key]['total_cost']         = $totalCost;
            $resourceItems[$key]['do_quantity']        = $doQuantity;
            $resourceItems[$key]['stock_out_quantity'] = $soQuantity;
            $resourceItems[$key]['balance_quantity']   = $doQuantity - $soQuantity;

            unset($item);
        }

        return $resourceItems;
    }

    public static function getAffectedTradeIdsThatHasStockInsByProjectAndResourceItemIds($resourceItemIds)
    {
        $data            = array();
        $resourceItemIds = json_decode($resourceItemIds);

        if ( empty($resourceItemIds) )
        {
            return $data;
        }

        $resourceItems = StockInInvoiceItemTable::queryToGetResourceItemWithoutHead($resourceItemIds);

        foreach ( $resourceItems as $item )
        {
            $data[$item['resource_trade_id']][] = $item['id'];

            unset($item);
        }

        unset($resourceItems);

        return $data;
    }

    public static function getImportRecordsWithDeliveryOrderQuantities(StockOutUsedQuantity $stockOutUsedQuantity, ResourceTrade $resourceTrade)
    {
        $notInResourceItemIds  = array();
        $project               = $stockOutUsedQuantity->Project;
        $existingResourceItems = StockOutUsedQuantityItemQuantityTable::getAffectedResourceItems($stockOutUsedQuantity);

        foreach ( $existingResourceItems as $existingResourceItem )
        {
            $notInResourceItemIds[] = $existingResourceItem['resource_item_id'];

            unset($existingResourceItem);
        }

        unset($existingResourceItems);

        $newDOQuantities             = StockInDeliveryOrderItemQuantityTable::getOverAllItemQuantitiesFilterByResourceItemIdByProject($project);
        $totalCostsByResourceItemIds = StockInInvoiceItemTable::getTotalCost($project, $resourceTrade, $notInResourceItemIds);
        $resourceItemIds             = array_keys($totalCostsByResourceItemIds);
        $resourceItems               = StockInInvoiceItemTable::queryToGetResourceItemHierarchy($resourceItemIds);
        $newSOQuantities             = StockOutUsedQuantityItemQuantityTable::getOverAllItemQuantitiesFilterByResourceItemIdByProject($project);
        
        foreach ( $resourceItems as $key => $item )
        {
            $doQuantity = 0;
            $soQuantity = 0;

            if ( isset($newDOQuantities[$item['id']]) )
            {
                $doQuantity = $newDOQuantities[$item['id']];
            }

            if ( isset($newSOQuantities[$item['id']]) )
            {
                $soQuantity = $newSOQuantities[$item['id']];
            }

            $resourceItems[$key]['uom_symbol']         = $item['uom'];
            $resourceItems[$key]['do_quantity']        = $doQuantity;
            $resourceItems[$key]['stock_out_quantity'] = $soQuantity;
            $resourceItems[$key]['balance_quantity']   = $doQuantity - $soQuantity;

            unset($item);
        }

        return $resourceItems;
    }
}