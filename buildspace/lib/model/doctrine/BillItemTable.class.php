<?php

/**
 * BillItemTable
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class BillItemTable extends Doctrine_Table {

    private $importedBillItemsChildren = array();

    /**
     * Returns an instance of this class.
     *
     * @return object BillItemTable
     */
    public static function getInstance()
    {
        return Doctrine_Core::getTable('BillItem');
    }

    public static function getItemTypeText($type)
    {
        switch ($type)
        {
            case BillItem::TYPE_HEADER:
                return BillItem::TYPE_HEADER_TEXT;

            case BillItem::TYPE_HEADER_N:
                return BillItem::TYPE_HEADER_N_TEXT;

            case BillItem::TYPE_WORK_ITEM:
                return BillItem::TYPE_WORK_ITEM_TEXT;

            case BillItem::TYPE_NOID:
                return BillItem::TYPE_NOID_TEXT;

            case BillItem::TYPE_ITEM_HTML_EDITOR:
                return BillItem::TYPE_ITEM_HTML_EDITOR_TEXT;

            case BillItem::TYPE_ITEM_PROVISIONAL:
                return BillItem::TYPE_ITEM_PROVISIONAL_TEXT;

            case BillItem::TYPE_ITEM_NOT_LISTED:
                return BillItem::TYPE_ITEM_NOT_LISTED_TEXT;

            case BillItem::TYPE_ITEM_PC_RATE:
                return BillItem::TYPE_ITEM_PC_RATE_TEXT;

            case BillItem::TYPE_ITEM_LUMP_SUM:
                return BillItem::TYPE_ITEM_LUMP_SUM_TEXT;

            case BillItem::TYPE_ITEM_LUMP_SUM_EXCLUDE:
                return BillItem::TYPE_ITEM_LUMP_SUM_EXCLUDE_TEXT;

            case BillItem::TYPE_ITEM_LUMP_SUM_PERCENT:
                return BillItem::TYPE_ITEM_LUMP_SUM_PERCENT_TEXT;

            case BillItem::TYPE_ITEM_RATE_ONLY:
                return BillItem::TYPE_ITEM_RATE_ONLY_TEXT;

            default:
                return null;
        }
    }

    public static function generateBillRef($prefix = null, $elementNo = null, $pageNo = null, $char = null)
    {
        //Temporary manual generate Bill Ref, Later to follow Bill Printout Setting

        if ( $elementNo && $pageNo && $char )
        {
            return $prefix . $elementNo . '/' . $pageNo . ' ' . $char;
        }
        else if ( $char )
        {
            return $char;
        }
        else
        {
            return '';
        }
    }

    public static function getItemTypeId($typeText)
    {
        switch ($typeText)
        {
            case BillItem::TYPE_HEADER_TEXT:
                return BillItem::TYPE_HEADER;

            case BillItem::TYPE_HEADER_N_TEXT:
                return BillItem::TYPE_HEADER_N;

            case BillItem::TYPE_WORK_ITEM_TEXT:
                return BillItem::TYPE_WORK_ITEM;

            case BillItem::TYPE_NOID_TEXT:
                return BillItem::TYPE_NOID;

            case BillItem::TYPE_ITEM_HTML_EDITOR_TEXT:
                return BillItem::TYPE_ITEM_HTML_EDITOR;

            case BillItem::TYPE_ITEM_PROVISIONAL_TEXT:
                return BillItem::TYPE_ITEM_PROVISIONAL;

            case BillItem::TYPE_ITEM_NOT_LISTED_TEXT:
                return BillItem::TYPE_ITEM_NOT_LISTED;

            case BillItem::TYPE_ITEM_PC_RATE_TEXT:
                return BillItem::TYPE_ITEM_PC_RATE;

            case BillItem::TYPE_ITEM_LUMP_SUM_TEXT:
                return BillItem::TYPE_ITEM_LUMP_SUM;

            case BillItem::TYPE_ITEM_LUMP_SUM_EXCLUDE_TEXT:
                return BillItem::TYPE_ITEM_LUMP_SUM_EXCLUDE;

            case BillItem::TYPE_ITEM_LUMP_SUM_PERCENT_TEXT:
                return BillItem::TYPE_ITEM_LUMP_SUM_PERCENT;

            case BillItem::TYPE_ITEM_RATE_ONLY_TEXT:
                return BillItem::TYPE_ITEM_RATE_ONLY;

            default:
                return null;
        }
    }


    /* Received array of element Ids and return Element List */
    public static function getRootItemByElementIds($elementIds, $hydrate = null)
    {
        $query = DoctrineQuery::create()->select('e.*, i.id, i.lft, i.rgt')
            ->from('BillElement e')
            ->leftJoin('e.Items i')
            ->andWhere('e.id IN ?', array( $elementIds ))
            ->addWhere('i.root_id = i.id')
            ->addOrderBy('e.priority ASC');

        if ( !is_null($hydrate) )
        {
            $query->setHydrationMode($hydrate);
        }

        return $query->execute();
    }

    public static function getFormulatedColumnByRelationIdAndColumnName($id, $columnName, $hydrate = null)
    {
        $query = DoctrineQuery::create()->select('*')
            ->from('BillItemFormulatedColumn c')
            ->where('c.relation_id = ?', $id)
            ->andWhere('c.column_name = ?', $columnName)
            ->limit(1);

        if ( !is_null($hydrate) )
        {
            $query->setHydrationMode($hydrate);
        }

        return $query->fetchOne();
    }

    public static function createItemFromLastRow($previousItem, $elementId, $fieldName = null, $fieldValue = null, $currentBQAddendumId)
    {
        $formulatedColumnConstants             = Utilities::getAllFormulatedColumnConstants('BillItem');
        $billItemTypeFormulatedColumnConstants = Utilities::getAllFormulatedColumnConstants('BillItemTypeReference');

        $item = new BillItem();

        $item->element_id          = $elementId;
        $item->project_revision_id = $currentBQAddendumId;

        if ( $fieldName )
        {
            $columns = array_keys(self::getInstance()->getColumns());
            if ( in_array($fieldName, $columns) and !in_array($fieldName, $formulatedColumnConstants) and !in_array($fieldName, $billItemTypeFormulatedColumnConstants) )
            {
                $fieldValue = ( $fieldName == 'uom_id' and $fieldValue == - 1 ) ? null : $fieldValue;
                $item->{'set' . sfInflector::camelize($fieldName)}($fieldValue);
            }
        }

        if ( $fieldName != 'type' )
        {
            $item->type = ( $previousItem ) ? ProjectStructure::getDefaultItemType($previousItem->Element->ProjectStructure->BillType->type) : ProjectStructure::getDefaultItemTypeByElementId($elementId);
        }

        $asRoot   = true;
        $priority = 0;

        if ( $previousItem )
        {
            if ( $previousItem->node->isRoot() )
            {
                $priority = $previousItem->priority + 1;
            }
            else
            {
                $asRoot = false;
                $item->node->insertAsNextSiblingOf($previousItem);

                $priority = $previousItem->priority;
            }
        }

        $item->priority = $priority;
        $item->save();

        if ( $asRoot )
        {
            $item->getTable()->getTree()->createRoot($item);

            $item->updateRootPriority($priority, $item->id);
        }

        if(in_array($item->type, BillItem::$noMarkupItemTypes))
        {
            $item->Element->removeMarkup();
        }

        return $item;
    }

    public static function createItem(BillItem $nextItem, $currentBQAddendumId)
    {
        $item                      = new BillItem();
        $item->element_id          = $nextItem->element_id;
        $item->type                = ProjectStructure::getDefaultItemType($nextItem->Element->ProjectStructure->BillType->type);
        $item->project_revision_id = $currentBQAddendumId;

        if ( $nextItem->node->isRoot() )
        {
            $priority = $nextItem->priority;

            $item->priority = $priority;

            $item->save();

            $node = $item->node;

            if ( $node->isValidNode() )
            {
                $node->makeRoot($item->id);
            }
            else
            {
                $item->getTable()->getTree()->createRoot($item);
            }

            $item->updateRootPriority($priority, $item->id);
        }
        else
        {
            $item->node->insertAsPrevSiblingOf($nextItem);
            $item->priority = $nextItem->priority;
        }

        $item->save();

        return $item;
    }

    public static function calculateRateAfterMarkupById($id, Array $markupSettingsInfo)
    {
        $itemMarkupPercentage = 0;

        if ( $markupSettingsInfo['item_markup_enabled'] )
        {
            $itemMarkupResult = DoctrineQuery::create()->select('c.final_value')
                ->from('BillItemFormulatedColumn c')
                ->where('c.relation_id = ?', $id)
                ->andWhere('c.column_name = ?', BillItem::FORMULATED_COLUMN_MARKUP_PERCENTAGE)
                ->limit(1)
                ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
                ->fetchOne();

            $itemMarkupPercentage = $itemMarkupResult ? $itemMarkupResult['final_value'] : 0;
        }

        $itemRateResult = DoctrineQuery::create()->select('c.final_value')
            ->from('BillItemFormulatedColumn c')->leftJoin('c.BillItem i')
            ->where('c.relation_id = ?', $id)
            ->andWhere('c.column_name = ?', BillItem::FORMULATED_COLUMN_RATE)
            ->limit(1)
            ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
            ->fetchOne();

        $rate = $itemRateResult ? $itemRateResult['final_value'] : 0;

        return self::calculateRateAfterMarkup($rate, $itemMarkupPercentage, $markupSettingsInfo);
    }

    public static function calculateRateAfterMarkup($rate, $itemMarkupPercentage, Array $markupSettingsInfo)
    {
        $rate                 = (float) $rate;
        $itemMarkupPercentage = (float) $itemMarkupPercentage;

        if ( $markupSettingsInfo['item_markup_enabled'] or $markupSettingsInfo['element_markup_enabled'] or $markupSettingsInfo['bill_markup_enabled'] )
        {
            if ( $markupSettingsInfo['item_markup_enabled'] and $itemMarkupPercentage != 0 )
            {
                $rate += $rate * ( $itemMarkupPercentage / 100 );
            }

            if ( $markupSettingsInfo['element_markup_enabled'] and $markupSettingsInfo['element_markup_percentage'] != 0 )
            {
                $elementMarkupPercentage = (float) $markupSettingsInfo['element_markup_percentage'];
                $rate += $rate * ( $elementMarkupPercentage / 100 );
            }

            if ( $markupSettingsInfo['bill_markup_enabled'] and $markupSettingsInfo['bill_markup_percentage'] != 0 )
            {
                $billMarkupPercentage = (float) $markupSettingsInfo['bill_markup_percentage'];
                $rate += $rate * ( $billMarkupPercentage / 100 );
            }

            switch ($markupSettingsInfo['rounding_type'])
            {
                case BillMarkupSetting::ROUNDING_TYPE_UPWARD:
                    return ceil($rate);
                case BillMarkupSetting::ROUNDING_TYPE_DOWNWARD:
                    return floor($rate);
                case BillMarkupSetting::ROUNDING_TYPE_NEAREST_WHOLE_NUMBER:
                    return round($rate);
                case BillMarkupSetting::ROUNDING_TYPE_NEAREST_TENTH:
                    return round($rate * 10) / 10;
                default:
                    return round($rate, 2);
            }
        }
        else
        {
            return round($rate, 2);
        }
    }

    public static function updateBillItemTotalColumns($billItemId, $billElementId, $disableUpdateMarkupAmount = false)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $grandTotalQuantityStatement = "SELECT COALESCE(SUM(r.total_quantity), 0) FROM " . BillItemTypeReferenceTable::getInstance()->getTableName() . "
        AS r LEFT JOIN " . BillColumnSettingTable::getInstance()->getTableName() . " AS c ON r.bill_column_setting_id = c.id
        WHERE r.bill_item_id = " . $billItemId . " AND r.include IS TRUE AND r.deleted_at IS NULL AND c.deleted_at IS NULL";

        $grandTotalStatement = "SELECT COALESCE(SUM(r.grand_total), 0) FROM " . BillItemTypeReferenceTable::getInstance()->getTableName() . "
        AS r LEFT JOIN " . BillColumnSettingTable::getInstance()->getTableName() . " AS c ON r.bill_column_setting_id = c.id
        WHERE r.bill_item_id = " . $billItemId . " AND r.include IS TRUE AND r.deleted_at IS NULL AND c.deleted_at IS NULL";

        $grandTotalAfterMarkupStatement = "SELECT COALESCE(SUM(r.grand_total_after_markup), 0) FROM " . BillItemTypeReferenceTable::getInstance()->getTableName() . "
        AS r LEFT JOIN " . BillColumnSettingTable::getInstance()->getTableName() . " AS c ON r.bill_column_setting_id = c.id
        WHERE r.bill_item_id = " . $billItemId . " AND r.include IS TRUE AND r.deleted_at IS NULL AND c.deleted_at IS NULL";

        //update grand total
        $stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . " SET
            grand_total_quantity = (" . $grandTotalQuantityStatement . "), grand_total = (" . $grandTotalStatement . "),
            grand_total_after_markup = (" . $grandTotalAfterMarkupStatement . ") WHERE id = " . $billItemId);

        $stmt->execute();

        //update markup amount columns since any changes on total qty or original grand total will affect markup amount (base on markup percentage)
        self::updateMarkupAmountByBillItemId($billItemId);

        if ( !$disableUpdateMarkupAmount )
        {
            BillElementTable::updateMarkupAmountByElementId($billElementId);
        }
    }

    public static function updateBulkBillItemTotalColumns(Array $billItemIds, $billElementId)
    {
        end($billItemIds);
        $lastKey = key($billItemIds);

        foreach ( $billItemIds as $key => $billItemId )
        {
            $disableUpdateMarkupAmount = ( $lastKey == $key ) ? true : false;

            self::updateBillItemTotalColumns($billItemId, $billElementId, $disableUpdateMarkupAmount);
        }
    }

    public static function updateMarkupAmountByBillItemId($billItemId)
    {
        $markupPercentageFormulatedColumn = self::getFormulatedColumnByRelationIdAndColumnName($billItemId, BillItem::FORMULATED_COLUMN_MARKUP_PERCENTAGE, Doctrine_Core::HYDRATE_ARRAY);

        if ( $markupPercentageFormulatedColumn )
        {
            $markupAmount = ( $markupPercentageFormulatedColumn['final_value'] / 100 );

            self::getInstance()->getConnection()->fetchAssoc("UPDATE " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " SET
            final_value = (SELECT COALESCE(ROUND(i.grand_total * " . $markupAmount . ", 5), 0) FROM " . self::getInstance()->getTableName() . " AS i
            WHERE i.id = " . $billItemId . "
            AND i.deleted_at IS NULL),
            value = (SELECT COALESCE(ROUND(i.grand_total * " . $markupAmount . ", 5), 0) FROM " . self::getInstance()->getTableName() . " AS i
            WHERE i.id = " . $billItemId . "
            AND i.deleted_at IS NULL)
            WHERE relation_id = " . $billItemId . " AND column_name = '" . BillItem::FORMULATED_COLUMN_MARKUP_AMOUNT . "' AND deleted_at IS NULL");
        }
    }

    public static function deleteBuildUpRatesByBillItemId($billItemId)
    {
        $con = self::getInstance()->getConnection();

        $con->fetchAssoc("UPDATE " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " SET schedule_of_rate_item_formulated_column_id = NULL WHERE
        relation_id = " . $billItemId . " AND deleted_at IS NULL");

        $con->fetchAssoc("UPDATE " . BillBuildUpRateResourceTable::getInstance()->getTableName() . " SET deleted_at = NOW() WHERE
        bill_item_id = " . $billItemId . " AND deleted_at IS NULL");

        $con->fetchAssoc("UPDATE " . BillBuildUpRateResourceTradeTable::getInstance()->getTableName() . " SET deleted_at = NOW() WHERE
        bill_item_id = " . $billItemId . " AND deleted_at IS NULL");

        $formulatedColumnIds = $con->fetchAssoc("UPDATE " . BillBuildUpRateFormulatedColumnTable::getInstance()->getTableName() . " SET deleted_at = NOW() WHERE
        relation_id IN (SELECT id FROM " . BillBuildUpRateItemTable::getInstance()->getTableName() . " WHERE bill_item_id = " . $billItemId . " AND deleted_at IS NULL) RETURNING id");

        $idList = array();

        foreach ( $formulatedColumnIds as $formulatedColumnId )
        {
            if ( array_key_exists('id', $formulatedColumnId) )
            {
                $idList[] = $formulatedColumnId['id'];
            }
        }

        if ( count($idList) > 0 )
        {
            //now we can remove all edges after we've updated related nodes
            Doctrine_Query::create()
                ->delete('BillBuildUpRateEdge e')
                ->whereIn('e.node_from', $idList)
                ->execute();

            Doctrine_Query::create()
                ->delete('BillBuildUpRateEdge e')
                ->whereIn('e.node_to', $idList)
                ->execute();
        }

        Doctrine_Query::create()
            ->delete('BillBuildUpRateItem i')
            ->where('i.bill_item_id = ?', $billItemId)
            ->execute();

        Doctrine_Query::create()
            ->delete('BillBuildUpRateSummary s')
            ->where('s.bill_item_id = ?', $billItemId)
            ->execute();

        Doctrine_Query::create()->update('BillItemFormulatedColumn c')
            ->set('c.has_build_up', 'FALSE')
            ->where('c.relation_id = ?', $billItemId)
            ->andWhere('c.column_name = ?', BillItem::FORMULATED_COLUMN_RATE)
            ->andWhere('deleted_at IS NULL')
            ->execute();
    }

    public static function deleteBuildUpQuantitiesByBillItemId($billItemId)
    {
        $con = self::getInstance()->getConnection();

        $con->fetchAssoc("UPDATE " . BillBuildUpQuantityFormulatedColumnTable::getInstance()->getTableName() . " SET deleted_at = NOW() WHERE
        relation_id IN (SELECT id FROM " . BillBuildUpQuantityItemTable::getInstance()->getTableName() . " WHERE bill_item_id = " . $billItemId . " AND deleted_at IS NULL)");

        Doctrine_Query::create()
            ->delete('BillBuildUpQuantityItem i')
            ->where('i.bill_item_id = ?', $billItemId)
            ->execute();

        Doctrine_Query::create()
            ->delete('BillBuildUpQuantitySummary s')
            ->where('s.bill_item_id = ?', $billItemId)
            ->execute();

        Doctrine_Query::create()
            ->delete('ScheduleOfQuantityBillItemXref x')
            ->where('x.bill_item_id = ?', $billItemId)
            ->execute();
    }

    public static function deleteBuildUpQuantityByItemIdAndColumnSettingId($billItemId, $billColumnSettingId, $type)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("UPDATE " . BillBuildUpQuantityFormulatedColumnTable::getInstance()->getTableName() . " SET deleted_at = NOW() WHERE
        relation_id IN (SELECT id FROM " . BillBuildUpQuantityItemTable::getInstance()->getTableName() . " WHERE bill_item_id = " . $billItemId . "
        AND bill_column_setting_id = " . $billColumnSettingId . " AND type = " . $type . " AND deleted_at IS NULL)");

        $stmt->execute();

        $stmt = $pdo->prepare("DELETE FROM ".BillBuildUpQuantityItemTable::getInstance()->getTableName()." WHERE
        bill_item_id = ".$billItemId." AND bill_column_setting_id = ".$billColumnSettingId." AND type = ".$type);

        $stmt->execute();

        $stmt = $pdo->prepare("DELETE FROM ".BillBuildUpQuantitySummaryTable::getInstance()->getTableName()." WHERE
        bill_item_id = ".$billItemId." AND bill_column_setting_id = ".$billColumnSettingId." AND type = ".$type);

        $stmt->execute();

        $stmt = $pdo->prepare("DELETE FROM ".ScheduleOfQuantityBillItemXrefTable::getInstance()->getTableName()." WHERE
        bill_item_id = ".$billItemId." AND bill_column_setting_id = ".$billColumnSettingId." AND type = ".$type);

        $stmt->execute();
    }

    public static function importBQItems($targetItemId, BillElement $billElement, Array $BQItemIds, $withRate = false, $currentBQAddendumId)
    {
        if ( count($BQItemIds) > 0 && array_search("", $BQItemIds) === false )
        {
            $pdo = self::getInstance()->getConnection()->getDbh();

            $targetItem = $targetItemId > 0 ? self::getInstance()->find($targetItemId) : false;

            $stmt = $pdo->prepare('SELECT c.id, c.description, c.type, c.uom_id, c.level FROM
            ' . BQItemTable::getInstance()->getTableName() . ' AS c
            LEFT JOIN ' . BQItemTable::getInstance()->getTableName() . ' AS r ON c.root_id = r.id
            WHERE c.id IN (' . implode(",", $BQItemIds) . ') AND c.deleted_at IS NULL AND r.deleted_at IS NULL
            ORDER BY r.priority, c.lft, c.level ASC');

            $stmt->execute();

            $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

            if ( !$targetItem )
            {
                /* If No Target Item Specify We Get First Root Item as target Item */
                $rootItem = DoctrineQuery::create()->select('i.id')
                    ->from('BillItem i')
                    ->where('i.element_id = ?', $billElement->id)
                    ->andWhere('i.root_id = i.id')
                    ->andWhere('i.project_revision_deleted_at IS NULL')
                    ->limit(1)
                    ->addOrderBy('i.priority ASC')
                    ->fetchOne();

                /*
                 * we get target item (assumed root) priority first because later we will increment the priority
                 * when we are creating root items.
                 */
                $priority = $rootItem ? $rootItem->priority : 0;
            }
            else
            {
                $record = DoctrineQuery::create()->select('i.priority')
                    ->from('BillItem i')
                    ->where('i.element_id = ?', $billElement->id)
                    ->andWhere('i.root_id = i.id')
                    ->andWhere('i.id = ? ', $targetItem->id)
                    ->andWhere('i.project_revision_deleted_at IS NULL')
                    ->limit(1)
                    ->addOrderBy('i.priority ASC')
                    ->fetchOne();

                $priority = $record ? $record->priority + 1 : 0;
            }

            $trees = array();

            if ( $items and !empty( $items ) )
            {
                // Node Stack. Used to help building the hierarchy
                $stack = array();

                foreach ( $items as $item )
                {
                    $item['element_id']          = $billElement->id;
                    $item['project_revision_id'] = $currentBQAddendumId;
                    $item['bq_library_item_id']  = $item['id'];
                    $item['__children']          = array();

                    // Number of stack items
                    $l = count($stack);

                    // Check if we're dealing with different levels
                    while ($l > 0 && $stack[$l - 1]['level'] >= $item['level'])
                    {
                        array_pop($stack);
                        $l --;
                    }

                    // Stack is empty (we are inspecting the root)
                    if ( $l == 0 )
                    {
                        // Assigning the root child
                        $i         = count($trees);
                        $trees[$i] = $item;
                        $stack[]   = &$trees[$i];
                    }
                    else
                    {
                        // Add child to parent
                        $i                               = count($stack[$l - 1]['__children']);
                        $stack[$l - 1]['__children'][$i] = $item;
                        $stack[]                         = &$stack[$l - 1]['__children'][$i];
                    }
                }

                $firstLevelData        = array();
                $shiftExistingRLValues = false;

                foreach ( $trees as $key => $tree )
                {
                    if ( !$targetItem )
                    {
                        BillItemTable::updateRootPriority($priority, $billElement->id);

                        $trees[$key]['priority'] = $priority;
                        $trees[$key]['root_id']  = 0;
                        $trees[$key]['lft']      = 1;
                        $trees[$key]['rgt']      = 2;
                        $trees[$key]['level']    = 0;

                        $priority += 1;
                    }
                    else if ( $targetItem->type == BillItem::TYPE_HEADER || $targetItem->type == BillItem::TYPE_HEADER_N )
                    {
                        if ( $key == 0 )
                        {
                            $lft = $targetItem->lft + 1;
                        }
                        else
                        {
                            $__childrenCount = 0;
                            array_walk_recursive($trees[$key - 1]['__children'], function ($v, $k) use (&$__childrenCount)
                            {
                                if ( $k == "id" )
                                {
                                    $__childrenCount ++;
                                }
                            });

                            $lft = $__childrenCount * 2 + $trees[$key - 1]['rgt'] + 1;
                        }

                        $trees[$key]['priority'] = $targetItem->priority;
                        $trees[$key]['root_id']  = $targetItem->root_id;
                        $trees[$key]['lft']      = $lft;
                        $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                        $trees[$key]['level']    = $targetItem->level + 1;

                        $shiftExistingRLValues = true;

                    }
                    else if ( $targetItem->node->isRoot() && ( $targetItem->type != BillItem::TYPE_HEADER || $targetItem->type != BillItem::TYPE_HEADER_N ) )
                    {
                        //Update Priority
                        $targetItem->updateRootPriority($priority);

                        $trees[$key]['priority'] = $priority;
                        $trees[$key]['root_id']  = 0;
                        $trees[$key]['lft']      = 1;
                        $trees[$key]['rgt']      = 2;
                        $trees[$key]['level']    = 0;

                        $priority += 1;
                    }
                    else
                    {
                        if ( $key == 0 )
                        {
                            $lft = $targetItem->rgt + 1;
                        }
                        else
                        {
                            $__childrenCount = 0;
                            array_walk_recursive($trees[$key - 1]['__children'], function ($v, $k) use (&$__childrenCount)
                            {
                                if ( $k == "id" )
                                {
                                    $__childrenCount ++;
                                }
                            });

                            $lft = $__childrenCount * 2 + $trees[$key - 1]['rgt'] + 1;
                        }

                        $trees[$key]['priority'] = $targetItem->priority;
                        $trees[$key]['root_id']  = $targetItem->root_id;
                        $trees[$key]['lft']      = $lft;
                        $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                        $trees[$key]['level']    = $targetItem->level;

                        $shiftExistingRLValues = true;
                    }

                    $uomId = $tree['uom_id'] > 0 ? $tree['uom_id'] : 'NULL';

                    $firstLevelData[] = "(
                        '" . pg_escape_string($tree['description']) . "',
                        " . $tree['type'] . ",
                        " . $uomId . ",
                        " . $tree['element_id'] . ",
                        " . $currentBQAddendumId . ",
                        " . $tree['bq_library_item_id'] . ",
                        " . $trees[$key]['priority'] . ",
                        " . $trees[$key]['lft'] . ",
                        " . $trees[$key]['rgt'] . ",
                        " . $trees[$key]['level'] . ",
                        NOW(),
                        NOW()
                    )";

                    unset( $tree );
                }

                try
                {
                    $pdo->beginTransaction();

                    $stmt = $pdo->prepare("INSERT INTO " . self::getInstance()->getTableName() . " (description, type, uom_id, element_id, project_revision_id, bq_library_item_id, priority, lft, rgt, level, created_at, updated_at) VALUES " . implode(",", $firstLevelData) . " RETURNING id, bq_library_item_id, type");
                    $stmt->execute();

                    $returnIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                    $rootIds   = array();
                    $rgtValues = array();

                    $hasChildrenToInsert = false;

                    foreach ( $returnIds as $key => $returnId )
                    {
                        $itemCount = 1;

                        $rootId = $trees[$key]['root_id'] > 0 ? $trees[$key]['root_id'] : $returnId['id'];

                        $rootIds[] = "WHEN " . $returnId['id'] . " THEN " . $rootId;

                        $firstLevelNodeRightVal = $trees[$key]['rgt'];

                        if ( count($trees[$key]['__children']) > 0 )
                        {
                            list( $firstLevelNodeRightVal, $itemCount ) = self::loadNestedSetData($trees[$key]['__children'], $trees[$key], $rootId, $firstLevelNodeRightVal, $itemCount, $currentBQAddendumId, BillItem::TYPE_IMPORT_LIBRARY);

                            $hasChildrenToInsert = true;
                        }

                        $rgtValues[] = "WHEN " . $returnId['id'] . " THEN " . $firstLevelNodeRightVal;

                        /*
                        * If items were inserted at the middle of tree then we need to update the left and right values for the existing items
                        */
                        if ( $shiftExistingRLValues && $targetItem )
                        {
                            $delta = $itemCount * 2;
                            //shift all existing siblings
                            $stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . " SET lft = (" . $delta . " + lft), rgt = (" . $delta . " + rgt) WHERE lft > " . $targetItem->lft . " AND root_id = " . $targetItem->root_id . " AND element_id = " . $billElement->id . " AND deleted_at IS NULL AND project_revision_deleted_at IS NULL");
                            $stmt->execute();

                            if ( $targetItem->type == BillItem::TYPE_HEADER || $targetItem->type == BillItem::TYPE_HEADER_N )
                            {
                                $lftSign = "<=";
                                $rgtSign = ">=";
                            }
                            else
                            {
                                $lftSign = "<";
                                $rgtSign = ">";
                            }

                            //update ancestors right values since the family is getting bigger!
                            $stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . " SET rgt = (" . $delta . " + rgt) WHERE lft " . $lftSign . " " . $targetItem->lft . " AND rgt " . $rgtSign . " " . $targetItem->rgt . " AND root_id = " . $targetItem->root_id . " AND element_id = " . $billElement->id . " AND deleted_at IS NULL AND project_revision_deleted_at IS NULL");
                            $stmt->execute();
                        }

                        if ( $withRate and $returnId['type'] != BillItem::TYPE_HEADER and $returnId['type'] != BillItem::TYPE_NOID )
                        {
                            self::copyBuildUpRatesFromBQItem($returnId['id'], $returnId['bq_library_item_id']);
                            self::copyRateFromBQItem($returnId['id'], $returnId['bq_library_item_id']);
                        }
                    }

                    $stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . " SET root_id = CASE id " . implode(" ", $rootIds) . " END, rgt = CASE id " . implode(" ", $rgtValues) . " END WHERE root_id IS NULL AND element_id = " . $billElement->id . " AND deleted_at IS NULL AND project_revision_deleted_at IS NULL");
                    $stmt->execute();

                    if ( $hasChildrenToInsert )
                    {
                        $stmt = $pdo->prepare("INSERT INTO " . self::getInstance()->getTableName() . " (description, type, uom_id, element_id, project_revision_id, bq_library_item_id, root_id, priority, lft, rgt, level, created_at, updated_at) VALUES " . implode(",", self::getInstance()->importedBillItemsChildren) . " RETURNING id, bq_library_item_id, type");
                        $stmt->execute();

                        if ( $withRate )
                        {
                            $returnChildrenIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                            foreach ( $returnChildrenIds as $returnChildrenId )
                            {
                                if ( $returnChildrenId['type'] != BillItem::TYPE_HEADER and $returnChildrenId['type'] != BillItem::TYPE_NOID )
                                {
                                    self::copyBuildUpRatesFromBQItem($returnChildrenId['id'], $returnChildrenId['bq_library_item_id']);
                                    self::copyRateFromBQItem($returnChildrenId['id'], $returnChildrenId['bq_library_item_id']);
                                }

                                unset( $returnChildrenId );
                            }

                            unset( $returnChildrenIds );
                        }
                    }

                    $pdo->commit();
                }
                catch (PDOException $e)
                {
                    $pdo->rollBack();
                    throw $e;
                }
            }

            unset( $trees, $families, self::getInstance()->importedBillItemsChildren );
        }
    }

    public static function loadNestedSetData(Array $nestedSetData, Array $parent, $rootId, $parentRgtVal, $itemCount, $currentBQAddendumId = 0, $importType)
    {
        foreach ( $nestedSetData as $nestedSet )
        {
            unset( $nestedSet['id'] );

            /*
             * Since this will only be called when the node (parent) has children under it so we just add
             * all nodes in nested set as children for the parent node
             */
            $nestedSet['lft']   = $parentRgtVal;
            $nestedSet['rgt']   = $nestedSet['lft'] + 1;
            $nestedSet['level'] = $parent['level'] + 1;

            $parentRgtVal = $nestedSet['rgt'];

            $nestedSet['priority'] = $parent['priority'];

            $itemCount += 1;

            if ( array_key_exists('__children', $nestedSet) and !empty( $nestedSet['__children'] ) )
            {
                list( $parentRgtVal, $itemCount ) = self::loadNestedSetData($nestedSet['__children'], $nestedSet, $rootId, $parentRgtVal, $itemCount, $currentBQAddendumId, $importType);

                $nestedSet['rgt'] = $parentRgtVal;
            }

            $parentRgtVal += 1;

            $uomId = $nestedSet['uom_id'] > 0 ? $nestedSet['uom_id'] : 'NULL';

            $originItemId = $importType == BillItem::TYPE_IMPORT_LIBRARY ? $nestedSet['bq_library_item_id'] : $nestedSet['bill_import_item_id'];

            self::getInstance()->importedBillItemsChildren[] = "(
                '" . pg_escape_string($nestedSet['description']) . "',
                " . $nestedSet['type'] . ",
                " . $uomId . ",
                " . $nestedSet['element_id'] . ",
                " . $currentBQAddendumId . ",
                " . $originItemId . ",
                " . $rootId . ",
                " . $nestedSet['priority'] . ",
                " . $nestedSet['lft'] . ",
                " . $nestedSet['rgt'] . ",
                " . $nestedSet['level'] . ",
                NOW(),
                NOW()
            )";
        }

        return array( $parentRgtVal, $itemCount );
    }

    public static function importBillItems($targetItemId, BillElement $billElement, Array $billItemIds, $withRate = false, $currentBQAddendumId)
    {
        if ( count($billItemIds) > 0 && array_search("", $billItemIds) === false )
        {
            $pdo = self::getInstance()->getConnection()->getDbh();

            $targetItem = $targetItemId > 0 ? self::getInstance()->find($targetItemId) : false;

            $stmt = $pdo->prepare("SELECT i.id, i.description, i.type, i.uom_id, i.level FROM " . self::getInstance()->getTableName() . " i
            WHERE i.id IN (" . implode(",", $billItemIds) . ") ORDER BY i.priority, i.lft, i.level ASC");

            $stmt->execute();

            $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

            if ( !$targetItem )
            {
                /* If No Target Item Specify We Get First Root Item as target Item */
                $rootItem = DoctrineQuery::create()->select('i.id')
                    ->from('BillItem i')
                    ->where('i.element_id = ?', $billElement->id)
                    ->andWhere('i.root_id = i.id')
                    ->andWhere('i.project_revision_deleted_at IS NULL')
                    ->limit(1)
                    ->addOrderBy('i.priority ASC')
                    ->fetchOne();
                /*
                 * we get target item (assumed root) priority first because later we will increment the priority
                 * when we are creating root items.
                 */
                $priority = $rootItem ? $rootItem->priority : 0;
            }
            else
            {
                $record = DoctrineQuery::create()->select('i.priority')
                    ->from('BillItem i')
                    ->where('i.element_id = ?', $billElement->id)
                    ->andWhere('i.root_id = i.id')
                    ->andWhere('i.id = ? ', $targetItem->id)
                    ->andWhere('i.project_revision_deleted_at IS NULL')
                    ->limit(1)
                    ->addOrderBy('i.priority ASC')
                    ->fetchOne();

                $priority = $record ? $record->priority + 1 : 0;
            }

            $trees = array();

            if ( $items and !empty( $items ) )
            {
                // Node Stack. Used to help building the hierarchy
                $stack = array();

                foreach ( $items as $item )
                {
                    $item['element_id']          = $billElement->id;
                    $item['project_revision_id'] = $currentBQAddendumId;
                    $item['bill_import_item_id'] = $item['id'];
                    $item['__children']          = array();

                    // Number of stack items
                    $l = count($stack);

                    // Check if we're dealing with different levels
                    while ($l > 0 && $stack[$l - 1]['level'] >= $item['level'])
                    {
                        array_pop($stack);
                        $l --;
                    }

                    // Stack is empty (we are inspecting the root)
                    if ( $l == 0 )
                    {
                        // Assigning the root child
                        $i         = count($trees);
                        $trees[$i] = $item;
                        $stack[]   = &$trees[$i];
                    }
                    else
                    {
                        // Add child to parent
                        $i                               = count($stack[$l - 1]['__children']);
                        $stack[$l - 1]['__children'][$i] = $item;
                        $stack[]                         = &$stack[$l - 1]['__children'][$i];
                    }
                }
            }

            $firstLevelData        = array();
            $shiftExistingRLValues = false;

            foreach ( $trees as $key => $tree )
            {
                if ( !$targetItem )
                {
                    BillItemTable::updateRootPriority($priority, $billElement->id);

                    $trees[$key]['priority'] = $priority;
                    $trees[$key]['root_id']  = 0;
                    $trees[$key]['lft']      = 1;
                    $trees[$key]['rgt']      = 2;
                    $trees[$key]['level']    = 0;

                    $priority += 1;
                }
                else if ( $targetItem->type == BillItem::TYPE_HEADER || $targetItem->type == BillItem::TYPE_HEADER_N )
                {
                    if ( $key == 0 )
                    {
                        $lft = $targetItem->lft + 1;
                    }
                    else
                    {
                        $__childrenCount = 0;
                        array_walk_recursive($trees[$key - 1]['__children'], function ($v, $k) use (&$__childrenCount)
                        {
                            if ( $k == "id" )
                            {
                                $__childrenCount ++;
                            }
                        });

                        $lft = $__childrenCount * 2 + $trees[$key - 1]['rgt'] + 1;
                    }

                    $trees[$key]['priority'] = $targetItem->priority;
                    $trees[$key]['root_id']  = $targetItem->root_id;
                    $trees[$key]['lft']      = $lft;
                    $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                    $trees[$key]['level']    = $targetItem->level + 1;

                    $shiftExistingRLValues = true;

                }
                else if ( $targetItem->node->isRoot() && ( $targetItem->type != BillItem::TYPE_HEADER || $targetItem->type != BillItem::TYPE_HEADER_N ) )
                {
                    //Update Priority
                    $targetItem->updateRootPriority($priority);

                    $trees[$key]['priority'] = $priority;
                    $trees[$key]['root_id']  = 0;
                    $trees[$key]['lft']      = 1;
                    $trees[$key]['rgt']      = 2;
                    $trees[$key]['level']    = 0;

                    $priority += 1;
                }
                else
                {
                    if ( $key == 0 )
                    {
                        $lft = $targetItem->rgt + 1;
                    }
                    else
                    {
                        $__childrenCount = 0;
                        array_walk_recursive($trees[$key - 1]['__children'], function ($v, $k) use (&$__childrenCount)
                        {
                            if ( $k == "id" )
                            {
                                $__childrenCount ++;
                            }
                        });

                        $lft = $__childrenCount * 2 + $trees[$key - 1]['rgt'] + 1;
                    }

                    $trees[$key]['priority'] = $targetItem->priority;
                    $trees[$key]['root_id']  = $targetItem->root_id;
                    $trees[$key]['lft']      = $lft;
                    $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                    $trees[$key]['level']    = $targetItem->level;

                    $shiftExistingRLValues = true;
                }

                $uomId = $tree['uom_id'] > 0 ? $tree['uom_id'] : 'NULL';

                $firstLevelData[] = "(
                        '" . pg_escape_string($tree['description']) . "',
                        " . $tree['type'] . ",
                        " . $uomId . ",
                        " . $tree['element_id'] . ",
                        " . $currentBQAddendumId . ",
                        " . $tree['bill_import_item_id'] . ",
                        " . $trees[$key]['priority'] . ",
                        " . $trees[$key]['lft'] . ",
                        " . $trees[$key]['rgt'] . ",
                        " . $trees[$key]['level'] . ",
                        NOW(),
                        NOW()
                    )";

                unset( $tree );
            }

            try
            {
                $pdo->beginTransaction();

                $stmt = $pdo->prepare("INSERT INTO " . self::getInstance()->getTableName() . " (description, type, uom_id, element_id, project_revision_id, bill_import_item_id, priority, lft, rgt, level, created_at, updated_at) VALUES " . implode(",", $firstLevelData) . " RETURNING id, bill_import_item_id, type");
                $stmt->execute();

                $returnIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                $rootIds   = array();
                $rgtValues = array();

                $hasChildrenToInsert = false;

                $billColumnSettings                           = $billElement->ProjectStructure->BillColumnSettings->toArray();
                $billItemTypeReferencesData                   = array();
                $billColumnSettingWithRemeasurementQtyEnabled = array();

                foreach ( $billColumnSettings as $billColumnSetting )
                {
                    if ( $billColumnSetting['remeasurement_quantity_enabled'] )
                    {
                        $billColumnSettingWithRemeasurementQtyEnabled[$billColumnSetting['id']] = $billColumnSetting['id'];
                    }
                }

                $grand_total_case_statement = null;

                if ( count($returnIds) )
                {
                    $implodedReturningIds = implode(',', Utilities::arrayValueRecursive('id', $returnIds));
                }

                foreach ( $returnIds as $key => $returnId )
                {
                    $itemCount = 1;

                    $rootId = $trees[$key]['root_id'] > 0 ? $trees[$key]['root_id'] : $returnId['id'];

                    $rootIds[] = "WHEN " . $returnId['id'] . " THEN " . $rootId;

                    $firstLevelNodeRightVal = $trees[$key]['rgt'];

                    if ( count($trees[$key]['__children']) > 0 )
                    {
                        list( $firstLevelNodeRightVal, $itemCount ) = self::loadNestedSetData($trees[$key]['__children'], $trees[$key], $rootId, $firstLevelNodeRightVal, $itemCount, $currentBQAddendumId, BillItem::TYPE_IMPORT_PROJECT);

                        $hasChildrenToInsert = true;
                    }

                    $rgtValues[] = "WHEN " . $returnId['id'] . " THEN " . $firstLevelNodeRightVal;

                    /*
                    * If items were inserted at the middle of tree then we need to update the left and right values for the existing items
                    */
                    if ( $shiftExistingRLValues && $targetItem )
                    {
                        $delta = $itemCount * 2;
                        //shift all existing siblings
                        $stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . " SET lft = (" . $delta . " + lft), rgt = (" . $delta . " + rgt) WHERE lft > " . $targetItem->lft . " AND root_id = " . $targetItem->root_id . " AND element_id = " . $billElement->id . " AND deleted_at IS NULL AND project_revision_deleted_at IS NULL");
                        $stmt->execute();

                        if ( $targetItem->type == BillItem::TYPE_HEADER || $targetItem->type == BillItem::TYPE_HEADER_N )
                        {
                            $lftSign = "<=";
                            $rgtSign = ">=";
                        }
                        else
                        {
                            $lftSign = "<";
                            $rgtSign = ">";
                        }

                        //update ancestors right values since the family is getting bigger!
                        $stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . " SET rgt = (" . $delta . " + rgt) WHERE lft " . $lftSign . " " . $targetItem->lft . " AND rgt " . $rgtSign . " " . $targetItem->rgt . " AND root_id = " . $targetItem->root_id . " AND element_id = " . $billElement->id . " AND deleted_at IS NULL AND project_revision_deleted_at IS NULL");
                        $stmt->execute();
                    }

                    if ( $withRate and $returnId['type'] != BillItem::TYPE_HEADER and $returnId['type'] != BillItem::TYPE_HEADER_N and
                        $returnId['type'] != BillItem::TYPE_NOID and $returnId['type'] != BillItem::TYPE_ITEM_LUMP_SUM and
                        $returnId['type'] != BillItem::TYPE_ITEM_LUMP_SUM_EXCLUDE and $returnId['type'] != BillItem::TYPE_ITEM_LUMP_SUM_PERCENT
                    )
                    {
                        switch ($returnId['type'])
                        {
                            case BillItem::TYPE_ITEM_PC_RATE:
                                self::copyPrimeCostRateFromBillItem($returnId['id'], $returnId['bill_import_item_id']);
                                break;
                            default:
                                self::copyBuildUpRatesFromBillItem($returnId['id'], $returnId['bill_import_item_id']);
                        }

                        self::copyRateFromBillItem($returnId['id'], $returnId['bill_import_item_id']);
                    }

                    /*
                    * Create billItemTypeReference since we need to set default quantity to 1
                    */
                    if ( $returnId['type'] == BillItem::TYPE_ITEM_LUMP_SUM or $returnId['type'] == BillItem::TYPE_ITEM_LUMP_SUM_EXCLUDE or $returnId['type'] == BillItem::TYPE_ITEM_LUMP_SUM_PERCENT )
                    {
                        $grand_total_quantity = 0;

                        foreach ( $billColumnSettings as $billColumnSetting )
                        {
                            $billItemTypeReferencesData[] = "(" . $returnId['id'] . ", " . $billColumnSetting['id'] . ", 0, " . $billColumnSetting['quantity'] . ", NOW(), NOW())";

                            $grand_total_quantity += $billColumnSetting['quantity'];

                            unset( $billColumnSetting );
                        }

                        if ( $grand_total_quantity > 0 )
                        {
                            $grand_total_case_statement .= " WHEN " . $returnId['id'] . " THEN (" . $grand_total_quantity . ")";
                        }
                    }
                }

                if ( $grand_total_case_statement != null )
                {
                    $stmt = $pdo->prepare("UPDATE " . BillItemTable::getInstance()->getTableName() . "
                            SET grand_total_quantity = (CASE id" . $grand_total_case_statement . " END)
                            WHERE deleted_at IS NULL AND id IN (" . $implodedReturningIds . ")");

                    $stmt->execute();
                }

                $stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . " SET root_id = CASE id " . implode(" ", $rootIds) . " END, rgt = CASE id " . implode(" ", $rgtValues) . " END WHERE root_id IS NULL AND element_id = " . $billElement->id . " AND deleted_at IS NULL AND project_revision_deleted_at IS NULL");
                $stmt->execute();

                if ( $hasChildrenToInsert )
                {
                    $stmt = $pdo->prepare("INSERT INTO " . self::getInstance()->getTableName() . " (description, type, uom_id, element_id, project_revision_id, bill_import_item_id, root_id, priority, lft, rgt, level, created_at, updated_at) VALUES " . implode(",", self::getInstance()->importedBillItemsChildren) . " RETURNING id, bill_import_item_id, type");
                    $stmt->execute();

                    $returnChildrenIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                    $grand_total_case_statement = null;

                    if ( count($returnChildrenIds) )
                    {
                        $implodedReturningIds = implode(',', Utilities::arrayValueRecursive('id', $returnChildrenIds));
                    }

                    foreach ( $returnChildrenIds as $returnChildrenId )
                    {
                        if ( $withRate and $returnChildrenId['type'] != BillItem::TYPE_HEADER and $returnChildrenId['type'] != BillItem::TYPE_HEADER_N and
                            $returnChildrenId['type'] != BillItem::TYPE_NOID and $returnChildrenId['type'] != BillItem::TYPE_ITEM_LUMP_SUM and
                            $returnChildrenId['type'] != BillItem::TYPE_ITEM_LUMP_SUM_EXCLUDE and $returnChildrenId['type'] != BillItem::TYPE_ITEM_LUMP_SUM_PERCENT
                        )
                        {
                            switch ($returnChildrenId['type'])
                            {
                                case BillItem::TYPE_ITEM_PC_RATE:
                                    self::copyPrimeCostRateFromBillItem($returnChildrenId['id'], $returnChildrenId['bill_import_item_id']);
                                    break;
                                default:
                                    self::copyBuildUpRatesFromBillItem($returnChildrenId['id'], $returnChildrenId['bill_import_item_id']);
                            }

                            self::copyRateFromBillItem($returnChildrenId['id'], $returnChildrenId['bill_import_item_id']);
                        }

                        /*
                        * Create billItemTypeReference since we need to set default quantity to 1
                        */
                        if ( $returnChildrenId['type'] == BillItem::TYPE_ITEM_LUMP_SUM or $returnChildrenId['type'] == BillItem::TYPE_ITEM_LUMP_SUM_EXCLUDE or $returnChildrenId['type'] == BillItem::TYPE_ITEM_LUMP_SUM_PERCENT )
                        {
                            $grand_total_quantity = 0;

                            foreach ( $billColumnSettings as $billColumnSetting )
                            {
                                $billItemTypeReferencesData[] = "(" . $returnChildrenId['id'] . ", " . $billColumnSetting['id'] . ", 0, " . $billColumnSetting['quantity'] . ", NOW(), NOW())";

                                $grand_total_quantity += $billColumnSetting['quantity'];

                                unset( $billColumnSetting );
                            }

                            if ( $grand_total_quantity > 0 )
                            {
                                $grand_total_case_statement .= " WHEN " . $returnChildrenId['id'] . " THEN (" . $grand_total_quantity . ")";
                            }
                        }

                        unset( $returnChildrenId );
                    }

                    if ( $grand_total_case_statement != null )
                    {
                        $stmt = $pdo->prepare("UPDATE " . BillItemTable::getInstance()->getTableName() . "
                                SET grand_total_quantity = (CASE id" . $grand_total_case_statement . " END)
                                WHERE deleted_at IS NULL AND id IN(" . $implodedReturningIds . ")");

                        $stmt->execute();
                    }

                    unset( $returnChildrenIds );
                }

                if ( count($billItemTypeReferencesData) > 0 )
                {
                    $stmt = $pdo->prepare("INSERT INTO " . BillItemTypeReferenceTable::getInstance()->getTableName() . " (bill_item_id, bill_column_setting_id, quantity_per_unit_difference, total_quantity, created_at, updated_at)
                    VALUES " . implode(",", $billItemTypeReferencesData) . " RETURNING id, bill_column_setting_id");

                    $stmt->execute();

                    $returnedBillItemTypeReferences = $stmt->fetchAll(PDO::FETCH_ASSOC);

                    $billItemTypeReferenceFormulatedColumns                 = array();
                    $billItemTypeReferenceRemeasurementQtyFormulatedColumns = array();

                    foreach ( $returnedBillItemTypeReferences as $billItemTypeReference )
                    {
                        $billItemTypeReferenceFormulatedColumns[] = "(" . $billItemTypeReference['id'] . ", '" . BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT . "', '1', 1, NOW(), NOW())";

                        if ( count($billColumnSettingWithRemeasurementQtyEnabled) > 0 and array_key_exists($billItemTypeReference['bill_column_setting_id'], $billColumnSettingWithRemeasurementQtyEnabled) )
                        {
                            $billItemTypeReferenceRemeasurementQtyFormulatedColumns[] = "(" . $billItemTypeReference['id'] . ", '" . BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT . "', '1', 1, NOW(), NOW())";
                        }
                    }

                    if ( count($billItemTypeReferenceFormulatedColumns) > 0 )
                    {
                        $stmt = $pdo->prepare("INSERT INTO " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " (relation_id, column_name, value, final_value, created_at, updated_at)
                        VALUES " . implode(",", $billItemTypeReferenceFormulatedColumns) . " RETURNING id");

                        $stmt->execute();
                    }

                    if ( count($billItemTypeReferenceRemeasurementQtyFormulatedColumns) > 0 )
                    {
                        $stmt = $pdo->prepare("INSERT INTO " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " (relation_id, column_name, value, final_value, created_at, updated_at)
                        VALUES " . implode(",", $billItemTypeReferenceRemeasurementQtyFormulatedColumns) . " RETURNING id");

                        $stmt->execute();
                    }
                }

                $pdo->commit();
            }
            catch (PDOException $e)
            {
                $pdo->rollBack();
                throw $e;
            }

            unset( $trees, $families, $billItemTypeReferencesData, $billItemTypeReferenceFormulatedColumns, $billItemTypeReferenceRemeasurementQtyFormulatedColumns, self::getInstance()->importedBillItemsChildren );
        }
    }

    public static function copyBuildUpRatesFromBQItem($billItemId, $bqItemId)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT DISTINCT i.id, i.bq_item_id, i.build_up_rate_resource_id, i.resource_trade_library_id, i.resource_item_library_id, i.description, i.total, i.line_total, i.uom_id, i.priority FROM " . BQLibraryBuildUpRateItemTable::getInstance()->getTableName() . " i WHERE i.bq_item_id = " . $bqItemId . " AND i.deleted_at IS NULL ORDER BY i.priority ASC");

        $stmt->execute();

        $BQLibraryBuildUpRateItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if ( $BQLibraryBuildUpRateItems )
        {
            $formulatedColumnConstants        = Utilities::getAllFormulatedColumnConstants('BQLibraryBuildUpRateItem');
            $userId                           = sfContext::getInstance()->getUser()->getAttribute('user_id', null, 'sfGuardSecurityUser');
            $buildUpRateItemsData             = array();
            $buildUpRateFormulatedColumnsData = array();

            foreach ( $BQLibraryBuildUpRateItems as $buildUpItem )
            {
                $buildUpRateResourceId  = $buildUpItem['build_up_rate_resource_id'];
                $resourceTradeLibraryId = $buildUpItem['resource_trade_library_id'];

                // find existing BillBuildUpRateResourceTrade, if got then use current ID
                // if not then create new one
                $billBuildUpRateResource = BillBuildUpRateResourceTable::getExistingRecordFromBQLibraryBuildUpRateResource($billItemId, $buildUpRateResourceId);
                $billBuildUpRateTrade    = BillBuildUpRateResourceTradeTable::getExistingRecordFromResourceTrade($billItemId, $billBuildUpRateResource['id'], $resourceTradeLibraryId);

                $resourceItemId             = $buildUpItem['resource_item_library_id'] > 0 ? $buildUpItem['resource_item_library_id'] : 'NULL';
                $uomId                      = $buildUpItem['uom_id'] > 0 ? $buildUpItem['uom_id'] : 'NULL';
                $buildUpRateResourceTradeId = is_array($billBuildUpRateTrade) ? $billBuildUpRateTrade['id'] : 'NULL';

                $buildUpRateItemsData[] = "(" . $billItemId . ", " . $billBuildUpRateResource['id'] . ", " . $buildUpRateResourceTradeId . ", " . $resourceItemId . ", '" . pg_escape_string($buildUpItem['description']) . "', " . $buildUpItem['total'] . ", " . $buildUpItem['line_total'] . ", " . $uomId . ", " . $buildUpItem['priority'] . ", NOW(), NOW(), " . $userId . ", " . $userId . ")";

                $buildUpRateFormulatedColumns = array();

                foreach ( $formulatedColumnConstants as $constant )
                {
                    $formulatedColumn = BQLibraryBuildUpRateItemTable::getFormulatedColumnByRelationIdAndColumnName($buildUpItem['id'], $constant, Doctrine_Core::HYDRATE_ARRAY);

                    if ( $formulatedColumn )
                    {
                        $buildUpRateFormulatedColumns[] = $formulatedColumn;
                    }
                }

                $buildUpRateFormulatedColumnsData[] = $buildUpRateFormulatedColumns;
            }

            if ( count($buildUpRateItemsData) > 0 )
            {
                $stmt = $pdo->prepare("INSERT INTO " . BillBuildUpRateItemTable::getInstance()->getTableName() . " (bill_item_id, build_up_rate_resource_id, build_up_rate_resource_trade_id, resource_item_library_id, description, total, line_total, uom_id, priority, created_at, updated_at, created_by, updated_by) VALUES " . implode(",", $buildUpRateItemsData) . " RETURNING id");
                $stmt->execute();

                $returnIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                $formulatedColumnsData = array();

                foreach ( $returnIds as $key => $returnId )
                {
                    if ( array_key_exists($key, $buildUpRateFormulatedColumnsData) )
                    {
                        foreach ( $buildUpRateFormulatedColumnsData[$key] as $formulatedColumn )
                        {
                            $linked                  = $formulatedColumn['linked'] ? 'TRUE' : 'FALSE';
                            $finalValue              = strlen($formulatedColumn['final_value']) > 0 && !is_null($formulatedColumn['final_value']) ? $formulatedColumn['final_value'] : 0;
                            $formulatedColumnsData[] = "(" . $returnId['id'] . ", " . $linked . ", '" . pg_escape_string($formulatedColumn['column_name']) . "', '" . pg_escape_string($formulatedColumn['value']) . "', " . $finalValue . ", NOW(), NOW(), " . $userId . ", " . $userId . ")";
                        }

                        unset( $buildUpRateFormulatedColumnsData[$key] );
                    }
                }

                if ( count($formulatedColumnsData) > 0 )
                {
                    $stmt = $pdo->prepare("INSERT INTO " . BillBuildUpRateFormulatedColumnTable::getInstance()->getTableName() . " (relation_id, linked, column_name, value, final_value, created_at, updated_at, created_by, updated_by) VALUES " . implode(",", $formulatedColumnsData));
                    $stmt->execute();
                }
            }

            unset( $buildUpRateItemsData, $returnIds, $buildUpRateFormulatedColumnsData, $formulatedColumnsData );

            $bqLibraryBuildUpSummary = DoctrineQuery::create()->select('s.total_cost, s.markup, s.final_cost, s.apply_conversion_factor, s.conversion_factor_amount, s.conversion_factor_uom_id, s.conversion_factor_operator')
                ->from('BQLibraryBuildUpRateSummary s')
                ->where('s.bq_item_id = ?', $bqItemId)
                ->limit(1)
                ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
                ->fetchOne();

            if ( $bqLibraryBuildUpSummary )
            {
                $applyConversionFactor = $bqLibraryBuildUpSummary['apply_conversion_factor'] ? 1 : 0;
                $conversionFactorUomId = $bqLibraryBuildUpSummary['conversion_factor_uom_id'] > 0 ? $bqLibraryBuildUpSummary['conversion_factor_uom_id'] : null;
                $roundingType          = BillSetting::ROUNDING_TYPE_DISABLED; //later to change to default setting

                $billBuildUpSummaryQuery = DoctrineQuery::create()->select('s.id')
                    ->from('BillBuildUpRateSummary s')
                    ->where('s.bill_item_id = ?', $billItemId)
                    ->limit(1)
                    ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY);

                if ( $bqLibraryBuildUpSummary['final_cost'] > 0 )
                {
                    switch ($roundingType)
                    {
                        case BillBuildUpRateSummary::ROUNDING_TYPE_UPWARD:
                            $bqLibraryBuildUpSummary['final_cost'] = ceil($bqLibraryBuildUpSummary['final_cost']);
                            break;
                        case BillBuildUpRateSummary::ROUNDING_TYPE_DOWNWARD:
                            $bqLibraryBuildUpSummary['final_cost'] = floor($bqLibraryBuildUpSummary['final_cost']);
                            break;
                        case BillBuildUpRateSummary::ROUNDING_TYPE_NEAREST_WHOLE_NUMBER:
                            $bqLibraryBuildUpSummary['final_cost'] = round($bqLibraryBuildUpSummary['final_cost']);
                            break;
                        case BillBuildUpRateSummary::ROUNDING_TYPE_NEAREST_TENTH:
                            $bqLibraryBuildUpSummary['final_cost'] = round($bqLibraryBuildUpSummary['final_cost'] * 10) / 10;
                            break;
                        default:
                            $bqLibraryBuildUpSummary['final_cost'] = number_format($bqLibraryBuildUpSummary['final_cost'], 2, '.', '');
                    }
                }

                if ( $billBuildUpSummaryQuery->count() == 0 )
                {
                    $sql = "INSERT INTO " . BillBuildUpRateSummaryTable::getInstance()->getTableName() . " (bill_item_id, total_cost, markup, final_cost, apply_conversion_factor, conversion_factor_amount, conversion_factor_uom_id, conversion_factor_operator, rounding_type, created_at, updated_at, created_by, updated_by)
                    VALUES (:bill_item_id, :total_cost, :markup, :final_cost, :apply_conversion_factor, :conversion_factor_amount, :conversion_factor_uom_id, :conversion_factor_operator, :rounding_type, NOW(), NOW(), " . $userId . ", " . $userId . ")";
                }
                else
                {
                    $sql = "UPDATE " . BillBuildUpRateSummaryTable::getInstance()->getTableName() . " SET total_cost = :total_cost, markup = :markup, final_cost = :final_cost, apply_conversion_factor = :apply_conversion_factor, conversion_factor_amount = :conversion_factor_amount,
                    conversion_factor_uom_id = :conversion_factor_uom_id, conversion_factor_operator = :conversion_factor_operator, rounding_type = :rounding_type, created_at = NOW(), updated_at = NOW(), created_by = " . $userId . ", updated_by = " . $userId . " WHERE bill_item_id = :bill_item_id";
                }

                $stmt = $pdo->prepare($sql);

                $stmt->execute(array(
                    'bill_item_id'               => $billItemId,
                    'total_cost'                 => $bqLibraryBuildUpSummary['total_cost'],
                    'markup'                     => $bqLibraryBuildUpSummary['markup'],
                    'final_cost'                 => $bqLibraryBuildUpSummary['final_cost'],
                    'apply_conversion_factor'    => $applyConversionFactor,
                    'conversion_factor_amount'   => $bqLibraryBuildUpSummary['conversion_factor_amount'],
                    'conversion_factor_operator' => $bqLibraryBuildUpSummary['conversion_factor_operator'],
                    'conversion_factor_uom_id'   => $conversionFactorUomId,
                    'rounding_type'              => $roundingType
                ));
            }

            unset( $BQLibraryBuildUpRateItems );
        }
    }

    public static function copyBuildUpRatesFromBillItem($targetItemId, $billItemId)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT DISTINCT i.id, i.bill_item_id, i.build_up_rate_resource_id, i.build_up_rate_resource_trade_id, i.resource_item_library_id,
        i.description, i.total, i.line_total, i.uom_id, i.priority, t.resource_trade_library_id FROM " . BillBuildUpRateItemTable::getInstance()->getTableName() . " i
        LEFT JOIN " . BillBuildUpRateResourceTradeTable::getInstance()->getTableName() . " t ON t.id = i.build_up_rate_resource_trade_id AND t.bill_item_id = " . $billItemId . " AND t.deleted_at IS NULL
        WHERE i.bill_item_id = " . $billItemId . " AND i.deleted_at IS NULL ORDER BY i.priority ASC");

        $stmt->execute();

        $billBuildUpRateItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if ( $billBuildUpRateItems )
        {
            $formulatedColumnConstants        = Utilities::getAllFormulatedColumnConstants('BillBuildUpRateItem');
            $userId                           = sfContext::getInstance()->getUser()->getAttribute('user_id', null, 'sfGuardSecurityUser');
            $buildUpRateItemsData             = array();
            $buildUpRateFormulatedColumnsData = array();

            foreach ( $billBuildUpRateItems as $buildUpItem )
            {
                $buildUpRateResourceId  = $buildUpItem['build_up_rate_resource_id'];
                $resourceTradeLibraryId = $buildUpItem['resource_trade_library_id'];

                // find existing BillBuildUpRateResourceTrade, if got then use current ID
                // if not then create new one
                $billBuildUpRateResource = BillBuildUpRateResourceTable::getExistingRecordFromBillBuildUpRateResourceTable($targetItemId, $buildUpRateResourceId);
                $billBuildUpRateTrade    = BillBuildUpRateResourceTradeTable::getExistingRecordFromBillBuildUpRateResourceTrade($targetItemId, $billBuildUpRateResource['id'], $resourceTradeLibraryId);

                $resourceItemId             = $buildUpItem['resource_item_library_id'] > 0 ? $buildUpItem['resource_item_library_id'] : 'NULL';
                $uomId                      = $buildUpItem['uom_id'] > 0 ? $buildUpItem['uom_id'] : 'NULL';
                $buildUpRateResourceTradeId = is_array($billBuildUpRateTrade) ? $billBuildUpRateTrade['id'] : 'NULL';

                $buildUpRateItemsData[] = "(" . $targetItemId . ", " . $billBuildUpRateResource['id'] . ", " . $buildUpRateResourceTradeId . ", " . $resourceItemId . ", '" . pg_escape_string($buildUpItem['description']) . "', " . $buildUpItem['total'] . ", " . $buildUpItem['line_total'] . ", " . $uomId . ", " . $buildUpItem['priority'] . ", NOW(), NOW(), " . $userId . ", " . $userId . ")";

                $buildUpRateFormulatedColumns = array();

                foreach ( $formulatedColumnConstants as $constant )
                {
                    $formulatedColumn = BillBuildUpRateItemTable::getFormulatedColumnByRelationIdAndColumnName($buildUpItem['id'], $constant, Doctrine_Core::HYDRATE_ARRAY);

                    if ( $formulatedColumn )
                    {
                        $buildUpRateFormulatedColumns[] = $formulatedColumn;
                    }
                }

                $buildUpRateFormulatedColumnsData[] = $buildUpRateFormulatedColumns;
            }

            if ( count($buildUpRateItemsData) > 0 )
            {
                $stmt = $pdo->prepare("INSERT INTO " . BillBuildUpRateItemTable::getInstance()->getTableName() . " (bill_item_id, build_up_rate_resource_id, build_up_rate_resource_trade_id, resource_item_library_id, description, total, line_total, uom_id, priority, created_at, updated_at, created_by, updated_by) VALUES " . implode(",", $buildUpRateItemsData) . " RETURNING id");
                $stmt->execute();

                $returnIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                $formulatedColumnsData = array();

                foreach ( $returnIds as $key => $returnId )
                {
                    if ( array_key_exists($key, $buildUpRateFormulatedColumnsData) )
                    {
                        foreach ( $buildUpRateFormulatedColumnsData[$key] as $formulatedColumn )
                        {
                            $linked                  = $formulatedColumn['linked'] ? 'TRUE' : 'FALSE';
                            $finalValue              = strlen($formulatedColumn['final_value']) > 0 && !is_null($formulatedColumn['final_value']) ? $formulatedColumn['final_value'] : 0;
                            $formulatedColumnsData[] = "(" . $returnId['id'] . ", " . $linked . ", '" . pg_escape_string($formulatedColumn['column_name']) . "', '" . pg_escape_string($formulatedColumn['value']) . "', " . $finalValue . ", NOW(), NOW(), " . $userId . ", " . $userId . ")";
                        }

                        unset( $buildUpRateFormulatedColumnsData[$key] );
                    }
                }

                if ( count($formulatedColumnsData) > 0 )
                {
                    $stmt = $pdo->prepare("INSERT INTO " . BillBuildUpRateFormulatedColumnTable::getInstance()->getTableName() . " (relation_id, linked, column_name, value, final_value, created_at, updated_at, created_by, updated_by) VALUES " . implode(",", $formulatedColumnsData));
                    $stmt->execute();
                }
            }

            unset( $buildUpRateItemsData, $returnIds, $buildUpRateFormulatedColumnsData, $formulatedColumnsData );

            $billBuildUpSummary = DoctrineQuery::create()->select('s.total_cost, s.markup, s.final_cost, s.apply_conversion_factor, s.conversion_factor_amount, s.conversion_factor_uom_id, s.conversion_factor_operator')
                ->from('BillBuildUpRateSummary s')
                ->where('s.bill_item_id = ?', $billItemId)
                ->limit(1)
                ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
                ->fetchOne();

            if ( $billBuildUpSummary )
            {
                $applyConversionFactor = $billBuildUpSummary['apply_conversion_factor'] ? 1 : 0;
                $conversionFactorUomId = $billBuildUpSummary['conversion_factor_uom_id'] > 0 ? $billBuildUpSummary['conversion_factor_uom_id'] : null;
                $roundingType          = BillSetting::ROUNDING_TYPE_DISABLED; //later to change to default setting

                $targetBuildUpSummaryQuery = DoctrineQuery::create()->select('s.id')
                    ->from('BillBuildUpRateSummary s')
                    ->where('s.bill_item_id = ?', $targetItemId)
                    ->limit(1)
                    ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY);

                if ( $targetBuildUpSummaryQuery->count() == 0 )
                {
                    $sql = "INSERT INTO " . BillBuildUpRateSummaryTable::getInstance()->getTableName() . " (bill_item_id, total_cost, markup, final_cost, apply_conversion_factor, conversion_factor_amount, conversion_factor_uom_id, conversion_factor_operator, rounding_type, created_at, updated_at, created_by, updated_by)
                    VALUES (:bill_item_id, :total_cost, :markup, :final_cost, :apply_conversion_factor, :conversion_factor_amount, :conversion_factor_uom_id, :conversion_factor_operator, :rounding_type, NOW(), NOW(), " . $userId . ", " . $userId . ")";
                }
                else
                {
                    $sql = "UPDATE " . BillBuildUpRateSummaryTable::getInstance()->getTableName() . " SET total_cost = :total_cost, markup = :markup, final_cost = :final_cost, apply_conversion_factor = :apply_conversion_factor, conversion_factor_amount = :conversion_factor_amount,
                    conversion_factor_uom_id = :conversion_factor_uom_id, conversion_factor_operator = :conversion_factor_operator, rounding_type = :rounding_type, created_at = NOW(), updated_at = NOW(), created_by = " . $userId . ", updated_by = " . $userId . " WHERE bill_item_id = :bill_item_id";
                }

                $stmt = $pdo->prepare($sql);

                $stmt->execute(array(
                    'bill_item_id'               => $targetItemId,
                    'total_cost'                 => $billBuildUpSummary['total_cost'],
                    'markup'                     => $billBuildUpSummary['markup'],
                    'final_cost'                 => $billBuildUpSummary['final_cost'],
                    'apply_conversion_factor'    => $applyConversionFactor,
                    'conversion_factor_amount'   => $billBuildUpSummary['conversion_factor_amount'],
                    'conversion_factor_operator' => $billBuildUpSummary['conversion_factor_operator'],
                    'conversion_factor_uom_id'   => $conversionFactorUomId,
                    'rounding_type'              => $roundingType
                ));
            }

            unset( $billBuildUpRateItems );
        }
    }

    public static function calculateTotalForResourceAnalysis($resourceId, $resourceItemId = null, $buildUpRateItemId = null, $unsorted = false)
    {
        $pdo                  = self::getInstance()->getConnection()->getDbh();
        $buildUpRateSummaries = array();
        $result               = array();

        $sql = "SELECT bur.bill_item_id, burfc.relation_id, burfc.final_value, burfc.column_name FROM
        " . BillBuildUpRateFormulatedColumnTable::getInstance()->getTableName() . " AS burfc JOIN
        " . BillBuildUpRateItemTable::getInstance()->getTableName() . " AS bur ON burfc.relation_id = bur.id JOIN
        " . BillBuildUpRateResourceTable::getInstance()->getTableName() . " AS r ON bur.build_up_rate_resource_id = r.id
        WHERE r.resource_library_id = " . $resourceId . "
        AND burfc.column_name <> '" . BillBuildUpRateItem::FORMULATED_COLUMN_WASTAGE . "'
        AND burfc.final_value IS NOT NULL AND burfc.final_value <> 0 ";

        if ( !$unsorted )
        {
            $sql .= "AND bur.resource_item_library_id = " . $resourceItemId . " ";
        }
        else
        {
            $sql .= "AND bur.id = " . $buildUpRateItemId . " AND bur.build_up_rate_resource_trade_id IS NULL AND bur.resource_item_library_id IS NULL ";
        }

        $sql .= "AND burfc.deleted_at IS NULL AND bur.deleted_at IS NULL ORDER BY burfc.relation_id, bur.bill_item_id";

        $stmt = $pdo->prepare($sql);

        $stmt->execute();

        $billBuildUpRateFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $sql = "SELECT DISTINCT sum.bill_item_id, sum.conversion_factor_operator, sum.conversion_factor_amount FROM
        " . BillBuildUpRateItemTable::getInstance()->getTableName() . " AS bur JOIN
        " . BillBuildUpRateResourceTable::getInstance()->getTableName() . " AS r ON bur.build_up_rate_resource_id = r.id JOIN
        " . BillBuildUpRateSummaryTable::getInstance()->getTableName() . " AS sum ON r.bill_item_id = sum.bill_item_id
        WHERE r.resource_library_id = " . $resourceId . " AND sum.apply_conversion_factor IS TRUE ";

        if ( !$unsorted )
        {
            $sql .= "AND bur.resource_item_library_id = " . $resourceItemId . " ";
        }
        else
        {
            $sql .= "AND bur.id = " . $buildUpRateItemId . " AND bur.build_up_rate_resource_trade_id IS NULL AND bur.resource_item_library_id IS NULL ";
        }

        $sql .= "AND sum.deleted_at IS NULL ORDER BY sum.bill_item_id";

        $stmt = $pdo->prepare($sql);

        $stmt->execute();

        $buildUpRateSummaryRecords = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ( $buildUpRateSummaryRecords as $buildUpRateSummary )
        {
            $buildUpRateSummaries[$buildUpRateSummary['bill_item_id']] = array(
                'conversion_factor_operator' => $buildUpRateSummary['conversion_factor_operator'],
                'conversion_factor_amount'   => $buildUpRateSummary['conversion_factor_amount']
            );
        }

        $sql = "SELECT DISTINCT i.id, i.grand_total_quantity FROM
        " . BillBuildUpRateItemTable::getInstance()->getTableName() . " AS bur JOIN
        " . BillBuildUpRateResourceTable::getInstance()->getTableName() . " AS r ON bur.build_up_rate_resource_id = r.id JOIN
        " . BillItemTable::getInstance()->getTableName() . " AS i ON r.bill_item_id = i.id
        WHERE r.resource_library_id = " . $resourceId . " ";

        if ( !$unsorted )
        {
            $sql .= "AND bur.resource_item_library_id = " . $resourceItemId . " ";
        }
        else
        {
            $sql .= "AND bur.id = " . $buildUpRateItemId . " AND bur.build_up_rate_resource_trade_id IS NULL AND bur.resource_item_library_id IS NULL ";
        }

        $sql .= "AND i.grand_total_quantity IS NOT NULL AND i.grand_total_quantity <> 0 AND i.project_revision_deleted_at IS NULL AND i.deleted_at IS NULL ORDER BY i.id";

        $stmt = $pdo->prepare($sql);

        $stmt->execute();

        $billItems = $stmt->fetchAll(PDO::FETCH_COLUMN | PDO::FETCH_GROUP);

        $billBuildUpRateItems = array();

        foreach ( $billBuildUpRateFormulatedColumns as $billBuildUpRateFormulatedColumn )
        {
            $billBuildUpRateItems[$billBuildUpRateFormulatedColumn['relation_id']]['bill_item_id']                                  = $billBuildUpRateFormulatedColumn['bill_item_id'];
            $billBuildUpRateItems[$billBuildUpRateFormulatedColumn['relation_id']][$billBuildUpRateFormulatedColumn['column_name']] = $billBuildUpRateFormulatedColumn['final_value'];
        }

        unset( $billBuildUpRateFormulatedColumns );

        $totalQuantity = 0;
        $totalCost     = 0;

        foreach ( $billBuildUpRateItems as $billBuildUpRateItem )
        {
            if ( !array_key_exists($billBuildUpRateItem['bill_item_id'], $result) )
            {
                $totalQuantity = 0;
                $totalCost     = 0;

                $result[$billBuildUpRateItem['bill_item_id']] = array(
                    'total_cost'     => 0,
                    'total_quantity' => 0
                );
            }

            if ( array_key_exists(BillBuildUpRateItem::FORMULATED_COLUMN_QUANTITY, $billBuildUpRateItem) )
            {
                $quantity = $billBuildUpRateItem[BillBuildUpRateItem::FORMULATED_COLUMN_QUANTITY];
                $number   = array_key_exists(BillBuildUpRateItem::FORMULATED_COLUMN_NUMBER, $billBuildUpRateItem) ? $billBuildUpRateItem[BillBuildUpRateItem::FORMULATED_COLUMN_NUMBER] : 1;
                $constant = array_key_exists(BillBuildUpRateItem::FORMULATED_COLUMN_CONSTANT, $billBuildUpRateItem) ? $billBuildUpRateItem[BillBuildUpRateItem::FORMULATED_COLUMN_CONSTANT] : 1;
                $rate     = array_key_exists(BillBuildUpRateItem::FORMULATED_COLUMN_RATE, $billBuildUpRateItem) ? $billBuildUpRateItem[BillBuildUpRateItem::FORMULATED_COLUMN_RATE] : 0;

                $billItemQuantity = array_key_exists($billBuildUpRateItem['bill_item_id'], $billItems) ? $billItems[$billBuildUpRateItem['bill_item_id']][0] : 0;

                if ( array_key_exists($billBuildUpRateItem['bill_item_id'], $buildUpRateSummaries) )
                {
                    switch ($buildUpRateSummaries[$billBuildUpRateItem['bill_item_id']]['conversion_factor_operator'])
                    {
                        case '/':
                            if($buildUpRateSummaries[$billBuildUpRateItem['bill_item_id']]['conversion_factor_amount'] == 0)
                            {
                                $rate = 0;
                                $quantityOnly = 0;
                                break;
                            }
                            $rate         = $number * $constant * $quantity / $buildUpRateSummaries[$billBuildUpRateItem['bill_item_id']]['conversion_factor_amount'] * $rate;
                            $quantityOnly = $number * $constant * $quantity / $buildUpRateSummaries[$billBuildUpRateItem['bill_item_id']]['conversion_factor_amount'] * $billItemQuantity;
                            break;
                        case '*':
                            $rate         = $number * $constant * $quantity * $buildUpRateSummaries[$billBuildUpRateItem['bill_item_id']]['conversion_factor_amount'] * $rate;
                            $quantityOnly = $number * $constant * $quantity * $buildUpRateSummaries[$billBuildUpRateItem['bill_item_id']]['conversion_factor_amount'] * $billItemQuantity;
                            break;
                        default:
                            throw new Exception('Invalid conversion factor operator');
                    }
                }
                else
                {
                    $rate         = $number * $constant * $quantity * $rate;
                    $quantityOnly = $number * $constant * $quantity * $billItemQuantity;
                }

                $cost = number_format($rate, 2, '.', '') * $billItemQuantity;

                $totalQuantity += $quantityOnly;
                $totalCost += $cost;
            }
            else
            {
                continue;
            }

            if ( array_key_exists($billBuildUpRateItem['bill_item_id'], $result) )
            {
                $result[$billBuildUpRateItem['bill_item_id']]['total_cost'] += $totalCost;
                $result[$billBuildUpRateItem['bill_item_id']]['total_quantity'] += $totalQuantity;

                unset( $billBuildUpRateItem['bill_item_id'] );
            }
        }

        return $result;
    }

    public static function copyRateFromBQItem($billItemId, $bqItemId)
    {
        $formulatedColumn = BQItemTable::getFormulatedColumnByRelationIdAndColumnName($bqItemId, BQItem::FORMULATED_COLUMN_RATE, Doctrine_Core::HYDRATE_ARRAY);

        if ( $formulatedColumn )
        {
            $pdo = self::getInstance()->getConnection()->getDbh();

            $userId     = sfContext::getInstance()->getUser()->getAttribute('user_id', null, 'sfGuardSecurityUser');
            $hasBuildUp = $formulatedColumn['has_build_up'] ? 'TRUE' : 'FALSE';
            $finalValue = ( $formulatedColumn['final_value'] ) ? $formulatedColumn['final_value'] : 0;

            if ( $hasBuildUp == 'TRUE' && $finalValue > 0 )
            {
                $billBuildUpSummary = DoctrineQuery::create()->select('s.id, s.total_cost, s.final_cost')
                    ->from('BillBuildUpRateSummary s')
                    ->where('s.bill_item_id = ?', $billItemId)
                    ->limit(1)
                    ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
                    ->fetchOne();

                if ( $billBuildUpSummary )
                {
                    $finalValue = $billBuildUpSummary['final_cost'];
                }
                else
                {
                    $finalValue = 0;
                }
            }

            $stmt = $pdo->prepare("INSERT INTO " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " (relation_id, has_build_up, column_name, value, final_value, created_at, updated_at, created_by, updated_by)
                VALUES (" . $billItemId . ", " . $hasBuildUp . ", '" . $formulatedColumn['column_name'] . "', '" . $finalValue . "', " . $finalValue . ", NOW(), NOW(), " . $userId . ", " . $userId . ")");

            $stmt->execute();
        }
    }

    public static function copyRateFromBillItem($targetItemId, $billItemId)
    {
        $formulatedColumn = BillItemTable::getFormulatedColumnByRelationIdAndColumnName($billItemId, BillItem::FORMULATED_COLUMN_RATE, Doctrine_Core::HYDRATE_ARRAY);

        if ( $formulatedColumn )
        {
            $pdo = self::getInstance()->getConnection()->getDbh();

            $userId                           = sfContext::getInstance()->getUser()->getAttribute('user_id', null, 'sfGuardSecurityUser');
            $hasBuildUp                       = $formulatedColumn['has_build_up'] ? 'TRUE' : 'FALSE';
            $linked                           = $formulatedColumn['linked'] ? 'TRUE' : 'FALSE';
            $finalValue                       = $formulatedColumn['final_value'] ? $formulatedColumn['final_value'] : 0;
            $scheduleOfRateFormulatedColumnId = $formulatedColumn['schedule_of_rate_item_formulated_column_id'] ? $formulatedColumn['schedule_of_rate_item_formulated_column_id'] : 'NULL';

            $stmt = $pdo->prepare("INSERT INTO " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " (relation_id, linked, has_build_up, schedule_of_rate_item_formulated_column_id, column_name, value, final_value, created_at, updated_at, created_by, updated_by)
                VALUES
                (" . $targetItemId . ", " . $linked . ", " . $hasBuildUp . ", " . $scheduleOfRateFormulatedColumnId . ", '" . $formulatedColumn['column_name'] . "', '" . $finalValue . "', " . $finalValue . ", NOW(), NOW(), " . $userId . ", " . $userId . ")");

            $stmt->execute();
        }
    }

    public static function copyPrimeCostRateFromBillItem($targetItemId, $billItemId)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT supply_rate, wastage_percentage, wastage_amount, labour_for_installation, other_cost, profit_percentage, profit_amount, total
        FROM " . BillItemPrimeCostRateTable::getInstance()->getTableName() . " WHERE bill_item_id = " . $billItemId . " AND deleted_at IS NULL");

        $stmt->execute();

        $primeCostRate = $stmt->fetch(PDO::FETCH_ASSOC);

        if ( $primeCostRate )
        {
            $userId = sfContext::getInstance()->getUser()->getAttribute('user_id', null, 'sfGuardSecurityUser');

            $stmt = $pdo->prepare("INSERT INTO " . BillItemPrimeCostRateTable::getInstance()->getTableName() . " (bill_item_id, supply_rate, wastage_percentage, wastage_amount, labour_for_installation, other_cost, profit_percentage, profit_amount, total, created_at, updated_at, created_by, updated_by)
                VALUES
                (" . $targetItemId . ", " . $primeCostRate['supply_rate'] . ", " . $primeCostRate['wastage_percentage'] . ", " . $primeCostRate['wastage_amount'] . ", " . $primeCostRate['labour_for_installation'] . ", " . $primeCostRate['other_cost'] . ", " . $primeCostRate['profit_percentage'] . ", " . $primeCostRate['profit_amount'] . ", " . $primeCostRate['total'] . ", NOW(), NOW(), " . $userId . ", " . $userId . ")");


            $stmt->execute();
        }
    }

    public static function updateTypeTotalAmount($billItemId, $billColumnSettings, $markupSettingsInfo)
    {
        foreach ( $billColumnSettings as $columnSetting )
        {
            BillItemTypeReferenceTable::updateTypeTotalByBillColumnSettingAndItemId($billItemId, $columnSetting, $markupSettingsInfo);
        }
    }

    public static function getDataStructureForBillItemList(BillElement $element, ProjectStructure $bill)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $formulatedColumns                = array();
        $quantityPerUnitByColumns         = array();
        $billItemTypeReferences           = array();
        $billItemTypeRefFormulatedColumns = array();

        $stmt = $pdo->prepare("SELECT i.id, i.description, i.type, i.lft, i.level, i.grand_total_quantity, i.grand_total,
            i.bill_ref_element_no, i.bill_ref_page_no, i.bill_ref_char, uom.id AS uom_id, uom.symbol AS uom_symbol,
            i.note, i.project_revision_id, i.project_revision_deleted_at, COALESCE(hr.rate, 0) AS historical_rate, r.version,
            pc.supply_rate AS pc_supply_rate, pc.wastage_percentage AS pc_wastage_percentage,
            pc.wastage_amount AS pc_wastage_amount, pc.labour_for_installation AS pc_labour_for_installation,
            pc.other_cost AS pc_other_cost, pc.profit_percentage AS pc_profit_percentage,
            pc.profit_amount AS pc_profit_amount, pc.total AS pc_total
            FROM " . BillItemTable::getInstance()->getTableName() . " i
            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom ON i.uom_id = uom.id AND uom.deleted_at IS NULL
            LEFT JOIN " . BillItemPrimeCostRateTable::getInstance()->getTableName() . " pc ON i.id = pc.bill_item_id AND pc.deleted_at IS NULL
            LEFT JOIN " . ProjectRevisionTable::getInstance()->getTableName() . " r ON i.project_revision_id = r.id
            LEFT JOIN " . HistoricalRateTable::getInstance()->getTableName() . " hr ON hr.bill_item_id = i.id
            WHERE i.element_id = " . $element->id . " AND i.deleted_at IS NULL
            AND r.deleted_at IS NULL ORDER BY i.priority, i.lft, i.level");

        $stmt->execute();

        $billItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $stmt = $pdo->prepare("SELECT ifc.relation_id, ifc.column_name, ifc.final_value, ifc.value, ifc.linked, ifc.has_build_up
            FROM " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " ifc JOIN
            " . BillItemTable::getInstance()->getTableName() . " i ON i.id = ifc.relation_id
            WHERE i.element_id = " . $element->id . " AND i.deleted_at IS NULL
            AND ifc.deleted_at IS NULL AND ifc.final_value <> 0");

        $stmt->execute();

        $itemFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ( $itemFormulatedColumns as $itemFormulatedColumn )
        {
            if ( !array_key_exists($itemFormulatedColumn['relation_id'], $formulatedColumns) )
            {
                $formulatedColumns[$itemFormulatedColumn['relation_id']] = array();
            }

            array_push($formulatedColumns[$itemFormulatedColumn['relation_id']], $itemFormulatedColumn);

            unset( $itemFormulatedColumn );
        }

        unset( $itemFormulatedColumns );

        $billItemIds = Utilities::arrayValueRecursive('id', $billItems);

        if ( $billItems and is_array($billItemIds) and count($billItemIds) > 0 )
        {
            $implodedItemIds = implode(',', $billItemIds);

            foreach ( $bill->BillColumnSettings as $column )
            {
                $quantityFieldName = $column->use_original_quantity ? BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT : BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT;

                $stmt = $pdo->prepare("SELECT r.bill_item_id, COALESCE(fc.final_value, 0) AS value FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " fc
                JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " r ON fc.relation_id = r.id
                WHERE r.bill_item_id IN (" . $implodedItemIds . ") AND r.bill_column_setting_id = " . $column->id . "
                AND r.include IS TRUE AND fc.column_name = '" . $quantityFieldName . "' AND fc.final_value <> 0
                AND r.deleted_at IS NULL AND fc.deleted_at IS NULL");

                $stmt->execute();

                $quantities = $stmt->fetchAll(PDO::FETCH_COLUMN | PDO::FETCH_GROUP);

                $quantityPerUnitByColumns[$column->id] = $quantities;

                $stmt = $pdo->prepare("SELECT r.id, r.bill_item_id, r.include, r.total_quantity, r.quantity_per_unit_difference
                    FROM " . BillItemTypeReferenceTable::getInstance()->getTableName() . " r
                    WHERE r.bill_item_id IN (" . $implodedItemIds . ") AND r.bill_column_setting_id = " . $column->id . "
                    AND r.deleted_at IS NULL");

                $stmt->execute();

                $billItemTypeRefs = $stmt->fetchAll(PDO::FETCH_ASSOC);

                $billItemTypeRefIds = count($billItemTypeRefs) > 0 ? new SplFixedArray(count($billItemTypeRefs)) : null;

                foreach ( $billItemTypeRefs as $idx => $billItemTypeReference )
                {
                    if ( !array_key_exists($column->id, $billItemTypeReferences) )
                    {
                        $billItemTypeReferences[$column->id] = array();
                    }

                    $billItemTypeReferences[$column->id][$billItemTypeReference['bill_item_id']] = $billItemTypeReference;

                    $billItemTypeRefIds[$idx] = $billItemTypeReference['id'];
                }

                if ( $billItemTypeRefIds instanceof SplFixedArray )
                {
                    $stmt = $pdo->prepare("SELECT fc.relation_id, fc.value, fc.final_value, fc.column_name, fc.linked, fc.has_build_up FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " fc
                        WHERE fc.relation_id IN (" . implode(',', $billItemTypeRefIds->toArray()) . ") AND fc.deleted_at IS NULL");

                    $stmt->execute();

                    $billItemTypeRefFormulatedColumnFetch = $stmt->fetchAll(PDO::FETCH_ASSOC);

                    foreach ( $billItemTypeRefFormulatedColumnFetch as $fc )
                    {
                        if ( !array_key_exists($fc['relation_id'], $billItemTypeRefFormulatedColumns) )
                        {
                            $billItemTypeRefFormulatedColumns[$fc['relation_id']] = array();
                        }

                        array_push($billItemTypeRefFormulatedColumns[$fc['relation_id']], $fc);

                        unset( $fc );
                    }

                    unset( $billItemTypeRefFormulatedColumnFetch );
                }

                unset( $billItemTypeRefs );
            }
        }

        return array( $billItems, $formulatedColumns, $quantityPerUnitByColumns, $billItemTypeReferences, $billItemTypeRefFormulatedColumns );
    }

    public static function getSelectedItemsWithBuildUpRates(ProjectStructure $bill, $itemIds)
    {
        $itemIds = json_decode($itemIds, true);
        $pdo     = self::getInstance()->getConnection()->getDbh();

        $newItemIds        = array();
        $elementIds        = array();
        $billItems         = array();
        $formulatedColumns = array();

        if ( empty( $itemIds ) )
        {
            return array( $elementIds, $billItems, $formulatedColumns );
        }

        $stmt = $pdo->prepare("SELECT ifc.relation_id, ifc.column_name, ifc.final_value, ifc.value, ifc.linked, ifc.has_build_up
        FROM " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " ifc JOIN
        " . BillItemTable::getInstance()->getTableName() . " i ON i.id = ifc.relation_id
        WHERE i.id IN (" . implode(',', $itemIds) . ") AND i.deleted_at IS NULL
        AND ifc.deleted_at IS NULL AND ifc.final_value <> 0");

        $stmt->execute();
        $itemFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ( $itemFormulatedColumns as $itemFormulatedColumn )
        {
            if ( !array_key_exists($itemFormulatedColumn['relation_id'], $formulatedColumns) )
            {
                $formulatedColumns[$itemFormulatedColumn['relation_id']] = array();
            }

            array_push($formulatedColumns[$itemFormulatedColumn['relation_id']], $itemFormulatedColumn);

            if ( $itemFormulatedColumn['column_name'] == BillItem::FORMULATED_COLUMN_RATE AND $itemFormulatedColumn['has_build_up'] == true )
            {
                $newItemIds[$itemFormulatedColumn['relation_id']] = $itemFormulatedColumn['relation_id'];
            }

            unset( $itemFormulatedColumn );
        }

        unset( $itemIds, $itemFormulatedColumns );

        if ( empty( $newItemIds ) )
        {
            return array( $elementIds, $billItems, $formulatedColumns );
        }

        $stmt = $pdo->prepare("SELECT DISTINCT p.id, p.element_id, p.description, p.type, p.priority, p.lft, p.level, p.grand_total_quantity, p.grand_total,
        p.bill_ref_element_no, p.bill_ref_page_no, p.bill_ref_char, uom.id AS uom_id, uom.symbol AS uom_symbol,
        p.note, p.project_revision_id, p.project_revision_deleted_at, r.version,
        pc.supply_rate AS pc_supply_rate, pc.wastage_percentage AS pc_wastage_percentage,
        pc.wastage_amount AS pc_wastage_amount, pc.labour_for_installation AS pc_labour_for_installation,
        pc.other_cost AS pc_other_cost, pc.profit_percentage AS pc_profit_percentage,
        pc.profit_amount AS pc_profit_amount, pc.total AS pc_total
        FROM " . BillItemTable::getInstance()->getTableName() . " i
        JOIN " . BillItemTable::getInstance()->getTableName() . " p
        ON (i.lft BETWEEN p.lft AND p.rgt AND p.project_revision_deleted_at IS NULL AND p.deleted_at IS NULL)
        JOIN " . BillElementTable::getInstance()->getTableName() . " e ON p.element_id = e.id AND e.deleted_at IS NULL
        LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom ON (p.uom_id = uom.id AND uom.deleted_at IS NULL)
        LEFT JOIN " . BillItemPrimeCostRateTable::getInstance()->getTableName() . " pc ON (p.id = pc.bill_item_id)
        LEFT JOIN " . ProjectRevisionTable::getInstance()->getTableName() . " r ON (p.project_revision_id = r.id)
        WHERE e.project_structure_id = " . $bill->id . " AND i.id IN (" . implode(',', $newItemIds) . ")
        AND i.root_id = p.root_id AND i.type <> " . BillItem::TYPE_HEADER . "
        AND p.project_revision_deleted_at IS NULL AND i.deleted_at IS NULL AND pc.deleted_at IS NULL AND r.deleted_at IS NULL
        ORDER BY p.priority, p.lft, p.level");

        $stmt->execute(array());
        $billItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ( $billItems as $billItem )
        {
            $elementIds[$billItem['element_id']] = $billItem['element_id'];
        }

        return array( $elementIds, $billItems, $formulatedColumns );
    }

    public static function getSelectedItemsWithBuildUpQty(ProjectStructure $bill, $itemIds)
    {
        $itemIds                          = json_decode($itemIds, true);
        $pdo                              = self::getInstance()->getConnection()->getDbh();
        $newItemIds                       = array();
        $elementIds                       = array();
        $billItems                        = array();
        $formulatedColumns                = array();
        $quantityPerUnitByColumns         = array();
        $billItemTypeReferences           = array();
        $billItemTypeRefFormulatedColumns = array();

        if ( count($itemIds) == 0 )
        {
            return array( $elementIds, $billItems, $formulatedColumns, $quantityPerUnitByColumns, $billItemTypeReferences, $billItemTypeRefFormulatedColumns );
        }

        foreach ( $bill->BillColumnSettings as $column )
        {
            $currentItemIds    = implode(',', $itemIds);
            $quantityFieldName = $column->use_original_quantity ? BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT : BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT;

            // will get quantity that has build up first, then only proceed to query other things
            $stmt = $pdo->prepare("SELECT r.bill_item_id
            FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " fc
            JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " r ON fc.relation_id = r.id
            WHERE r.bill_item_id IN (" . $currentItemIds . ") AND r.bill_column_setting_id = " . $column->id . "
            AND r.include IS TRUE AND fc.column_name = '" . $quantityFieldName . "' AND fc.final_value <> 0
            AND fc.has_build_up = TRUE AND r.deleted_at IS NULL AND fc.deleted_at IS NULL");

            $stmt->execute();
            $checkItemsWithBuildUpQtys = $stmt->fetchAll(PDO::FETCH_ASSOC);

            foreach ( $checkItemsWithBuildUpQtys as $checkItemsWithBuildUpQty )
            {
                $newItemIds[$checkItemsWithBuildUpQty['bill_item_id']] = $checkItemsWithBuildUpQty['bill_item_id'];

                unset( $checkItemsWithBuildUpQty );
            }

            if ( !empty( $newItemIds ) )
            {
                $currentItemIds = implode(',', $newItemIds);

                $stmt = $pdo->prepare("SELECT r.bill_item_id, COALESCE(fc.final_value, 0) AS value
                FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " fc
                JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " r ON fc.relation_id = r.id
                WHERE r.bill_item_id IN (" . $currentItemIds . ") AND r.bill_column_setting_id = " . $column->id . "
                AND r.include IS TRUE AND fc.column_name = '" . $quantityFieldName . "' AND fc.final_value <> 0
                AND fc.has_build_up = TRUE AND r.deleted_at IS NULL AND fc.deleted_at IS NULL");

                $stmt->execute();
                $quantities = $stmt->fetchAll(PDO::FETCH_COLUMN | PDO::FETCH_GROUP);

                $quantityPerUnitByColumns[$column->id] = $quantities;

                $stmt = $pdo->prepare("SELECT r.id, r.bill_item_id, r.include, r.total_quantity, r.quantity_per_unit_difference
                FROM " . BillItemTypeReferenceTable::getInstance()->getTableName() . " r
                WHERE r.bill_item_id IN (" . $currentItemIds . ") AND r.bill_column_setting_id = " . $column->id . "
                AND r.deleted_at IS NULL");

                $stmt->execute();
                $billItemTypeRefs = $stmt->fetchAll(PDO::FETCH_ASSOC);

                $billItemTypeRefIds = count($billItemTypeRefs) > 0 ? new SplFixedArray(count($billItemTypeRefs)) : null;

                foreach ( $billItemTypeRefs as $idx => $billItemTypeReference )
                {
                    if ( !array_key_exists($column->id, $billItemTypeReferences) )
                    {
                        $billItemTypeReferences[$column->id] = array();
                    }

                    $billItemTypeReferences[$column->id][$billItemTypeReference['bill_item_id']] = $billItemTypeReference;

                    $billItemTypeRefIds[$idx] = $billItemTypeReference['id'];
                }

                if ( $billItemTypeRefIds instanceof SplFixedArray )
                {
                    $implodedBillItemTypeRefIds = implode(',', $billItemTypeRefIds->toArray());

                    $stmt = $pdo->prepare("SELECT fc.relation_id, fc.value, fc.final_value, fc.column_name, fc.linked,
                    fc.has_build_up FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " fc
                    WHERE fc.relation_id IN (" . $implodedBillItemTypeRefIds . ") AND fc.deleted_at IS NULL");

                    $stmt->execute();
                    $billItemTypeRefFormulatedColumnFetch = $stmt->fetchAll(PDO::FETCH_ASSOC);

                    foreach ( $billItemTypeRefFormulatedColumnFetch as $fc )
                    {
                        if ( !array_key_exists($fc['relation_id'], $billItemTypeRefFormulatedColumns) )
                        {
                            $billItemTypeRefFormulatedColumns[$fc['relation_id']] = array();
                        }

                        array_push($billItemTypeRefFormulatedColumns[$fc['relation_id']], $fc);

                        unset( $fc );
                    }

                    unset( $billItemTypeRefFormulatedColumnFetch );
                }

                unset( $billItemTypeRefs );
            }

            unset( $currentItemIds );
        }

        unset( $itemIds );

        if ( !empty( $newItemIds ) )
        {
            $stmt = $pdo->prepare("SELECT DISTINCT p.id, p.element_id, p.description, p.type, p.priority, p.lft, p.level, p.grand_total_quantity, p.grand_total,
            p.bill_ref_element_no, p.bill_ref_page_no, p.bill_ref_char, uom.id AS uom_id, uom.symbol AS uom_symbol,
            p.note, p.project_revision_id, p.project_revision_deleted_at, r.version,
            pc.supply_rate AS pc_supply_rate, pc.wastage_percentage AS pc_wastage_percentage,
            pc.wastage_amount AS pc_wastage_amount, pc.labour_for_installation AS pc_labour_for_installation,
            pc.other_cost AS pc_other_cost, pc.profit_percentage AS pc_profit_percentage,
            pc.profit_amount AS pc_profit_amount, pc.total AS pc_total
            FROM " . BillItemTable::getInstance()->getTableName() . " i
            JOIN " . BillItemTable::getInstance()->getTableName() . " p
            ON (i.lft BETWEEN p.lft AND p.rgt AND p.project_revision_deleted_at IS NULL AND p.deleted_at IS NULL)
            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom ON (p.uom_id = uom.id AND uom.deleted_at IS NULL)
            LEFT JOIN " . BillItemPrimeCostRateTable::getInstance()->getTableName() . " pc ON (p.id = pc.bill_item_id)
            LEFT JOIN " . ProjectRevisionTable::getInstance()->getTableName() . " r ON (p.project_revision_id = r.id)
            WHERE i.id IN (" . implode(',', $newItemIds) . ") AND i.root_id = p.root_id AND i.type <> " . BillItem::TYPE_HEADER . "
            AND i.project_revision_deleted_at IS NULL AND i.deleted_at IS NULL AND pc.deleted_at IS NULL AND r.deleted_at IS NULL
            ORDER BY p.priority, p.lft, p.level");

            $stmt->execute(array());
            $billItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

            foreach ( $billItems as $billItem )
            {
                $elementIds[$billItem['element_id']] = $billItem['element_id'];
            }

            $stmt = $pdo->prepare("SELECT ifc.relation_id, ifc.column_name, ifc.final_value, ifc.value, ifc.linked, ifc.has_build_up
            FROM " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " ifc JOIN
            " . BillItemTable::getInstance()->getTableName() . " i ON i.id = ifc.relation_id
            WHERE i.element_id IN (" . implode(', ', $elementIds) . ") AND i.deleted_at IS NULL
            AND ifc.deleted_at IS NULL AND ifc.final_value <> 0");

            $stmt->execute();
            $itemFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

            foreach ( $itemFormulatedColumns as $itemFormulatedColumn )
            {
                if ( !array_key_exists($itemFormulatedColumn['relation_id'], $formulatedColumns) )
                {
                    $formulatedColumns[$itemFormulatedColumn['relation_id']] = array();
                }

                array_push($formulatedColumns[$itemFormulatedColumn['relation_id']], $itemFormulatedColumn);

                unset( $itemFormulatedColumn );
            }

            unset( $itemFormulatedColumns );
        }

        return array( $elementIds, $billItems, $formulatedColumns, $quantityPerUnitByColumns, $billItemTypeReferences, $billItemTypeRefFormulatedColumns );
    }

    public static function getDataStructureForStandardClaimBillItemList($element, $bill, $revision, $postContractId, PostContractStandardClaimTypeReference $typeRef)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT p.id, p.project_structure_id, p.selected_type_rate FROM " . PostContractTable::getInstance()->getTableName() . " p
            WHERE p.id = " . $postContractId);

        $stmt->execute();

        $postContract = $stmt->fetch(PDO::FETCH_ASSOC);

        if ( $postContract['selected_type_rate'] == PostContract::RATE_TYPE_CONTRACTOR )
        {
            $stmt = $pdo->prepare("SELECT tc.id, tc.company_id FROM " . TenderSettingTable::getInstance()->getTableName() . " ts
            JOIN " . TenderCompanyTable::getInstance()->getTableName() . " tc ON tc.company_id = ts.awarded_company_id AND tc.project_structure_id = ts.project_structure_id
            WHERE ts.project_structure_id = " . $postContract['project_structure_id'] . " AND ts.deleted_at IS NULL");

            $stmt->execute();

            $tenderCompany = $stmt->fetch(PDO::FETCH_ASSOC);

            $sqlNOtListedField = ', (CASE i.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN tnl.description 
                    ELSE i.description 
                    END
                ) AS description, 
                (CASE i.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . ' 
                    THEN uom_not_listed.id
                    ELSE uom.id
                    END
                ) AS uom_id, 
                (CASE i.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . ' 
                    THEN uom_not_listed.symbol
                    ELSE uom.symbol
                    END
                ) AS uom_symbol';

            $sqlNOtListed = "LEFT JOIN " . TenderBillItemNotListedTable::getInstance()->getTableName() . " tnl ON tnl.bill_item_id = i.id AND tnl.tender_company_id = " . $tenderCompany['id'] . "
                            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom_not_listed ON tnl.uom_id = uom_not_listed.id AND uom_not_listed.deleted_at IS NULL";
        }
        else if ( $postContract['selected_type_rate'] == PostContract::RATE_TYPE_RATIONALIZED )
        {
            $sqlNOtListedField = ', (CASE i.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN tnl.description 
                    ELSE i.description 
                    END
                ) AS description, 
                (CASE i.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . ' 
                    THEN uom_not_listed.id
                    ELSE uom.id
                    END
                ) AS uom_id, 
                (CASE i.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . ' 
                    THEN uom_not_listed.symbol
                    ELSE uom.symbol
                    END
                ) AS uom_symbol';

            $sqlNOtListed = "LEFT JOIN " . TenderBillItemNotListedRationalizedTable::getInstance()->getTableName() . " tnl ON tnl.bill_item_id = i.id
                            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom_not_listed ON uom_not_listed.id = tnl.uom_id";
        }
        else
        {
            $sqlNOtListedField = ', i.description, uom.id AS uom_id, uom.symbol AS uom_symbol';
            $sqlNOtListed      = '';
        }

        $stmt = $pdo->prepare("SELECT pi.post_contract_id, " . $revision['id'] . " AS claim_revision_id, ROUND(COALESCE(pi.rate,0), 2) AS rate, type_fc.has_build_up , pi.bill_ref_element_no, pi.bill_ref_page_no, pi.bill_ref_char,
            ROUND(COALESCE(pcr.up_to_date_percentage, 0),2) AS prev_percentage, ROUND(COALESCE(pcr.up_to_date_amount, 0),2) AS prev_amount, ROUND(COALESCE(cr.current_amount,0),2) AS current_amount,
            ROUND(COALESCE(cr.current_percentage,0),2) AS current_percentage, ROUND(COALESCE(cr.up_to_date_percentage,0),2) AS up_to_date_percentage, ROUND(COALESCE(cr.up_to_date_qty,0),2) AS up_to_date_qty,
            ROUND(COALESCE(cr.up_to_date_amount,0),2) AS up_to_date_amount,
            ROUND(COALESCE(icr.up_to_date_percentage,0),2) AS imported_up_to_date_percentage,
            ROUND(COALESCE(icr.up_to_date_qty,0),2) AS imported_up_to_date_qty,
            ROUND(COALESCE(icr.up_to_date_amount,0),2) AS imported_up_to_date_amount,
            i.id, i.note, i.type, i.lft, i.level, pt.total_per_unit, ROUND(pt.qty_per_unit,2) AS qty_per_unit, pt.include " . $sqlNOtListedField . "
            FROM " . PostContractBillItemRateTable::getInstance()->getTableName() . " pi
            LEFT JOIN " . BillItemTable::getInstance()->getTableName() . " i on i.id = pi.bill_item_id
            LEFT JOIN " . PostContractClaimRevisionTable::getInstance()->getTableName() . " pr ON pr.post_contract_id = " . $revision['post_contract_id'] . " AND pr.version = (" . $revision['version'] . " - 1)
            LEFT JOIN " . PostContractStandardClaimTable::getInstance()->getTableName() . " cr ON cr.bill_item_id = pi.bill_item_id AND cr.claim_type_ref_id = " . $typeRef->id . " AND cr.revision_id = " . $revision['id'] . "
            LEFT JOIN " . PostContractStandardClaimTable::getInstance()->getTableName() . " pcr ON pcr.bill_item_id = pi.bill_item_id AND pcr.claim_type_ref_id = " . $typeRef->id . " AND pcr.revision_id = pr.id
            LEFT JOIN " . PostContractImportedStandardClaimTable::getInstance()->getTableName() . " icr ON icr.bill_item_id = pi.bill_item_id AND icr.claim_type_ref_id = " . $typeRef->id . " AND icr.revision_id = " . $revision['id'] . "
            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom ON i.uom_id = uom.id AND uom.deleted_at IS NULL
            LEFT JOIN " . PostContractBillItemTypeTable::getInstance()->getTableName() . " pt ON pt.post_contract_id = " . $typeRef->post_contract_id . " AND pt.bill_item_id = pi.bill_item_id AND pt.bill_column_setting_id = " . $typeRef->bill_column_setting_id . "
            LEFT JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " type ON type.bill_item_id = pt.bill_item_id AND type.bill_column_setting_id = pt.bill_column_setting_id AND type.deleted_at IS NULL
            LEFT JOIN " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " type_fc ON type_fc.relation_id = type.id AND column_name ='" . BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT . "' AND type_fc.deleted_at IS NULL
            " . $sqlNOtListed . "
            WHERE i.element_id = " . $element->id . " AND i.deleted_at IS NULL AND i.project_revision_deleted_at IS NULL
            AND pi.post_contract_id = " . $postContractId . " ORDER BY i.priority, i.lft, i.level");

        $stmt->execute();

        $billItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

        return array( $billItems );
    }


    public static function getDataStructureForSubPackageStandardClaimBillItemList(BillElement $element, $revision, $subPackageId, PostContractStandardClaimTypeReference $typeRef)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        // get process post contract latest bill ref
        $billRefSelector       = 'pc.bill_ref_element_no, pc.bill_ref_page_no, pc.bill_ref_char';
        $postContractJoinTable = 'JOIN ' . PostContractBillItemRateTable::getInstance()->getTableName() . " pc ON (pc.bill_item_id = i.id)";

        $stmt = $pdo->prepare("SELECT si.sub_package_id, " . $revision['id'] . " AS claim_revision_id,
        ROUND(COALESCE(si.rate,0), 2) AS rate, type_fc.has_build_up,
        ROUND(COALESCE(pcr.up_to_date_percentage, 0),2) AS prev_percentage,
        ROUND(COALESCE(pcr.up_to_date_amount, 0),2) AS prev_amount,
        ROUND(COALESCE(cr.current_amount,0),2) AS current_amount,
        ROUND(COALESCE(cr.current_percentage,0),2) AS current_percentage,
        ROUND(COALESCE(cr.up_to_date_percentage,0),2) AS up_to_date_percentage,
        ROUND(COALESCE(cr.up_to_date_qty,0),2) AS up_to_date_qty,
        ROUND(COALESCE(cr.up_to_date_amount,0),2) AS up_to_date_amount,
        i.id, i.note, i.type, i.lft, i.level, ROUND(pt.qty_per_unit * si.rate,2) AS total_per_unit,
        ROUND(pt.qty_per_unit,2) AS qty_per_unit, pt.include, i.description, uom.id AS uom_id,
        uom.symbol AS uom_symbol, {$billRefSelector}
        FROM " . SubPackagePostContractBillItemRateTable::getInstance()->getTableName() . " si
        LEFT JOIN " . BillItemTable::getInstance()->getTableName() . " i on i.id = si.bill_item_id {$postContractJoinTable}
        LEFT JOIN " . SubPackagePostContractClaimRevisionTable::getInstance()->getTableName() . " pr
        ON pr.sub_package_id = " . $revision['sub_package_id'] . " AND pr.version = (" . $revision['version'] . " - 1)
        LEFT JOIN " . SubPackagePostContractStandardClaimTable::getInstance()->getTableName() . " cr
        ON cr.bill_item_id = si.bill_item_id AND cr.claim_type_ref_id = " . $typeRef->id . " AND cr.revision_id = " . $revision['id'] . "
        LEFT JOIN " . SubPackagePostContractStandardClaimTable::getInstance()->getTableName() . " pcr
        ON pcr.bill_item_id = si.bill_item_id AND pcr.claim_type_ref_id = " . $typeRef->id . " AND pcr.revision_id = pr.id
        LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom ON i.uom_id = uom.id AND uom.deleted_at IS NULL
        LEFT JOIN " . PostContractBillItemTypeTable::getInstance()->getTableName() . " pt
        ON pt.post_contract_id = " . $typeRef->post_contract_id . " AND pt.bill_item_id = si.bill_item_id
        AND pt.bill_column_setting_id = " . $typeRef->bill_column_setting_id . "
        LEFT JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " type
        ON type.bill_item_id = pt.bill_item_id AND type.bill_column_setting_id = pt.bill_column_setting_id AND type.deleted_at IS NULL
        LEFT JOIN " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " type_fc
        ON type_fc.relation_id = type.id AND column_name ='" . BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT . "'
        WHERE i.element_id = " . $element->id . " AND i.deleted_at IS NULL AND i.project_revision_deleted_at IS NULL
        AND si.sub_package_id = " . $subPackageId . "
        ORDER BY i.priority, i.lft, i.level");

        $stmt->execute();

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public static function getDataStructureForStandardClaimBillItemListFilteredByItemIds($element, $bill, $revision, $postContractId, PostContractStandardClaimTypeReference $typeRef, $itemIds)
    {
        $itemIds = json_decode($itemIds, true);

        if ( count($itemIds) == 0 )
        {
            return array();
        }

        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT p.id, p.project_structure_id, p.selected_type_rate FROM " . PostContractTable::getInstance()->getTableName() . " p
            WHERE p.id = " . $postContractId);

        $stmt->execute();

        $postContract = $stmt->fetch(PDO::FETCH_ASSOC);

        if ( $postContract['selected_type_rate'] == PostContract::RATE_TYPE_CONTRACTOR )
        {
            $stmt = $pdo->prepare("SELECT tc.id, tc.company_id FROM " . TenderSettingTable::getInstance()->getTableName() . " ts
            JOIN " . TenderCompanyTable::getInstance()->getTableName() . " tc ON tc.company_id = ts.awarded_company_id AND tc.project_structure_id = ts.project_structure_id
            WHERE ts.project_structure_id = " . $postContract['project_structure_id'] . " AND ts.deleted_at IS NULL");

            $stmt->execute();

            $tenderCompany = $stmt->fetch(PDO::FETCH_ASSOC);

            $sqlNOtListedField = ', (CASE p.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN tnl.description
                    ELSE p.description
                    END
                ) AS description,
                (CASE p.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN uom_not_listed.id
                    ELSE uom.id
                    END
                ) AS uom_id,
                (CASE p.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN uom_not_listed.symbol
                    ELSE uom.symbol
                    END
                ) AS uom_symbol';

            $sqlNOtListed = "LEFT JOIN " . TenderBillItemNotListedTable::getInstance()->getTableName() . " tnl ON tnl.bill_item_id = p.id AND tnl.tender_company_id = " . $tenderCompany['id'] . "
                            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom_not_listed ON tnl.uom_id = uom_not_listed.id AND uom_not_listed.deleted_at IS NULL";
        }
        else if ( $postContract['selected_type_rate'] == PostContract::RATE_TYPE_RATIONALIZED )
        {
            $sqlNOtListedField = ', (CASE p.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN tnl.description
                    ELSE p.description
                    END
                ) AS description,
                (CASE p.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN uom_not_listed.id
                    ELSE uom.id
                    END
                ) AS uom_id,
                (CASE p.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN uom_not_listed.symbol
                    ELSE uom.symbol
                    END
                ) AS uom_symbol';

            $sqlNOtListed = "LEFT JOIN " . TenderBillItemNotListedRationalizedTable::getInstance()->getTableName() . " tnl ON tnl.bill_item_id = p.id
                            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom_not_listed ON uom_not_listed.id = tnl.uom_id";
        }
        else
        {
            $sqlNOtListedField = ', p.description, uom.id AS uom_id, uom.symbol AS uom_symbol';
            $sqlNOtListed      = '';
        }

        $stmt = $pdo->prepare("SELECT DISTINCT p.id, pi.post_contract_id, ROUND(COALESCE(pi.rate,0), 2) AS rate, type_fc.has_build_up, pi.bill_ref_element_no, pi.bill_ref_page_no, pi.bill_ref_char,
            ROUND(COALESCE(pcr.up_to_date_percentage, 0),2) AS prev_percentage, ROUND(COALESCE(pcr.up_to_date_amount, 0),2) AS prev_amount, ROUND(COALESCE(cr.current_amount,0),2) AS current_amount,
            ROUND(COALESCE(cr.current_percentage,0),2) AS current_percentage, ROUND(COALESCE(cr.up_to_date_percentage,0),2) AS up_to_date_percentage, ROUND(COALESCE(cr.up_to_date_qty,0),2) AS up_to_date_qty,
            ROUND(COALESCE(cr.up_to_date_amount,0),2) AS up_to_date_amount, p.note, p.type, p.priority, p.lft, p.level, pt.total_per_unit, ROUND(pt.qty_per_unit,2) AS qty_per_unit, pt.include " . $sqlNOtListedField . "
            FROM " . BillItemTable::getInstance()->getTableName() . " i
            JOIN " . BillItemTable::getInstance()->getTableName() . " p ON (i.lft BETWEEN p.lft AND p.rgt AND i.root_id = p.root_id AND i.type <> " . BillItem::TYPE_HEADER . " AND p.deleted_at IS NULL)
            LEFT JOIN " . PostContractBillItemRateTable::getInstance()->getTableName() . " pi ON pi.bill_item_id = p.id
            LEFT JOIN " . PostContractClaimRevisionTable::getInstance()->getTableName() . " pr ON pr.post_contract_id = " . $revision['post_contract_id'] . " AND pr.version = (" . $revision['version'] . " - 1)
            LEFT JOIN " . PostContractStandardClaimTable::getInstance()->getTableName() . " cr ON cr.bill_item_id = p.id AND cr.claim_type_ref_id = " . $typeRef->id . " AND cr.revision_id = " . $revision['id'] . "
            LEFT JOIN " . PostContractStandardClaimTable::getInstance()->getTableName() . " pcr ON pcr.bill_item_id = p.id AND pcr.claim_type_ref_id = " . $typeRef->id . " AND pcr.revision_id = pr.id
            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom ON p.uom_id = uom.id AND uom.deleted_at IS NULL
            LEFT JOIN " . PostContractBillItemTypeTable::getInstance()->getTableName() . " pt ON pt.post_contract_id = " . $typeRef->post_contract_id . " AND pt.bill_item_id = p.id AND pt.bill_column_setting_id = " . $typeRef->bill_column_setting_id . "
            LEFT JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " type ON type.bill_item_id = p.id AND type.bill_column_setting_id = pt.bill_column_setting_id AND type.deleted_at IS NULL
            LEFT JOIN " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " type_fc ON type_fc.relation_id = type.id AND column_name ='" . BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT . "'
            " . $sqlNOtListed . "
            WHERE i.id IN (" . implode(',', $itemIds) . ") AND i.element_id = " . $element->id . " AND pi.post_contract_id = " . $postContractId . " ORDER BY p.priority, p.lft, p.level");

        $stmt->execute();

        $billItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

        return array( $billItems );
    }

    public static function getPrintingPreviewDataStructureForBillItemList($itemIds, $bill)
    {
        $itemIds = json_decode($itemIds, true);

        $pdo = self::getInstance()->getConnection()->getDbh();

        $elementIds                       = array();
        $newElements                      = array();
        $newBillItems                     = array();
        $formulatedColumns                = array();
        $quantityPerUnitByColumns         = array();
        $billItemTypeReferences           = array();
        $billItemTypeRefFormulatedColumns = array();

        if ( count($itemIds) == 0 )
        {
            return array( array(), array(), $formulatedColumns, $quantityPerUnitByColumns, $billItemTypeReferences, $billItemTypeRefFormulatedColumns );
        }

        $stmt = $pdo->prepare("SELECT DISTINCT p.id, p.element_id, p.description, p.type, p.priority, p.lft, p.level,
            p.grand_total_quantity, p.grand_total, p.bill_ref_element_no, p.bill_ref_page_no, p.bill_ref_char,
            uom.id AS uom_id, uom.symbol AS uom_symbol, p.note, p.project_revision_id, p.project_revision_deleted_at,
            r.version, pc.supply_rate AS pc_supply_rate, pc.wastage_percentage AS pc_wastage_percentage,
            pc.wastage_amount AS pc_wastage_amount, pc.labour_for_installation AS pc_labour_for_installation,
            pc.other_cost AS pc_other_cost, pc.profit_percentage AS pc_profit_percentage,
            pc.profit_amount AS pc_profit_amount, pc.total AS pc_total, e.priority as element_priority
            FROM " . BillItemTable::getInstance()->getTableName() . " i
            JOIN " . BillItemTable::getInstance()->getTableName() . " p
            ON (i.lft BETWEEN p.lft AND p.rgt AND p.project_revision_deleted_at IS NULL AND p.deleted_at IS NULL)
            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom ON (p.uom_id = uom.id AND uom.deleted_at IS NULL)
            LEFT JOIN " . BillItemPrimeCostRateTable::getInstance()->getTableName() . " pc ON (p.id = pc.bill_item_id)
            LEFT JOIN " . ProjectRevisionTable::getInstance()->getTableName() . " r ON (p.project_revision_id = r.id)
            LEFT JOIN " . BillElementTable::getInstance()->getTableName() . " e ON (p.element_id = e.id AND e.deleted_at IS NULL)
            WHERE i.id IN (" . implode(',', $itemIds) . ") AND e.project_structure_id = " . $bill->id . "
            AND i.root_id = p.root_id AND i.type <> " . BillItem::TYPE_HEADER . " AND i.project_revision_deleted_at IS NULL
            AND i.deleted_at IS NULL AND pc.deleted_at IS NULL AND r.deleted_at IS NULL
            ORDER BY element_priority, p.priority, p.lft, p.level");

        $stmt->execute();

        $billItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if ( count($billItems) == 0 )
        {
            return array( array(), array(), $formulatedColumns, $quantityPerUnitByColumns, $billItemTypeReferences, $billItemTypeRefFormulatedColumns );
        }

        foreach ( $billItems as $billItem )
        {
            $newBillItems[$billItem['element_id']][] = $billItem;

            $elementIds[$billItem['element_id']] = $billItem['element_id'];
        }

        unset( $billItems );

        // get elements that has been tagged from items
        $stmt = $pdo->prepare("SELECT e.id, e.description FROM " . BillElementTable::getInstance()->getTableName() . " e
            WHERE e.id IN (" . implode(',', $elementIds) . ")");
        $stmt->execute();

        $elements = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ( $elements as $element )
        {
            $newElements[$element['id']] = array(
                'description' => $element['description'],
            );
        }

        unset( $elements );

        foreach ( $newBillItems as $elementId => $billItems )
        {
            $stmt = $pdo->prepare("SELECT ifc.relation_id, ifc.column_name, ifc.final_value, ifc.value, ifc.linked, ifc.has_build_up
            FROM " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " ifc JOIN
            " . BillItemTable::getInstance()->getTableName() . " i ON i.id = ifc.relation_id
            WHERE i.element_id = " . $elementId . " AND i.deleted_at IS NULL
            AND ifc.deleted_at IS NULL AND ifc.final_value <> 0");

            $stmt->execute();

            $itemFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

            foreach ( $itemFormulatedColumns as $itemFormulatedColumn )
            {
                if ( !array_key_exists($itemFormulatedColumn['relation_id'], $formulatedColumns) )
                {
                    $formulatedColumns[$itemFormulatedColumn['relation_id']] = array();
                }

                array_push($formulatedColumns[$itemFormulatedColumn['relation_id']], $itemFormulatedColumn);

                unset( $itemFormulatedColumn );
            }

            unset( $itemFormulatedColumns );
        }

        $implodedItemIds = implode(',', $itemIds);

        foreach ( $bill->BillColumnSettings as $column )
        {
            $quantityFieldName = $column->use_original_quantity ? BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT : BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT;

            $stmt = $pdo->prepare("SELECT r.bill_item_id, COALESCE(fc.final_value, 0) AS value FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " fc
            JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " r ON fc.relation_id = r.id
            WHERE r.bill_item_id IN (" . $implodedItemIds . ") AND r.bill_column_setting_id = " . $column->id . "
            AND r.include IS TRUE AND fc.column_name = '" . $quantityFieldName . "' AND fc.final_value <> 0
            AND r.deleted_at IS NULL AND fc.deleted_at IS NULL");

            $stmt->execute();

            $quantities = $stmt->fetchAll(PDO::FETCH_COLUMN | PDO::FETCH_GROUP);

            $quantityPerUnitByColumns[$column->id] = $quantities;

            $stmt = $pdo->prepare("SELECT r.id, r.bill_item_id, r.include, r.total_quantity, r.quantity_per_unit_difference
                FROM " . BillItemTypeReferenceTable::getInstance()->getTableName() . " r
                WHERE r.bill_item_id IN (" . $implodedItemIds . ") AND r.bill_column_setting_id = " . $column->id . "
                AND r.deleted_at IS NULL");

            $stmt->execute();

            $billItemTypeRefs = $stmt->fetchAll(PDO::FETCH_ASSOC);

            $billItemTypeRefIds = count($billItemTypeRefs) > 0 ? new SplFixedArray(count($billItemTypeRefs)) : null;

            foreach ( $billItemTypeRefs as $idx => $billItemTypeReference )
            {
                if ( !array_key_exists($column->id, $billItemTypeReferences) )
                {
                    $billItemTypeReferences[$column->id] = array();
                }

                $billItemTypeReferences[$column->id][$billItemTypeReference['bill_item_id']] = $billItemTypeReference;

                $billItemTypeRefIds[$idx] = $billItemTypeReference['id'];
            }

            if ( $billItemTypeRefIds instanceof SplFixedArray )
            {
                $implodedBillItemTypeRefIds = implode(',', $billItemTypeRefIds->toArray());

                $stmt = $pdo->prepare("SELECT fc.relation_id, fc.value, fc.final_value, fc.column_name, fc.linked, fc.has_build_up FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " fc
                    WHERE fc.relation_id IN (" . $implodedBillItemTypeRefIds . ") AND fc.deleted_at IS NULL");

                $stmt->execute();

                $billItemTypeRefFormulatedColumnFetch = $stmt->fetchAll(PDO::FETCH_ASSOC);

                foreach ( $billItemTypeRefFormulatedColumnFetch as $fc )
                {
                    if ( !array_key_exists($fc['relation_id'], $billItemTypeRefFormulatedColumns) )
                    {
                        $billItemTypeRefFormulatedColumns[$fc['relation_id']] = array();
                    }

                    array_push($billItemTypeRefFormulatedColumns[$fc['relation_id']], $fc);

                    unset( $fc );
                }

                unset( $billItemTypeRefFormulatedColumnFetch );
            }

            unset( $billItemTypeRefs );
        }

        return array( $newElements, $newBillItems, $formulatedColumns, $quantityPerUnitByColumns, $billItemTypeReferences, $billItemTypeRefFormulatedColumns );
    }

    public static function updateRootPriority($priority, $elementId, $excludeId = null)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $sqlUpdateRoot = "UPDATE " . self::getInstance()->getTableName() . " SET priority = priority + 1
            WHERE element_id =" . $elementId . " AND priority >=" . $priority . " AND id = root_id";

        if ( $excludeId and $excludeId > 0 )
        {
            $sqlUpdateRoot .= " AND id <> " . $excludeId;
        }

        $sqlUpdateRoot .= " AND deleted_at IS NULL";

        $stmt = $pdo->prepare($sqlUpdateRoot);

        $stmt->execute();

        //update children priority same as root priority
        $stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . " AS i SET priority = r.priority
            FROM " . self::getInstance()->getTableName() . " AS r
            WHERE i.root_id = r.id AND i.id <> r.id AND i.priority <> r.priority AND i.element_id = " . $elementId . "
            AND i.deleted_at IS NULL AND r.deleted_at IS NULL");

        $stmt->execute();
    }

    public static function getDataForPrintingPreviewItemsByColumn($element, $bill, $revision, $postContractId, PostContractStandardClaimTypeReference $typeRef, $column)
    {
        $pdo               = self::getInstance()->getConnection()->getDbh();
        $billItemIds       = array();
        $billItems         = array();
        $claimsInformation = array();

        $stmt = $pdo->prepare("SELECT p.id, p.project_structure_id, p.selected_type_rate FROM " . PostContractTable::getInstance()->getTableName() . " p
            WHERE p.id = " . $postContractId);

        $stmt->execute();

        $postContract = $stmt->fetch(PDO::FETCH_ASSOC);

        if ( $postContract['selected_type_rate'] == PostContract::RATE_TYPE_CONTRACTOR )
        {
            $stmt = $pdo->prepare("SELECT tc.id, tc.company_id FROM " . TenderSettingTable::getInstance()->getTableName() . " ts
            JOIN " . TenderCompanyTable::getInstance()->getTableName() . " tc ON tc.company_id = ts.awarded_company_id AND tc.project_structure_id = ts.project_structure_id
            WHERE ts.project_structure_id = " . $postContract['project_structure_id'] . " AND ts.deleted_at IS NULL");

            $stmt->execute();

            $tenderCompany = $stmt->fetch(PDO::FETCH_ASSOC);

            $sqlNOtListedField = ', (CASE p.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN tnl.description
                    ELSE p.description
                    END
                ) AS description,
                (CASE p.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN uom_not_listed.id
                    ELSE uom.id
                    END
                ) AS uom_id,
                (CASE p.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN uom_not_listed.symbol
                    ELSE uom.symbol
                    END
                ) AS uom_symbol';

            $sqlNOtListed = "LEFT JOIN " . TenderBillItemNotListedTable::getInstance()->getTableName() . " tnl ON tnl.bill_item_id = p.id AND tnl.tender_company_id = " . $tenderCompany['id'] . "
                            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom_not_listed ON tnl.uom_id = uom_not_listed.id AND uom_not_listed.deleted_at IS NULL";
        }
        else if ( $postContract['selected_type_rate'] == PostContract::RATE_TYPE_RATIONALIZED )
        {
            $sqlNOtListedField = ', (CASE p.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN tnl.description
                    ELSE p.description
                    END
                ) AS description,
                (CASE p.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN uom_not_listed.id
                    ELSE uom.id
                    END
                ) AS uom_id,
                (CASE p.type WHEN ' . BillItem::TYPE_ITEM_NOT_LISTED . '
                    THEN uom_not_listed.symbol
                    ELSE uom.symbol
                    END
                ) AS uom_symbol';

            $sqlNOtListed = "LEFT JOIN " . TenderBillItemNotListedRationalizedTable::getInstance()->getTableName() . " tnl ON tnl.bill_item_id = p.id
                            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom_not_listed ON uom_not_listed.id = tnl.uom_id";
        }
        else
        {
            $sqlNOtListedField = ', p.description, uom.id AS uom_id, uom.symbol AS uom_symbol';
            $sqlNOtListed      = '';
        }

        // get available current amount based on revision
        $stmt = $pdo->prepare("SELECT DISTINCT i.id, pi.post_contract_id, ROUND(COALESCE(pi.rate,0), 2) AS rate, pi.bill_ref_element_no, pi.bill_ref_page_no, pi.bill_ref_char, ROUND(COALESCE(pcr.up_to_date_percentage, 0),2) AS prev_percentage, ROUND(COALESCE(pcr.up_to_date_amount, 0),2) AS prev_amount, ROUND(COALESCE(cr.current_amount,0),2) AS current_amount, ROUND(COALESCE(cr.current_percentage,0),2) AS current_percentage, ROUND(COALESCE(cr.up_to_date_percentage,0),2) AS up_to_date_percentage, ROUND(COALESCE(cr.up_to_date_qty,0),2) AS up_to_date_qty, ROUND(COALESCE(cr.up_to_date_amount,0),2) AS up_to_date_amount, type_fc.has_build_up
            FROM " . BillItemTable::getInstance()->getTableName() . " i
            LEFT JOIN " . PostContractBillItemRateTable::getInstance()->getTableName() . " pi ON (pi.bill_item_id = i.id)
            LEFT JOIN " . PostContractClaimRevisionTable::getInstance()->getTableName() . " pr ON pr.post_contract_id = " . $revision['post_contract_id'] . " AND pr.version = (" . $revision['version'] . " - 1)
            LEFT JOIN " . PostContractStandardClaimTable::getInstance()->getTableName() . " pcr ON pcr.bill_item_id = i.id AND pcr.claim_type_ref_id = " . $typeRef->id . " AND pcr.revision_id = pr.id
            LEFT JOIN " . PostContractStandardClaimTable::getInstance()->getTableName() . " cr ON cr.bill_item_id = i.id AND cr.claim_type_ref_id = " . $typeRef->id . " AND cr.revision_id = " . $revision['id'] . "
            LEFT JOIN " . PostContractBillItemTypeTable::getInstance()->getTableName() . " pt ON pt.post_contract_id = " . $typeRef->post_contract_id . " AND pt.bill_item_id = i.id AND pt.bill_column_setting_id = " . $typeRef->bill_column_setting_id . "
            LEFT JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " type ON type.bill_item_id = i.id AND type.bill_column_setting_id = pt.bill_column_setting_id AND type.deleted_at IS NULL
            LEFT JOIN " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " type_fc ON type_fc.relation_id = type.id AND column_name ='" . BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT . "'
            WHERE i.element_id = " . $element->id . " AND i.project_revision_deleted_at IS NULL AND i.deleted_at IS NULL AND pi.post_contract_id = " . $postContractId);

        $stmt->execute();

        $claims = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ( $claims as $claim )
        {
            if ( $claim[$column] > 0 )
            {
                $billItemIds[$claim['id']] = $claim['id'];

                $claimsInformation[$claim['id']] = array(
                    'post_contract_id'      => $claim['post_contract_id'],
                    'rate'                  => $claim['rate'],
                    'bill_ref_element_no'   => $claim['bill_ref_element_no'],
                    'bill_ref_page_no'      => $claim['bill_ref_page_no'],
                    'bill_ref_char'         => $claim['bill_ref_char'],
                    'prev_percentage'       => $claim['prev_percentage'],
                    'prev_amount'           => $claim['prev_amount'],
                    'current_amount'        => $claim['current_amount'],
                    'current_percentage'    => $claim['current_percentage'],
                    'up_to_date_percentage' => $claim['up_to_date_percentage'],
                    'up_to_date_qty'        => $claim['up_to_date_qty'],
                    'up_to_date_amount'     => $claim['up_to_date_amount'],
                    'has_build_up'          => $claim['has_build_up'],
                );
            }

            unset( $claim );
        }

        if ( count($billItemIds) > 0 )
        {
            $stmt = $pdo->prepare("SELECT DISTINCT p.id, p.note, p.type, p.priority, p.lft, p.level, pt.total_per_unit, ROUND(pt.qty_per_unit,2) AS qty_per_unit, pt.include " . $sqlNOtListedField . "
                FROM " . BillItemTable::getInstance()->getTableName() . " i
                JOIN " . BillItemTable::getInstance()->getTableName() . " p ON (i.lft BETWEEN p.lft AND p.rgt AND i.root_id = p.root_id AND i.type <> " . BillItem::TYPE_HEADER . " AND p.deleted_at IS NULL)
                LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom ON p.uom_id = uom.id AND uom.deleted_at IS NULL
                LEFT JOIN " . PostContractBillItemTypeTable::getInstance()->getTableName() . " pt ON pt.post_contract_id = " . $typeRef->post_contract_id . " AND pt.bill_item_id = p.id AND pt.bill_column_setting_id = " . $typeRef->bill_column_setting_id . "
                LEFT JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " type ON type.bill_item_id = p.id AND type.bill_column_setting_id = pt.bill_column_setting_id AND type.deleted_at IS NULL
                LEFT JOIN " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " type_fc ON type_fc.relation_id = type.id AND column_name ='" . BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT . "'
                " . $sqlNOtListed . "
                WHERE i.id IN (" . implode(', ', $billItemIds) . ") ORDER BY p.priority, p.lft, p.level");

            $stmt->execute();

            $billItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

            foreach ( $billItems as $key => $billItem )
            {
                $billItems[$key]['bill_ref_element_no'] = null;
                $billItems[$key]['bill_ref_page_no']    = null;
                $billItems[$key]['bill_ref_char']       = null;
                $billItems[$key]['has_build_up']        = null;

                if ( isset( $claimsInformation[$billItem['id']] ) )
                {
                    $billItems[$key] = $billItem + $claimsInformation[$billItem['id']];
                }
            }
        }

        return array( $billItems );
    }

    public static function getSelectedItemsWithBuildUpQuantity(ProjectStructure $bill, $billColumnSettings, $itemIds)
    {
        $pdo                             = self::getInstance()->getConnection()->getDbh();
        $newItemIds                      = array();
        $itemIds                         = json_decode($itemIds, true);
        $uomIds                          = array();
        $billItems                       = array();
        $unitsDimensions                 = array();
        $newBuildUpQuantityItems         = array();
        $quantityPerUnitByColumns        = array();
        $newBillBuildUpQuantitySummaries = array();

        if ( empty( $itemIds ) )
        {
            return array( $billItems, $unitsDimensions, $newBuildUpQuantityItems, $newBillBuildUpQuantitySummaries, $quantityPerUnitByColumns );
        }

        foreach ( $billColumnSettings as $column )
        {
            $quantityFieldName = $column->use_original_quantity ? BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT : BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT;

            $buildupSummaryType = $column->use_original_quantity ? 1 : 2;

            $stmt = $pdo->prepare("SELECT r.bill_item_id
            FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " fc
            JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " r ON fc.relation_id = r.id
            WHERE r.bill_item_id IN (" . implode(',', $itemIds) . ") AND r.bill_column_setting_id = " . $column->id . "
            AND r.include IS TRUE AND fc.column_name = '" . $quantityFieldName . "' AND fc.final_value <> 0
            AND fc.has_build_up = TRUE AND r.deleted_at IS NULL AND fc.deleted_at IS NULL");

            $stmt->execute();
            $checkItemsWithBuildUpQtys = $stmt->fetchAll(PDO::FETCH_ASSOC);

            foreach ( $checkItemsWithBuildUpQtys as $checkItemsWithBuildUpQty )
            {
                $newItemIds[$checkItemsWithBuildUpQty['bill_item_id']] = $checkItemsWithBuildUpQty['bill_item_id'];
            }

            unset( $checkItemsWithBuildUpQtys );

            if ( !empty( $newItemIds ) )
            {
                $stmt = $pdo->prepare("SELECT r.bill_item_id, COALESCE(fc.final_value, 0) AS value
                FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " fc
                JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " r ON fc.relation_id = r.id
                WHERE r.bill_item_id IN (" . implode(',', $newItemIds) . ") AND r.bill_column_setting_id = " . $column->id . "
                AND r.include IS TRUE AND fc.column_name = '" . $quantityFieldName . "' AND fc.final_value <> 0
                AND r.deleted_at IS NULL AND fc.deleted_at IS NULL");

                $stmt->execute();
                $quantities = $stmt->fetchAll(PDO::FETCH_COLUMN | PDO::FETCH_GROUP);

                $quantityPerUnitByColumns[$column->id] = $quantities;

                $billBuildUpQuantitySummaries = DoctrineQuery::create()
                    ->from('BillBuildUpQuantitySummary s')
                    ->whereIn('s.bill_item_id', $newItemIds)
                    ->andWhere('s.bill_column_setting_id = ?', $column->id)
                    ->andWhere('s.type = ?', $buildupSummaryType)
                    ->fetchArray();

                foreach ( $billBuildUpQuantitySummaries as $billBuildUpQuantitySummary )
                {
                    $newBillBuildUpQuantitySummaries[$column->id][$billBuildUpQuantitySummary['bill_item_id']] = $billBuildUpQuantitySummary;

                    unset( $billBuildUpQuantitySummary );
                }

                unset( $billBuildUpQuantitySummaries );
            }
        }

        unset( $itemIds );

        if ( !empty( $newItemIds ) )
        {
            // get selected bill item(s)
            $billItems = DoctrineQuery::create()
                ->from('BillItem i')
                ->leftJoin('i.Element e')
                ->leftJoin('i.UnitOfMeasurement uom')
                ->whereIn('i.id', $newItemIds)
                ->andWhere('e.project_structure_id = ?', $bill->id)
                ->andWhere('i.type <> ?', BillItem::TYPE_HEADER)
                ->addOrderBy('e.priority, i.priority, i.lft, i.level')
                ->fetchArray();

            foreach ( $billItems as $billItem )
            {
                if ( $billItem['uom_id'] )
                {
                    $uomIds[$billItem['uom_id']] = $billItem['uom_id'];
                }

                unset( $billItem );
            }

            // need to check and see whether selected item(s) got build up qty or not
            // if not then omit it from the selected list
            foreach ( $billColumnSettings as $column )
            {
                $buildupSummaryType = $column->use_original_quantity ? 1 : 2;

                $buildUpQuantityItems = DoctrineQuery::create()
                    ->select('i.id, i.bill_item_id, i.bill_column_setting_id, i.description, i.sign, i.total, ifc.column_name, ifc.value, ifc.final_value')
                    ->from('BillBuildUpQuantityItem i')
                    ->leftJoin('i.FormulatedColumns ifc')
                    ->whereIn('i.bill_item_id', $newItemIds)
                    ->andWhere('i.bill_column_setting_id = ?', $column->id)
                    ->andWhere('i.type = ?', $buildupSummaryType)
                    ->addOrderBy('i.priority ASC')
                    ->fetchArray();

                foreach ( $buildUpQuantityItems as $buildUpQuantityItem )
                {
                    $newBuildUpQuantityItems[$column->id][$buildUpQuantityItem['bill_item_id']][] = $buildUpQuantityItem;

                    unset( $buildUpQuantityItem );
                }

                unset( $buildUpQuantityItems );
            }
        }

        // get unit's dimension
        if ( !empty( $uomIds ) )
        {
            $unitsDimensions = UnitOfMeasurementDimensionsTable::getUnitDimensionsByUnitIds($uomIds);
        }

        return array( $billItems, $unitsDimensions, $newBuildUpQuantityItems, $newBillBuildUpQuantitySummaries, $quantityPerUnitByColumns );
    }

    public static function getPrintingSelectedItemsWithBuildUpRates(ProjectStructure $bill, $itemIds)
    {
        $pdo                             = self::getInstance()->getConnection()->getDbh();
        $newItemIds                      = array();
        $itemIds                         = json_decode($itemIds, true);
        $resourceIds                     = array();
        $billItems                       = array();
        $newResourceTrades               = array();
        $newBuildUpRateItems             = array();
        $newBillItemRateFormulatedColumn = array();
        $newBillBuildUpRateSummary       = array();

        if ( empty( $itemIds ) )
        {
            return array( $billItems, $newResourceTrades, $newBuildUpRateItems, $newBillItemRateFormulatedColumn, $newBillBuildUpRateSummary );
        }

        $stmt = $pdo->prepare("SELECT ifc.relation_id, ifc.column_name, ifc.final_value, ifc.value, ifc.linked, ifc.has_build_up
        FROM " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " ifc
        WHERE ifc.relation_id IN (" . implode(', ', $itemIds) . ") AND ifc.deleted_at IS NULL
        AND ifc.column_name = '" . BillItem::FORMULATED_COLUMN_RATE . "'
        AND ifc.has_build_up IS TRUE AND ifc.final_value <> 0");

        $stmt->execute();
        $itemFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ( $itemFormulatedColumns as $itemFormulatedColumn )
        {
            $newItemIds[$itemFormulatedColumn['relation_id']] = $itemFormulatedColumn['relation_id'];
        }

        unset( $itemIds, $itemFormulatedColumns );

        if ( empty( $newItemIds ) )
        {
            return array( $billItems, $newResourceTrades, $newBuildUpRateItems, $newBillItemRateFormulatedColumn, $newBillBuildUpRateSummary );
        }

        // get selected bill item(s)
        $billItems = DoctrineQuery::create()
            ->from('BillItem i')
            ->leftJoin('i.Element e')
            ->leftJoin('i.UnitOfMeasurement uom')
            ->leftJoin('i.BuildUpQuantitySummaries buqs')
            ->whereIn('i.id', $newItemIds)
            ->andWhere('e.project_structure_id = ?', array( $bill->id ))
            ->andWhere('i.type <> ?', array( BillItem::TYPE_HEADER ))
            ->andWhere('i.project_revision_deleted_at IS NULL')
            ->addOrderBy('e.priority, i.priority, i.lft, i.level')
            ->fetchArray();

        foreach ( $billItems as $billItem )
        {
            if ( $billItem['uom_id'] )
            {
                $uomIds[$billItem['uom_id']] = $billItem['uom_id'];
            }

            unset( $billItem );
        }

        unset( $itemIds );

        // for now get trade(s) associated with queried item(s)
        $resourceTrades = DoctrineQuery::create()
            ->select('r.id, r.bill_item_id, r.name, r.resource_library_id')
            ->from('BillBuildUpRateResource r')
            ->whereIn('r.bill_item_id', $newItemIds)
            ->addOrderBy('r.id ASC')
            ->fetchArray();

        foreach ( $resourceTrades as $resourceTrade )
        {
            $resourceIds[$resourceTrade['id']] = $resourceTrade['id'];

            $newResourceTrades[$resourceTrade['bill_item_id']][] = $resourceTrade;

            unset( $resourceTrade );
        }

        unset( $resourceTrades );

        // will get item(s) based on trade
        if ( !empty( $resourceIds ) )
        {
            $buildUpRateItems = DoctrineQuery::create()
                ->select('i.id, i.bill_item_id, i.build_up_rate_resource_id, i.description, i.uom_id, i.total,
            i.line_total, i.resource_item_library_id, ifc.column_name, ifc.value, ifc.final_value, ifc.linked, uom.symbol')
                ->from('BillBuildUpRateItem i')
                ->leftJoin('i.FormulatedColumns ifc')
                ->leftJoin('i.UnitOfMeasurement uom')
                ->whereIn('i.bill_item_id', $newItemIds)
                ->andWhereIn('i.build_up_rate_resource_id', $resourceIds)
                ->addOrderBy('i.priority ASC')
                ->fetchArray();

            foreach ( $buildUpRateItems as $buildUpRateItem )
            {
                $billItemId = $buildUpRateItem['bill_item_id'];
                $resourceId = $buildUpRateItem['build_up_rate_resource_id'];

                foreach ( $buildUpRateItem['FormulatedColumns'] as $formulatedColumnKey => $formulatedColumn )
                {
                    $buildUpRateItem['FormulatedColumns'][$formulatedColumnKey]['has_formula'] = $formulatedColumn['value'] != $formulatedColumn['final_value'] ? true : false;
                }

                $newBuildUpRateItems[$billItemId][$resourceId][] = $buildUpRateItem;

                unset( $buildUpRateItem );
            }

            unset( $buildUpRateItems );
        }

        if ( !empty( $newItemIds ) )
        {
            // get rate formulated column
            $billItemRateFormulatedColumns = DoctrineQuery::create()
                ->select('x.relation_id, x.final_value')
                ->from('BillItemFormulatedColumn x')
                ->whereIn('x.relation_id', $newItemIds)
                ->andWhere('x.column_name = ?', BillItem::FORMULATED_COLUMN_RATE)
                ->fetchArray();

            foreach ( $billItemRateFormulatedColumns as $billItemRateFormulatedColumn )
            {
                $newBillItemRateFormulatedColumn[$billItemRateFormulatedColumn['relation_id']] = $billItemRateFormulatedColumn;
            }

            unset( $billItemRateFormulatedColumns );

            // get item(s) rate build up summary
            $billBuildUpRateSummaries = DoctrineQuery::create()
                ->from('BillBuildUpRateSummary i')
                ->leftJoin('i.UnitOfMeasurement uom')
                ->whereIn('i.bill_item_id', $newItemIds)
                ->fetchArray();

            foreach ( $billBuildUpRateSummaries as $billBuildUpRateSummary )
            {
                $newBillBuildUpRateSummary[$billBuildUpRateSummary['bill_item_id']] = $billBuildUpRateSummary;
            }

            unset( $billBuildUpRateSummaries );
        }

        return array( $billItems, $newResourceTrades, $newBuildUpRateItems, $newBillItemRateFormulatedColumn, $newBillBuildUpRateSummary );
    }

    public static function getScheduleOfQuantitiesTotalAmountByItemIdAndColumnSettingId($itemId, $billColumnSettingId, $type)
    {
        switch ($type)
        {
            case BillBuildUpQuantityItem::QUANTITY_PER_UNIT_ORIGINAL:
                break;
            case BillBuildUpQuantityItem::QUANTITY_PER_UNIT_REMEASUREMENT:
                break;
            default:
                throw new Exception("invalid quantity type");
        }

        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT COALESCE(SUM(xfc.final_value), 0) AS total FROM " . ScheduleOfQuantityItemFormulatedColumnTable::getInstance()->getTableName() . " xfc
            JOIN " . ScheduleOfQuantityBillItemXrefTable::getInstance()->getTableName() . " x ON x.schedule_of_quantity_item_id = xfc.relation_id WHERE
            x.bill_item_id = " . $itemId . " AND x.bill_column_setting_id = " . $billColumnSettingId . " AND x.type = " . $type . "
            AND xfc.final_value <> 0 AND xfc.deleted_at IS NULL GROUP BY x.bill_item_id");

        $stmt->execute();

        $result = $stmt->fetch(PDO::FETCH_ASSOC);

        return $result['total'];
    }

    public static function getFormulatedColumnsByItems(array $billItems)
    {
        $pdo               = self::getInstance()->getConnection()->getDbh();
        $formulatedColumns = array();
        $itemIds           = array();

        foreach ( $billItems as $billItem )
        {
            $itemIds[$billItem['id']] = $billItem['id'];

            unset( $billItem );
        }

        unset( $billItems );

        $stmt = $pdo->prepare("SELECT ifc.relation_id, ifc.column_name, ifc.final_value, ifc.value, ifc.linked, ifc.has_build_up
        FROM " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " ifc JOIN
        " . BillItemTable::getInstance()->getTableName() . " i ON i.id = ifc.relation_id
        WHERE ifc.relation_id IN (" . implode(',', $itemIds) . ") AND i.deleted_at IS NULL
        AND ifc.deleted_at IS NULL AND ifc.final_value <> 0");

        $stmt->execute();
        $itemFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ( $itemFormulatedColumns as $itemFormulatedColumn )
        {
            if ( !array_key_exists($itemFormulatedColumn['relation_id'], $formulatedColumns) )
            {
                $formulatedColumns[$itemFormulatedColumn['relation_id']] = array();
            }

            array_push($formulatedColumns[$itemFormulatedColumn['relation_id']], $itemFormulatedColumn);

            unset( $itemFormulatedColumn );
        }

        unset( $itemFormulatedColumns );

        return $formulatedColumns;
    }

    public static function getDataStructureForBillItemListBySelectedItemIds(ProjectStructure $bill, $itemIds)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $formulatedColumns                = array();
        $quantityPerUnitByColumns         = array();
        $billItemTypeReferences           = array();
        $billItemTypeRefFormulatedColumns = array();
        $elementIds                       = array();
        $elements                         = array();
        $newBillItems                     = array();
        $itemIds                          = json_decode($itemIds, true);

        if ( empty( $itemIds ) )
        {
            return array( $elements, $newBillItems, $formulatedColumns, $quantityPerUnitByColumns, $billItemTypeReferences, $billItemTypeRefFormulatedColumns );
        }

        $stmt = $pdo->prepare("SELECT DISTINCT p.id, p.element_id, p.description, p.type, p.priority, p.lft, p.level,
            p.grand_total_quantity, p.grand_total, p.bill_ref_element_no, p.bill_ref_page_no, p.bill_ref_char,
            uom.id AS uom_id, uom.symbol AS uom_symbol, p.note, p.project_revision_id, p.project_revision_deleted_at,
            r.version, pc.supply_rate AS pc_supply_rate, pc.wastage_percentage AS pc_wastage_percentage,
            pc.wastage_amount AS pc_wastage_amount, pc.labour_for_installation AS pc_labour_for_installation,
            pc.other_cost AS pc_other_cost, pc.profit_percentage AS pc_profit_percentage,
            pc.profit_amount AS pc_profit_amount, pc.total AS pc_total, e.priority as element_priority
            FROM " . BillItemTable::getInstance()->getTableName() . " i
            JOIN " . BillItemTable::getInstance()->getTableName() . " p
            ON (i.lft BETWEEN p.lft AND p.rgt AND p.project_revision_deleted_at IS NULL AND p.deleted_at IS NULL)
            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom ON (p.uom_id = uom.id AND uom.deleted_at IS NULL)
            LEFT JOIN " . BillItemPrimeCostRateTable::getInstance()->getTableName() . " pc ON (p.id = pc.bill_item_id)
            LEFT JOIN " . ProjectRevisionTable::getInstance()->getTableName() . " r ON (p.project_revision_id = r.id)
            LEFT JOIN " . BillElementTable::getInstance()->getTableName() . " e ON (p.element_id = e.id AND e.deleted_at IS NULL)
            WHERE i.id IN (" . implode(',', $itemIds) . ") AND e.project_structure_id = " . $bill->id . "
            AND i.root_id = p.root_id AND i.type <> " . BillItem::TYPE_HEADER . " AND i.project_revision_deleted_at IS NULL
            AND i.deleted_at IS NULL AND pc.deleted_at IS NULL AND r.deleted_at IS NULL
            ORDER BY element_priority, p.priority, p.lft, p.level");

        $stmt->execute();

        $billItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $stmt = $pdo->prepare("SELECT ifc.relation_id, ifc.column_name, ifc.final_value, ifc.value, ifc.linked, ifc.has_build_up
            FROM " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " ifc JOIN
            " . BillItemTable::getInstance()->getTableName() . " i ON i.id = ifc.relation_id
            WHERE i.id IN (" . implode(',', $itemIds) . ") AND i.deleted_at IS NULL
            AND ifc.deleted_at IS NULL AND ifc.final_value <> 0");

        $stmt->execute();

        $itemFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ( $itemFormulatedColumns as $itemFormulatedColumn )
        {
            if ( !array_key_exists($itemFormulatedColumn['relation_id'], $formulatedColumns) )
            {
                $formulatedColumns[$itemFormulatedColumn['relation_id']] = array();
            }

            array_push($formulatedColumns[$itemFormulatedColumn['relation_id']], $itemFormulatedColumn);

            unset( $itemFormulatedColumn );
        }

        unset( $itemFormulatedColumns );

        $billItemIds = Utilities::arrayValueRecursive('id', $billItems);

        if ( $billItems and is_array($billItemIds) and count($billItemIds) > 0 )
        {
            $implodedItemIds = implode(',', $billItemIds);

            foreach ( $bill->BillColumnSettings as $column )
            {
                $quantityFieldName = $column->use_original_quantity ? BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT : BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT;

                $stmt = $pdo->prepare("SELECT r.bill_item_id, COALESCE(fc.final_value, 0) AS value
                FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " fc
                JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " r ON fc.relation_id = r.id
                WHERE r.bill_item_id IN (" . $implodedItemIds . ") AND r.bill_column_setting_id = " . $column->id . "
                AND r.include IS TRUE AND fc.column_name = '" . $quantityFieldName . "' AND fc.final_value <> 0
                AND r.deleted_at IS NULL AND fc.deleted_at IS NULL");

                $stmt->execute();

                $quantities = $stmt->fetchAll(PDO::FETCH_COLUMN | PDO::FETCH_GROUP);

                $quantityPerUnitByColumns[$column->id] = $quantities;

                $stmt = $pdo->prepare("SELECT r.id, r.bill_item_id, r.include, r.total_quantity, r.quantity_per_unit_difference
                    FROM " . BillItemTypeReferenceTable::getInstance()->getTableName() . " r
                    WHERE r.bill_item_id IN (" . $implodedItemIds . ") AND r.bill_column_setting_id = " . $column->id . "
                    AND r.deleted_at IS NULL");

                $stmt->execute();

                $billItemTypeRefs = $stmt->fetchAll(PDO::FETCH_ASSOC);

                $billItemTypeRefIds = count($billItemTypeRefs) > 0 ? new SplFixedArray(count($billItemTypeRefs)) : null;

                foreach ( $billItemTypeRefs as $idx => $billItemTypeReference )
                {
                    if ( !array_key_exists($column->id, $billItemTypeReferences) )
                    {
                        $billItemTypeReferences[$column->id] = array();
                    }

                    $billItemTypeReferences[$column->id][$billItemTypeReference['bill_item_id']] = $billItemTypeReference;

                    $billItemTypeRefIds[$idx] = $billItemTypeReference['id'];
                }

                if ( $billItemTypeRefIds instanceof SplFixedArray )
                {
                    $stmt = $pdo->prepare("SELECT fc.relation_id, fc.value, fc.final_value, fc.column_name, fc.linked, fc.has_build_up FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " fc
                        WHERE fc.relation_id IN (" . implode(',', $billItemTypeRefIds->toArray()) . ") AND fc.deleted_at IS NULL");

                    $stmt->execute();

                    $billItemTypeRefFormulatedColumnFetch = $stmt->fetchAll(PDO::FETCH_ASSOC);

                    foreach ( $billItemTypeRefFormulatedColumnFetch as $fc )
                    {
                        if ( !array_key_exists($fc['relation_id'], $billItemTypeRefFormulatedColumns) )
                        {
                            $billItemTypeRefFormulatedColumns[$fc['relation_id']] = array();
                        }

                        array_push($billItemTypeRefFormulatedColumns[$fc['relation_id']], $fc);

                        unset( $fc );
                    }

                    unset( $billItemTypeRefFormulatedColumnFetch );
                }

                unset( $billItemTypeRefs );
            }
        }

        foreach ( $billItems as $billItem )
        {
            $elementId = $billItem['element_id'];

            $elementIds[$elementId] = $elementId;

            $newBillItems[$elementId][] = $billItem;
        }

        unset( $billItems );

        $elements = BillElementTable::getElementsByElementIds($elementIds);

        return array( $elements, $newBillItems, $formulatedColumns, $quantityPerUnitByColumns, $billItemTypeReferences, $billItemTypeRefFormulatedColumns );
    }

    public static function getItemRatesByElementIds(array $elements)
    {
        $data       = array();
        $elementIds = array();

        if ( empty( $elements ) )
        {
            return $data;
        }

        foreach ( $elements as $element )
        {
            $elementIds[] = $element['id'];
        }

        $itemRates = DoctrineQuery::create()
            ->select('i.id as item_id, c.final_value as rate')
            ->from('BillItemFormulatedColumn c')
            ->leftJoin('c.BillItem i')
            ->whereIn('i.element_id', $elementIds)
            ->andWhere('c.column_name = ?', BillItem::FORMULATED_COLUMN_RATE)
            ->fetchArray();

        foreach ( $itemRates as $itemRate )
        {
            $data[$itemRate['item_id']] = $itemRate['rate'];
        }

        return $data;
    }

    public static function getAllBillItemsIncludingDeleted($itemIds, $bill)
    {
        if( count($itemIds) == 0 )
        {
            return array();
        }

        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT DISTINCT p.id, p.element_id, p.description, p.type, p.priority, p.lft, p.level,
            p.grand_total_quantity, p.grand_total, p.bill_ref_element_no, p.bill_ref_page_no, p.bill_ref_char,
            uom.id AS uom_id, uom.symbol AS uom_symbol, p.note, p.project_revision_id, p.project_revision_deleted_at,
            r.version, pc.supply_rate AS pc_supply_rate, pc.wastage_percentage AS pc_wastage_percentage,
            pc.wastage_amount AS pc_wastage_amount, pc.labour_for_installation AS pc_labour_for_installation,
            pc.other_cost AS pc_other_cost, pc.profit_percentage AS pc_profit_percentage,
            pc.profit_amount AS pc_profit_amount, pc.total AS pc_total, e.priority as element_priority
            FROM " . BillItemTable::getInstance()->getTableName() . " i
            JOIN " . BillItemTable::getInstance()->getTableName() . " p
            ON (i.lft BETWEEN p.lft AND p.rgt)
            LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom ON (p.uom_id = uom.id AND uom.deleted_at IS NULL)
            LEFT JOIN " . BillItemPrimeCostRateTable::getInstance()->getTableName() . " pc ON (p.id = pc.bill_item_id)
            LEFT JOIN " . ProjectRevisionTable::getInstance()->getTableName() . " r ON (p.project_revision_id = r.id)
            LEFT JOIN " . BillElementTable::getInstance()->getTableName() . " e ON (p.element_id = e.id AND e.deleted_at IS NULL)
            WHERE i.id IN (" . implode(',', $itemIds) . ") AND e.project_structure_id = " . $bill->id . "
            AND i.root_id = p.root_id AND i.type <> " . BillItem::TYPE_HEADER . "
            ORDER BY element_priority, p.priority, p.lft, p.level");

        $stmt->execute();

        $billItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $newBillItems = array();

        foreach ( $billItems as $billItem )
        {
            $newBillItems[$billItem['element_id']][] = $billItem;
        }

        return $newBillItems;
    }

    public static function getBillRef($billItem)
    {
        if( ( $billItem['type'] != BillItem::TYPE_HEADER && $billItem['type'] != BillItem::TYPE_HEADER_N && $billItem['type'] != BillItem::TYPE_NOID ) )
        {
            return $billItem['bill_ref_element_no'] . '/' . $billItem['bill_ref_page_no'] . ' ' . $billItem['bill_ref_char'];
        }

        return null;
    }

    public static function getBillItemResourceRates($billItemIds)
    {
        $billItems = array();

        if(is_array($billItemIds) && !empty($billItemIds))
        {
            $pdo = self::getInstance()->getConnection()->getDbh();

            $stmt = $pdo->prepare("SELECT DISTINCT sorifc.relation_id AS schedule_of_rate_item_id, i.id, i.description, i.grand_total, i.grand_total_after_markup, i.grand_total_quantity, s.markup, s.apply_conversion_factor,
            s.conversion_factor_amount, s.conversion_factor_operator, br.id AS bill_build_up_rate_resource_id, r.name AS resource_name
            FROM ".BillItemTable::getInstance()->getTableName()." i
            JOIN ".BillItemFormulatedColumnTable::getInstance()->getTableName()." fc ON fc.relation_id = i.id
            JOIN ".ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName()." sorifc ON fc.schedule_of_rate_item_formulated_column_id = sorifc.id
            JOIN ".BillBuildUpRateSummaryTable::getInstance()->getTableName()." s ON s.bill_item_id = fc.relation_id
            JOIN ".BillBuildUpRateResourceTable::getInstance()->getTableName()." br ON br.bill_item_id = s.bill_Item_id
            JOIN ".ResourceTable::getInstance()->getTableName()." r ON br.resource_library_id = r.id
            WHERE i.id IN (".implode(',', $billItemIds).") AND i.type <> ".BillItem::TYPE_HEADER."
            AND i.deleted_at IS NULL AND i.project_revision_deleted_at IS NULL AND fc.deleted_at IS NULL AND sorifc.deleted_at IS NULL
            AND br.deleted_at IS NULL AND r.deleted_at IS NULL AND s.deleted_at IS NULL ORDER BY br.id ASC");

            $stmt->execute();

            $records = $stmt->fetchAll(PDO::FETCH_ASSOC);

            foreach($records as $record)
            {
                $conversionFactor         = ($record['apply_conversion_factor']) ? $record['conversion_factor_amount'] : 1;
                $conversionFactorOperator = $record['conversion_factor_operator'];
                $applyConversionFactor    = $record['apply_conversion_factor'];

                if(!array_key_exists($record['id'], $billItems))
                {
                    $billItems[$record['id']] = array(
                        'schedule_of_rate_item_id'   => $record['schedule_of_rate_item_id'],
                        'apply_conversion_factor'    => $applyConversionFactor,
                        'conversion_factor_amount'   => $conversionFactor,
                        'conversion_factor_operator' => $conversionFactorOperator,
                        'markup'                     => $record['markup'],
                        'grand_total_quantity'       => $record['grand_total_quantity'],
                        'grand_total_after_markup'   => $record['grand_total_after_markup'],
                        'grand_total'                => $record['grand_total'],
                        'profitRates' => array(
                            'rate'  => 0,
                            'total' => 0
                        )
                    );
                }

                $resourceRate        = 0;
                $resourceWastageRate = 0;

                foreach(self::getBuildUpRateItemList($record['id'], $record['bill_build_up_rate_resource_id']) as $item)
                {
                    $resourceRate += $item['total'];
                    $resourceWastageRate += $item['wastage-rate'];
                }

                if($applyConversionFactor)
                {
                    $exp = $resourceRate.$conversionFactorOperator.$conversionFactor;

                    $evaluator = new EvalMath(true, true);
                    $evaluator->suppress_errors = true;
                    $evaluatedValue = $evaluator->evaluate($exp);

                    $resourceRate = $evaluatedValue ? $evaluatedValue : 0;

                    $exp = $resourceWastageRate.$conversionFactorOperator.$conversionFactor;

                    $evaluator = new EvalMath(true, true);
                    $evaluator->suppress_errors = true;
                    $evaluatedValue = $evaluator->evaluate($exp);

                    $resourceWastageRate = $evaluatedValue ? $evaluatedValue : 0;
                }

                $billItems[$record['id']]['resourceRates'][ $record['resource_name'] ]['rate']         = $resourceRate;
                $billItems[$record['id']]['resourceRates'][ $record['resource_name'] ]['wastageRate']  = $resourceWastageRate;
                $billItems[$record['id']]['resourceRates'][ $record['resource_name'] ]['total']        = $resourceRate * $record['grand_total_quantity'];
                $billItems[$record['id']]['resourceRates'][ $record['resource_name'] ]['wastageTotal'] = $resourceWastageRate * $record['grand_total_quantity'];
            }

            foreach($billItems as $id => &$billItem)
            {
                $total = 0;

                foreach($billItem['resourceRates'] as $billItemResourceRates)
                {
                    $total += $billItemResourceRates['total'] + $billItemResourceRates['wastageTotal'];
                }

                if($billItem['grand_total_quantity'] != 0)
                {
                    $billItem['profitRates']['total'] = $billItem['grand_total'] - $total;
                    $billItem['profitRates']['rate'] = $billItem['profitRates']['total'] / $billItem['grand_total_quantity'];
                }
            }

        }

        return $billItems;
    }

    public static function getBuildUpRateItemList($billItemId, $billBuildUpRateResourceId)
    {
        $items = DoctrineQuery::create()->select('i.id, i.description, i.uom_id, uom.symbol, i.resource_item_library_id, ifc.final_value, ifc.value, ifc.column_name, ifc.linked')
            ->leftJoin('BillBuildUpRateItem i')
            ->leftJoin('i.UnitOfMeasurement uom')
            ->leftJoin('i.FormulatedColumns ifc')
            ->where('i.bill_item_id = ?', $billItemId)
            ->andWhere('i.build_up_rate_resource_id = ?', $billBuildUpRateResourceId)
            ->andWhere('ifc.deleted_at IS NULL')
            ->addOrderBy('i.priority ASC')
            ->fetchArray();

        $formulatedColumnConstants = Utilities::getAllFormulatedColumnConstants('BillBuildUpRateItem');

        foreach($items as &$item)
        {
            $item['uom_id']      = $item['uom_id'] > 0 ? (string)$item['uom_id'] : '-1';
            $item['uom_symbol']  = $item['uom_id'] > 0 ? $item['UnitOfMeasurement']['symbol'] : '';
            $item['relation_id'] = $billItemId;
            $item['linked']      = $item['resource_item_library_id'] > 0 ? true : false;

            foreach($formulatedColumnConstants as $constant)
            {
                $item[ $constant . '-final_value' ] = 0;
                $item[ $constant . '-value' ]       = "";
                $item[ $constant . '-linked' ]      = false;
                $item[ $constant . '-has_formula' ] = false;
            }

            foreach($item['FormulatedColumns'] as $formulatedColumn)
            {
                $columnName                           = $formulatedColumn['column_name'];
                $item[ $columnName . '-final_value' ] = $formulatedColumn['final_value'];
                $item[ $columnName . '-value' ]       = $formulatedColumn['value'];
                $item[ $columnName . '-has_formula' ] = false;

                if( $columnName == BillBuildUpRateItem::FORMULATED_COLUMN_RATE or $columnName == BillBuildUpRateItem::FORMULATED_COLUMN_WASTAGE or $columnName == BillBuildUpRateItem::FORMULATED_COLUMN_CONSTANT )
                {
                    $item[ $columnName . '-linked' ] = $formulatedColumn['linked'];
                }
            }

            $item['total']      = BillBuildUpRateItemTable::calculateTotalById($item['id']);
            $item['line_total'] = BillBuildUpRateItemTable::calculateLineTotalById($item['id']);

            $item['wastage-rate'] = isset( $item['wastage-final_value'] ) ? ( $item['wastage-final_value'] * $item['total'] /100 ) : 0;

            unset( $item['FormulatedColumns'], $item['UnitOfMeasurement'] );
        }

        return $items;
    }

    public static function getProfitFromBillMarkupByScheduleOfRateItem(Array $billItemIds, $scheduleOfRateItemId)
    {
        $data = array();

        if(!empty($billItemIds))
        {
            $pdo = self::getInstance()->getConnection()->getDbh();

            $stmt = $pdo->prepare("SELECT DISTINCT i.id, (i.grand_total_after_markup - i.grand_total) AS value, i.priority, i.root_id, i.lft, i.level
            FROM ".BillMarkupSettingTable::getInstance()->getTableName()." m
            JOIN ".BillElementTable::getInstance()->getTableName()." e ON m.project_structure_id = e.project_structure_id
            JOIN ".BillItemTable::getInstance()->getTableName()." i ON i.element_id = e.id
            JOIN ".BillItemFormulatedColumnTable::getInstance()->getTableName()." f ON i.id = f.relation_id
            JOIN ".ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName()." sf ON sf.id = schedule_of_rate_item_formulated_column_id
            JOIN ".ScheduleOfRateItemTable::getInstance()->getTableName()." si ON si.id = sf.relation_id
            WHERE i.id IN (" . implode(',', $billItemIds) . ") AND si.id = ".$scheduleOfRateItemId."
            AND (m.element_markup_enabled IS TRUE OR m.item_markup_enabled IS TRUE) AND i.type <> " . BillItem::TYPE_HEADER . "
            AND f.column_name = '".BillItem::FORMULATED_COLUMN_RATE."'
            AND si.deleted_at IS NULL AND sf.deleted_at IS NULL AND f.deleted_at IS NULL
            AND i.deleted_at IS NULL AND i.project_revision_deleted_at IS NULL
            AND e.deleted_at IS NULL AND m.deleted_at IS NULL ORDER BY i.priority, i.root_id, i.lft, i.level");

            $stmt->execute();

            $records = $stmt->fetchAll(PDO::FETCH_ASSOC);

            if(!empty($records))
            {
                $data = array(
                    $scheduleOfRateItemId => 0
                );

                foreach($records as $record)
                {
                    $data[ $scheduleOfRateItemId ] += $record['value'];
                }
            }
        }

        return $data;
    }

    public static function getOriginBillItems(array $billItemIds)
    {
        $data = [];

        if(empty($billItemIds))
        {
            return $data;
        }

        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT DISTINCT i.id, i.tender_origin_id
            FROM " . BillItemTable::getInstance()->getTableName() . " i
            WHERE i.id IN (" . implode(',', $billItemIds) . ")
            AND i.deleted_at IS NULL");

        $stmt->execute();

        $records = $stmt->fetchAll(PDO::FETCH_ASSOC);
        
        foreach($records as $record)
        {
            $originInfo = ProjectStructureTable::extractOriginId($record['tender_origin_id']);

            $data[ $record['id'] ] = null;
            $originBillItemId = $originInfo['origin_id'];

            if(sfConfig::get('app_register_buildspace_id') !== $originInfo['buildspace_id']) continue;

            $stmt = $pdo->prepare("SELECT DISTINCT i.id, i.*
                FROM " . BillItemTable::getInstance()->getTableName() . " i
                WHERE i.id = {$originBillItemId}
                AND i.deleted_at IS NULL
                LIMIT 1");

            $stmt->execute();

            $originalBillItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

            $stmt = $pdo->prepare("SELECT DISTINCT ref.id, ref.bill_column_setting_id
                FROM " . BillItemTable::getInstance()->getTableName() . " i
                JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " ref on ref.bill_item_id = i.id
                WHERE i.id = {$originBillItemId}
                AND i.deleted_at IS NULL");

            $stmt->execute();

            $originalBillColumnSettings = $stmt->fetchAll(PDO::FETCH_KEY_PAIR);

            $data[ $record['id'] ] = ( $originalBillItem = $originalBillItems[0] ?? null );

            if( ! $originalBillItem ) continue;

            foreach($originalBillColumnSettings as $originalRefId => $originalBillColumnSettingId)
            {
                $stmt = $pdo->prepare("SELECT DISTINCT reffc.*, ref.bill_column_setting_id
                FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " reffc
                JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " ref on ref.id = reffc.relation_id
                WHERE reffc.relation_id = {$originalRefId}
                AND reffc.deleted_at IS NULL");

                $stmt->execute();

                foreach($stmt->fetchAll(PDO::FETCH_ASSOC) as $formulatedColumn)
                {
                    $data[ $record['id'] ]['ref_formulated_columns'][] = $formulatedColumn;
                }
            }
        }

        return $data;
    }

    public static function getOmittedAtVariationOrders(array $billItemIds, $typeRefCount)
    {
        if( empty( $billItemIds ) ) return array();
        
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT i.id AS bill_item_id, vo.id as vo_id, vo.description
            FROM " . VariationOrderItemTable::getInstance()->getTableName() . " voi
            JOIN " . VariationOrderTable::getInstance()->getTableName() . " vo ON voi.variation_order_id = vo.id
            JOIN " . PostContractTable::getInstance()->getTableName() . " pc ON pc.project_structure_id = vo.project_structure_id
            JOIN " . VariationOrderItemUnitTable::getInstance()->getTableName() . " u ON u.variation_order_item_id = voi.id
            JOIN " . PostContractStandardClaimTypeReferenceTable::getInstance()->getTableName() . " ref ON ref.id = u.type_reference_id AND ref.post_contract_id = pc.id
            JOIN " . BillItemTable::getInstance()->getTableName() . " i ON voi.bill_item_id = i.id
            WHERE i.type != " . BillItem::TYPE_HEADER . " and i.type != " . BillItem::TYPE_HEADER_N . "
            AND i.id in (" . implode(',', $billItemIds) . ")
            AND ref.counter = {$typeRefCount}");

        $stmt->execute();

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * checks if there are any items linked with a particular unit of measurement
     * where the element or bill is deleted
     * @param mixed $uomId
     * @return bool
     */
    public static function hasDanglingUnitOfMeasurement($uomId)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $query = "SELECT bi.id AS item_id
            FROM bs_bill_items bi
            INNER JOIN bs_bill_elements be ON be.id = bi.element_id 
            INNER JOIN bs_project_structures bill ON bill.id = be.project_structure_id 
            WHERE bi.deleted_at IS NULL
            AND be.deleted_at IS NULL
            AND bill.deleted_at IS NULL
            AND bi.uom_id = {$uomId};";

        $stmt = $pdo->prepare($query);
        $stmt->execute();

        $records = $stmt->fetchAll(PDO::FETCH_COLUMN);

        return count($records) > 0;
    }
}