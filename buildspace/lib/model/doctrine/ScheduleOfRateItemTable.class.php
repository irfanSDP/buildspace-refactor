<?php

/**
 * ScheduleOfRateItemTable
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class ScheduleOfRateItemTable extends Doctrine_Table
{
    private $importedBillItemsChildren = array();

    /**
     * Returns an instance of this class.
     *
     * @return object ScheduleOfRateItemTable
     */
    public static function getInstance()
    {
        return Doctrine_Core::getTable('ScheduleOfRateItem');
    }

    public static function updateTimestamp(ScheduleOfRateItem $item)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("UPDATE ".ScheduleOfRateItemTable::getInstance()->getTableName()." SET updated_at = NOW() WHERE id = ".$item->id." AND deleted_at IS NULL");
        $stmt->execute(array());

        $stmt = $pdo->prepare("UPDATE ".ScheduleOfRateTradeTable::getInstance()->getTableName()." SET updated_at = NOW() WHERE id = ".$item->trade_id." AND deleted_at IS NULL");
        $stmt->execute(array());
    }

    public static function createItemFromLastRow($previousItem, $tradeId, $fieldName=null, $fieldValue=null)
    {
        $formulatedColumnConstants = Utilities::getAllFormulatedColumnConstants('ScheduleOfRateItem');

        $item = new ScheduleOfRateItem();

        $item->trade_id = $tradeId;
        if($fieldName)
        {
            if(!in_array($fieldName, $formulatedColumnConstants))
            {
                $item->{'set'.sfInflector::camelize($fieldName)}($fieldValue);
            }
        }

        if($fieldName != 'type')
        {
            $item->type = ScheduleOfRateItem::TYPE_WORK_ITEM;
        }

        $asRoot = true;
        $priority = 0;

        if($previousItem)
        {
            if($previousItem->node->isRoot())
            {
                $priority = $previousItem->priority + 1;
            }
            else
            {
                $asRoot = false;
                $item->node->insertAsNextSiblingOf($previousItem);

                $priority = $previousItem->priority;
            }
        }

        $item->priority = $priority;
        $item->save();

        if($asRoot)
        {
            $item->getTable()->getTree()->createRoot($item);

            $item->updateRootPriority($priority, $item->id);
        }

        return $item;
    }

    public static function createItem(ScheduleOfRateItem $nextItem, $tradeId)
    {
        $item = new ScheduleOfRateItem();

        $item->trade_id = $tradeId;
        $item->type = ScheduleOfRateItem::TYPE_WORK_ITEM;

        if($nextItem->node->isRoot())
        {
            $priority = $nextItem->priority;

            $item->priority = $priority;

            $item->save();

            $node = $item->node;

            if ($node->isValidNode())
            {
                $node->makeRoot($item->id);
            }
            else
            {
                $item->getTable()->getTree()->createRoot($item);
            }

            $item->updateRootPriority($priority, $item->id);
        }
        else
        {
            $item->node->insertAsPrevSiblingOf($nextItem);
            $item->priority = $nextItem->priority;
        }

        $item->save();

        return $item;
    }

    public static function getFormulatedColumnByRelationIdAndColumnName($id, $columnName, $hydrate=null)
    {
        $query = DoctrineQuery::create()->select('*')
            ->from('ScheduleOfRateItemFormulatedColumn c')
            ->where('c.relation_id = ?', $id)
            ->andWhere('c.column_name = ?', $columnName)
            ->limit(1);

        if(!is_null($hydrate))
        {
            $query->setHydrationMode($hydrate);
        }

        return $query->fetchOne();
    }

    public static function deleteBuildUpRatesByScheduleOfRateItemId($scheduleOfRateItemId, Doctrine_Connection $con = null)
    {
        $con = $con ? $con : self::getInstance()->getConnection();

        $con->fetchAssoc("UPDATE ".ScheduleOfRateBuildUpRateResourceTable::getInstance()->getTableName()." SET deleted_at = NOW() WHERE
        schedule_of_rate_item_id = ".$scheduleOfRateItemId." AND deleted_at IS NULL");


        $formulatedColumnIds = $con->fetchAssoc("UPDATE ".ScheduleOfRateBuildUpRateFormulatedColumnTable::getInstance()->getTableName()." SET deleted_at = NOW() WHERE
        relation_id IN (SELECT id FROM ".ScheduleOfRateBuildUpRateItemTable::getInstance()->getTableName()." WHERE schedule_of_rate_item_id = ".$scheduleOfRateItemId." AND deleted_at IS NULL) RETURNING id");

        $idList = array();

        foreach($formulatedColumnIds as $formulatedColumnId)
        {
            if(array_key_exists('id', $formulatedColumnId))
            {
                $idList[] = $formulatedColumnId['id'];
            }
        }

        if(count($idList) > 0)
        {
            //now we can remove all edges after we've updated related nodes
            Doctrine_Query::create()
                ->delete('ScheduleOfRateBuildUpRateEdge e')
                ->whereIn('e.node_from', $idList)
                ->execute();

            Doctrine_Query::create()
                ->delete('ScheduleOfRateBuildUpRateEdge e')
                ->whereIn('e.node_to', $idList)
                ->execute();
        }

        Doctrine_Query::create()
            ->delete('ScheduleOfRateBuildUpRateItem i')
            ->where('i.schedule_of_rate_item_id = ?', $scheduleOfRateItemId)
            ->execute();

        Doctrine_Query::create()
            ->delete('ScheduleOfRateBuildUpRateSummary s')
            ->where('s.schedule_of_rate_item_id = ?', $scheduleOfRateItemId)
            ->execute();

        Doctrine_Query::create()->update('ScheduleOfRateItemFormulatedColumn c')
            ->set('c.has_build_up', 'FALSE')
            ->where('c.relation_id = ?', $scheduleOfRateItemId)
            ->andWhere('c.column_name = ?', BillItem::FORMULATED_COLUMN_RATE)
            ->andWhere('deleted_at IS NULL')
            ->execute();

        Doctrine_Query::create()
            ->update('ScheduleOfRateItem')
            ->set('recalculate_resources_library_status', '?', false)
            ->where('id = ?', $scheduleOfRateItemId)
            ->andWhere('recalculate_resources_library_status IS TRUE')
            ->execute();

        // check for existing records under the same trade that has been flagged as recalculated
        // if all records has been recalculate then update the trade recalculate status to false
        $pdo = $con->getDbh();

        $stmt = $pdo->prepare( "SELECT COUNT(id) FROM ".self::getInstance()->getTableName()."
            WHERE trade_id = (SELECT trade_id FROM ".self::getInstance()->getTableName()." WHERE id = ".$scheduleOfRateItemId.")
            AND recalculate_resources_library_status IS TRUE AND deleted_at IS NULL GROUP BY trade_id");

        $stmt->execute();

        $result = $stmt->fetchColumn(0);

        if(!$result)
        {
            $stmt = $pdo->prepare("UPDATE ".ScheduleOfRateTradeTable::getInstance()->getTableName()."
                SET recalculate_resources_library_status = FALSE
                WHERE id = (SELECT trade_id FROM ".self::getInstance()->getTableName()." WHERE id = ".$scheduleOfRateItemId.")
                AND recalculate_resources_library_status IS TRUE");

            $stmt->execute();
        }
    }

    public static function calculateTotalCostForAnalysis($id, $projectId)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare( "SELECT COALESCE(SUM(bi.grand_total_quantity), 0) AS total_quantity, COALESCE(SUM(bi.grand_total), 0) AS total_cost FROM
            ".ScheduleOfRateItemTable::getInstance()->getTableName()." AS i JOIN
            ".ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName()." AS ifc ON i.id = ifc.relation_id JOIN
            ".BillItemFormulatedColumnTable::getInstance()->getTableName()." AS bifc ON ifc.id = bifc.schedule_of_rate_item_formulated_column_id JOIN
            ".BillItemTable::getInstance()->getTableName()." AS bi ON bifc.relation_id = bi.id JOIN
            ".BillElementTable::getInstance()->getTableName()." AS be ON bi.element_id = be.id JOIN
            ".ProjectStructureTable::getInstance()->getTableName()." AS s ON be.project_structure_id = s.id
            WHERE i.id = ".$id." AND s.root_id = ".$projectId." AND bifc.column_name = '".BillItem::FORMULATED_COLUMN_RATE."'
            AND bifc.schedule_of_rate_item_formulated_column_id IS NOT NULL
            AND i.deleted_at IS NULL
            AND ifc.deleted_at IS NULL AND bifc.deleted_at IS NULL AND bi.deleted_at IS NULL AND bi.project_revision_deleted_at IS NULL
            AND be.deleted_at IS NULL AND s.deleted_at IS NULL");

        $stmt->execute();

        $result = $stmt->fetch(PDO::FETCH_ASSOC);

        return array($result['total_quantity'], $result['total_cost']);
    }

    public static function calculateTotalCostForAnalysisByScheduleOfRateItemIds(Array $ids, ProjectStructure $project)
    {
        $result = array();

        if(!empty($ids))
        {
            $pdo = self::getInstance()->getConnection()->getDbh();

            $stmt = $pdo->prepare( "SELECT ifc.relation_id AS id, COALESCE(SUM(bi.grand_total_quantity), 0) AS total_quantity, COALESCE(SUM(bi.grand_total), 0) AS total_cost
            FROM ".ScheduleOfRateItemTable::getInstance()->getTableName()." AS i
            JOIN ".ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName()." AS ifc ON i.id = ifc.relation_id
            JOIN ".BillItemFormulatedColumnTable::getInstance()->getTableName()." AS bifc ON ifc.id = bifc.schedule_of_rate_item_formulated_column_id
            JOIN ".BillItemTable::getInstance()->getTableName()." AS bi ON bifc.relation_id = bi.id
            JOIN ".BillElementTable::getInstance()->getTableName()." AS be ON bi.element_id = be.id
            JOIN ".ProjectStructureTable::getInstance()->getTableName()." AS s ON be.project_structure_id = s.id
            WHERE i.id IN (".implode(',', $ids).") AND s.root_id = ".$project->id." AND bifc.column_name = '".BillItem::FORMULATED_COLUMN_RATE."'
            AND bifc.schedule_of_rate_item_formulated_column_id IS NOT NULL AND i.deleted_at IS NULL
            AND ifc.deleted_at IS NULL AND bifc.deleted_at IS NULL AND bi.deleted_at IS NULL AND bi.project_revision_deleted_at IS NULL
            AND be.deleted_at IS NULL AND s.deleted_at IS NULL GROUP BY ifc.relation_id");

            $stmt->execute();

            $result = $stmt->fetchAll(PDO::FETCH_ASSOC);
        }

        return $result;
    }

    public static function getScheduleOfItemRatesByProject(Array $scheduleOfRateItemIds, ProjectStructure $project)
    {
        $result = array();

        if(!empty($scheduleOfRateItemIds))
        {
            $pdo = self::getInstance()->getConnection()->getDbh();

            $stmt = $pdo->prepare("SELECT DISTINCT sorifc.relation_id AS id, COALESCE(ifc.final_value, 0) AS value
            FROM " . ProjectStructureTable::getInstance()->getTableName() . " AS s
            JOIN " . BillElementTable::getInstance()->getTableName() . " AS be ON be.project_structure_id = s.id
            JOIN " . BillItemTable::getInstance()->getTableName() . " AS bi ON bi.element_id = be.id
            JOIN " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " ifc ON ifc.relation_id = bi.id
            JOIN " . ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName() . " AS sorifc
            ON ifc.schedule_of_rate_item_formulated_column_id = sorifc.id
            WHERE s.root_id = " . $project->id . " AND sorifc.relation_id IN (" . implode(',', $scheduleOfRateItemIds) . ") AND ifc.column_name = '" . BillItem::FORMULATED_COLUMN_RATE . "'
            AND s.deleted_at IS NULL AND be.deleted_at IS NULL AND bi.project_revision_deleted_at IS NULL AND bi.deleted_at IS NULL
            AND ifc.deleted_at IS NULL AND sorifc.deleted_at IS NULL");

            $stmt->execute();

            $records = $stmt->fetchAll(PDO::FETCH_ASSOC);

            foreach($records as $record)
            {
                if(!array_key_exists($record['id'], $result))
                {
                    $result[$record['id']] = array(
                        'multi-rate'       => false,
                        'rate-value'       => $record['value'],
                        'rate-final_value' => $record['value']
                    );
                }

                if(array_key_exists($record['id'], $result) and $result[$record['id']]['rate-value'] != $record['value'] and !$result[$record['id']]['multi-rate'])
                {
                    $result[$record['id']]['multi-rate']       = true;
                    $result[$record['id']]['rate-value']       = 0;
                    $result[$record['id']]['rate-final_value'] = 0;
                }
            }
        }

        return $result;
    }

    public static function calculateTotalCostForAnalysisWithSelectedTendererRates($id, $projectId, $companyId)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT COALESCE(SUM(bi.grand_total_quantity), 0) AS total_quantity, COALESCE(SUM(r.grand_total), 0) AS total_cost FROM
            ".ScheduleOfRateItemTable::getInstance()->getTableName()." AS i JOIN
            ".ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName()." AS ifc ON i.id = ifc.relation_id JOIN
            ".BillItemFormulatedColumnTable::getInstance()->getTableName()." AS bifc ON ifc.id = bifc.schedule_of_rate_item_formulated_column_id JOIN
            ".BillItemTable::getInstance()->getTableName()." AS bi ON bifc.relation_id = bi.id JOIN
            ".TenderBillItemRateTable::getInstance()->getTableName()." r ON r.bill_item_id = bi.id JOIN
            ".BillElementTable::getInstance()->getTableName()." AS be ON bi.element_id = be.id JOIN
            ".ProjectStructureTable::getInstance()->getTableName()." AS s ON be.project_structure_id = s.id JOIN
            ".TenderCompanyTable::getInstance()->getTableName()." tc ON r.tender_company_id = tc.id AND tc.project_structure_id = s.root_id
            WHERE i.id = ".$id." AND s.root_id = ".$projectId." AND bifc.column_name = '".BillItem::FORMULATED_COLUMN_RATE."'
            AND tc.company_id = ".$companyId." AND bifc.schedule_of_rate_item_formulated_column_id IS NOT NULL
            AND i.deleted_at IS NULL
            AND ifc.deleted_at IS NULL AND bifc.deleted_at IS NULL AND bi.deleted_at IS NULL AND bi.project_revision_deleted_at IS NULL
            AND be.deleted_at IS NULL AND s.deleted_at IS NULL");

        $stmt->execute();

        $result = $stmt->fetch(PDO::FETCH_ASSOC);

        return array($result['total_quantity'], $result['total_cost']);
    }

    public static function getAffectedBillItemsByScheduleOfRateItemIds(ProjectStructure $project, array $sorItemIds)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT DISTINCT p.id, ifc.relation_id AS sor_item_id, p.root_id, p.level, p.priority, e.priority AS element_priority, p.lft
        FROM ".BillItemTable::getInstance()->getTableName()." c
        JOIN ".BillItemTable::getInstance()->getTableName()." p ON c.lft BETWEEN p.lft AND p.rgt
        JOIN ".BillItemFormulatedColumnTable::getInstance()->getTableName()." AS bifc ON c.id = bifc.relation_id
        JOIN ".ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName()." AS ifc ON bifc.schedule_of_rate_item_formulated_column_id = ifc.id
        JOIN ".BillElementTable::getInstance()->getTableName()." AS e ON p.element_id = e.id
        JOIN ".ProjectStructureTable::getInstance()->getTableName()." AS s ON e.project_structure_id = s.id
        WHERE s.root_id = ".$project->id." AND c.root_id = p.root_id AND c.element_id = p.element_id
        AND ifc.relation_id IN (".implode(',', $sorItemIds).") AND bifc.column_name = '".BillItem::FORMULATED_COLUMN_RATE."'
        AND c.project_revision_deleted_at IS NULL AND c.deleted_at IS NULL
        AND p.project_revision_deleted_at IS NULL AND p.deleted_at IS NULL
        AND e.deleted_at IS NULL AND ifc.deleted_at IS NULL AND bifc.deleted_at IS NULL AND s.deleted_at IS NULL
        ORDER BY e.priority, p.priority, p.lft, p.level ASC");

        $stmt->execute();

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public static function getAffectedScheduleOfRateBillItemsByBillItemIds(ProjectStructure $project, array $itemIds)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT DISTINCT c.id, ifc.relation_id AS sor_item_id, c.root_id, c.level, c.priority, e.priority AS element_priority, c.lft
        FROM ".BillItemTable::getInstance()->getTableName()." c
        JOIN ".BillItemFormulatedColumnTable::getInstance()->getTableName()." AS bifc ON c.id = bifc.relation_id
        JOIN ".ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName()." AS ifc ON bifc.schedule_of_rate_item_formulated_column_id = ifc.id
        JOIN ".BillElementTable::getInstance()->getTableName()." AS e ON c.element_id = e.id
        JOIN ".ProjectStructureTable::getInstance()->getTableName()." AS s ON e.project_structure_id = s.id
        WHERE s.root_id = ".$project->id." AND c.id IN (".implode(',', $itemIds).") AND c.root_id = c.root_id AND c.element_id = c.element_id
        AND bifc.column_name = '".BillItem::FORMULATED_COLUMN_RATE."'
        AND c.project_revision_deleted_at IS NULL AND c.deleted_at IS NULL
        AND e.deleted_at IS NULL AND ifc.deleted_at IS NULL AND bifc.deleted_at IS NULL AND s.deleted_at IS NULL
        ORDER BY e.priority, c.priority, c.lft, c.level ASC");

        $stmt->execute();

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public static function getSelectedItemsByItemIds(ScheduleOfRate $scheduleOfRate, array $itemIds)
    {
        $pdo               = self::getInstance()->getConnection()->getDbh();
        $newItemIds        = array();
        $tradeIds          = array();
        $newItems          = array();
        $formulatedColumns = array();

        if ( empty($itemIds) )
        {
            return array(array(), array(), array());
        }

        // will get selected item(s) first, then only get affected trade(s)
        // so that we can display it in print preview
        $stmt = $pdo->prepare("SELECT DISTINCT p.id, p.trade_id, p.description, p.type, uom.id as uom_id, p.priority, p.lft, p.level,
        p.updated_at, p.recalculate_resources_library_status, uom.symbol AS uom_symbol
        FROM ".ScheduleOfRateItemTable::getInstance()->getTableName()." i
        JOIN ".ScheduleOfRateItemTable::getInstance()->getTableName()." p
        ON (i.lft BETWEEN p.lft AND p.rgt AND p.deleted_at IS NULL)
        JOIN ".ScheduleOfRateTradeTable::getInstance()->getTableName()." sort ON p.trade_id = sort.id AND sort.deleted_at IS NULL
        LEFT JOIN ".UnitOfMeasurementTable::getInstance()->getTableName()." uom ON p.uom_id = uom.id AND uom.deleted_at IS NULL
        WHERE sort.schedule_of_rate_id = ".$scheduleOfRate->id." AND i.id IN (".implode(',', $itemIds).")
        AND i.root_id = p.root_id AND i.type <> ".ScheduleOfRateItem::TYPE_HEADER." AND i.deleted_at IS NULL
        ORDER BY p.priority, p.lft, p.level ASC");

        $stmt->execute();
        $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if ( empty($items) )
        {
            return array(array(), array(), array());
        }

        foreach ( $items as $item )
        {
            $newItems[$item['trade_id']][] = $item;

            $newItemIds[$item['id']]     = $item['id'];
            $tradeIds[$item['trade_id']] = $item['trade_id'];

            unset($item);
        }

        unset($items);

        $stmt = $pdo->prepare("SELECT ifc.relation_id, ifc.column_name, ifc.final_value, ifc.value, ifc.has_build_up
        FROM ".ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName()." ifc
        JOIN ".ScheduleOfRateItemTable::getInstance()->getTableName()." i ON i.id = ifc.relation_id
        WHERE i.id IN (".implode(',', $newItemIds).") AND ifc.deleted_at IS NULL AND i.deleted_at IS NULL AND ifc.final_value <> 0");

        $stmt->execute();
        $itemFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach($itemFormulatedColumns as $itemFormulatedColumn)
        {
            if(!array_key_exists($itemFormulatedColumn['relation_id'], $formulatedColumns))
            {
                $formulatedColumns[$itemFormulatedColumn['relation_id']] = array();
            }

            array_push($formulatedColumns[$itemFormulatedColumn['relation_id']], $itemFormulatedColumn);

            unset($itemFormulatedColumn);
        }

        unset($itemFormulatedColumns);

        $trades = ScheduleOfRateTradeTable::getRecordsByScheduleOfRateAndIds($scheduleOfRate, $tradeIds);

        return array($trades, $newItems, $formulatedColumns);
    }

    public static function getSelectedItemsWithBuildUpRateByItemIds(ScheduleOfRate $scheduleOfRate, array $itemIds)
    {
        $pdo               = self::getInstance()->getConnection()->getDbh();
        $newItemIds        = array();
        $tradeIds          = array();
        $newItems          = array();
        $formulatedColumns = array();

        if ( empty($itemIds) )
        {
            return array(array(), array(), array());
        }

        // will get item(s) that has build up in place
        $stmt = $pdo->prepare("SELECT ifc.relation_id, ifc.column_name, ifc.final_value, ifc.value, ifc.has_build_up
        FROM ".ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName()." ifc
        JOIN ".ScheduleOfRateItemTable::getInstance()->getTableName()." i ON i.id = ifc.relation_id
        JOIN ".ScheduleOfRateTradeTable::getInstance()->getTableName()." sort ON sort.id = i.trade_id AND sort.deleted_at IS NULL
        WHERE sort.schedule_of_rate_id = ".$scheduleOfRate->id." AND i.id IN (".implode(',', $itemIds).")
        AND ifc.deleted_at IS NULL AND i.deleted_at IS NULL AND ifc.has_build_up = TRUE AND ifc.final_value <> 0");

        $stmt->execute();
        $itemFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if ( empty($itemFormulatedColumns) )
        {
            return array(array(), array(), array());
        }

        foreach($itemFormulatedColumns as $itemFormulatedColumn)
        {
            $itemId              = $itemFormulatedColumn['relation_id'];
            $newItemIds[$itemId] = $itemId;

            if(!array_key_exists($itemId, $formulatedColumns))
            {
                $formulatedColumns[$itemId] = array();
            }

            array_push($formulatedColumns[$itemId], $itemFormulatedColumn);

            unset($itemFormulatedColumn);
        }

        // then only get item(s) hierarchy that has the build up available
        $stmt = $pdo->prepare("SELECT DISTINCT p.id, p.trade_id, p.description, p.type, uom.id as uom_id, p.priority, p.lft, p.level,
        p.updated_at, p.recalculate_resources_library_status, uom.symbol AS uom_symbol
        FROM ".ScheduleOfRateItemTable::getInstance()->getTableName()." i
        JOIN ".ScheduleOfRateItemTable::getInstance()->getTableName()." p
        ON (i.lft BETWEEN p.lft AND p.rgt AND p.deleted_at IS NULL)
        JOIN ".ScheduleOfRateTradeTable::getInstance()->getTableName()." sort ON p.trade_id = sort.id AND sort.deleted_at IS NULL
        LEFT JOIN ".UnitOfMeasurementTable::getInstance()->getTableName()." uom ON p.uom_id = uom.id AND uom.deleted_at IS NULL
        WHERE sort.schedule_of_rate_id = ".$scheduleOfRate->id." AND i.id IN (".implode(',', $newItemIds).")
        AND i.root_id = p.root_id AND i.type <> ".ScheduleOfRateItem::TYPE_HEADER." AND i.deleted_at IS NULL
        ORDER BY p.priority, p.lft, p.level ASC");

        $stmt->execute();
        $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ( $items as $item )
        {
            $newItems[$item['trade_id']][] = $item;
            $tradeIds[$item['trade_id']]   = $item['trade_id'];

            unset($item);
        }

        $trades = ScheduleOfRateTradeTable::getRecordsByScheduleOfRateAndIds($scheduleOfRate, $tradeIds);

        return array($trades, $newItems, $formulatedColumns);
    }

    public static function updateRootPriority($priority, $tradeId, $excludeId = null)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $sqlUpdateRoot = "UPDATE ".self::getInstance()->getTableName()." SET priority = priority + 1
            WHERE trade_id =".$tradeId." AND priority >=".$priority." AND id = root_id";

        if($excludeId and $excludeId > 0)
        {
            $sqlUpdateRoot .= " AND id <> ".$excludeId;
        }

        $sqlUpdateRoot .= " AND deleted_at IS NULL";

        $stmt = $pdo->prepare($sqlUpdateRoot);

        $stmt->execute();

        //update children priority same as root priority
        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." AS i SET priority = r.priority
            FROM ".self::getInstance()->getTableName()." AS r
            WHERE i.root_id = r.id AND i.id <> r.id AND i.priority <> r.priority AND i.trade_id = ".$tradeId."
            AND i.deleted_at IS NULL");

        $stmt->execute();
    }

    public static function importResourceItems(Doctrine_Connection $conn, $targetItemId, ScheduleOfRateTrade $sorTrade, Array $resourceItemIds, $withRate = false)
    {
        if(count($resourceItemIds) > 0 && array_search("", $resourceItemIds) === false)
        {
            $pdo = $conn->getDbh();

            $targetItem = $targetItemId > 0 ? self::getInstance()->find($targetItemId) : false;

            $stmt = $pdo->prepare('SELECT c.id, c.description, c.type, c.uom_id, c.level FROM
            '.ResourceItemTable::getInstance()->getTableName().' AS c
            LEFT JOIN '.ResourceItemTable::getInstance()->getTableName().' AS r ON c.root_id = r.id
            WHERE c.id IN ('.implode(",", $resourceItemIds).') AND c.deleted_at IS NULL AND r.deleted_at IS NULL
            ORDER BY r.priority, c.lft, c.level ASC');

            $stmt->execute();

            $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

            $priority = self::getTargetedResourceItemPriority($sorTrade, $targetItem);

            $trees = array();

            if($items and !empty($items))
            {
                // Node Stack. Used to help building the hierarchy
                $stack = array();

                foreach($items as $item)
                {
                    $item['trade_id']                = $sorTrade->id;
                    $item['import_resource_item_id'] = $item['id'];
                    $item['__children']              = array();

                    // Number of stack items
                    $l = count($stack);

                    // Check if we're dealing with different levels
                    while($l > 0 && $stack[$l - 1]['level'] >= $item['level'])
                    {
                        array_pop($stack);
                        $l--;
                    }

                    // Stack is empty (we are inspecting the root)
                    if ($l == 0)
                    {
                        // Assigning the root child
                        $i         = count($trees);
                        $trees[$i] = $item;
                        $stack[]   = & $trees[$i];
                    }
                    else
                    {
                        // Add child to parent
                        $i                               = count($stack[$l - 1]['__children']);
                        $stack[$l - 1]['__children'][$i] = $item;
                        $stack[]                         = & $stack[$l - 1]['__children'][$i];
                    }
                }

                $firstLevelData        = array();
                $shiftExistingRLValues = false;

                foreach($trees as $key => $tree)
                {
                    if(!$targetItem)
                    {
                        ScheduleOfRateItemTable::updateRootPriority($priority, $sorTrade->id);

                        $trees[$key]['priority'] = $priority;
                        $trees[$key]['root_id']  = 0;
                        $trees[$key]['lft']      = 1;
                        $trees[$key]['rgt']      = 2;
                        $trees[$key]['level']    = 0;

                        $priority += 1;
                    }
                    else if($targetItem->type == ScheduleOfRateItem::TYPE_HEADER)
                    {
                        if($key == 0)
                        {
                            $lft = $targetItem->lft + 1;
                        }
                        else
                        {
                            $__childrenCount = 0;
                            array_walk_recursive($trees[$key-1]['__children'], function($v, $k) use(&$__childrenCount){
                                if($k == "id") $__childrenCount++;
                            });

                            $lft = $__childrenCount * 2 + $trees[$key-1]['rgt'] + 1;
                        }

                        $trees[$key]['priority'] = $targetItem->priority;
                        $trees[$key]['root_id']  = $targetItem->root_id;
                        $trees[$key]['lft']      = $lft;
                        $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                        $trees[$key]['level']    = $targetItem->level + 1;
                        $shiftExistingRLValues   = true;
                    }
                    else if($targetItem->node->isRoot() && ($targetItem->type != ScheduleOfRateItem::TYPE_HEADER))
                    {
                        //Update Priority
                        $targetItem->updateRootPriority($priority);

                        $trees[$key]['priority'] = $priority;
                        $trees[$key]['root_id']  = 0;
                        $trees[$key]['lft']      = 1;
                        $trees[$key]['rgt']      = 2;
                        $trees[$key]['level']    = 0;

                        $priority += 1;
                    }
                    else
                    {
                        if($key == 0)
                        {
                            $lft = $targetItem->rgt + 1;
                        }
                        else
                        {
                            $__childrenCount = 0;
                            array_walk_recursive($trees[$key-1]['__children'], function($v, $k) use(&$__childrenCount){
                                if($k == "id") $__childrenCount++;
                            });

                            $lft = $__childrenCount * 2 + $trees[$key-1]['rgt'] + 1;
                        }

                        $trees[$key]['priority'] = $targetItem->priority;
                        $trees[$key]['root_id']  = $targetItem->root_id;
                        $trees[$key]['lft']      = $lft;
                        $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                        $trees[$key]['level']    = $targetItem->level;

                        $shiftExistingRLValues = true;
                    }

                    $uomId = $tree['uom_id'] > 0 ? $tree['uom_id'] : 'NULL';

                    $firstLevelData[] = "(
                        '".pg_escape_string(trim($tree['description']))."',
                        ".$tree['type'].",
                        ".$uomId.",
                        ".$tree['trade_id'].",
                        ".$tree['import_resource_item_id'].",
                        ".$trees[$key]['priority'].",
                        ".$trees[$key]['lft'].",
                        ".$trees[$key]['rgt'].",
                        ".$trees[$key]['level'].",
                        NOW(),
                        NOW()
                    )";

                    unset($tree);
                }

                $stmt = $pdo->prepare("INSERT INTO ".self::getInstance()->getTableName()." (description, type, uom_id, trade_id, import_resource_item_id, priority, lft, rgt, level, created_at, updated_at) VALUES ".implode(",", $firstLevelData)." RETURNING id, import_resource_item_id, type");
                $stmt->execute();

                $returnIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                $rootIds = array();
                $rgtValues = array();

                $hasChildrenToInsert = false;

                foreach($returnIds as $key => $returnId)
                {
                    $itemCount = 1;

                    $rootId = $trees[$key]['root_id'] > 0 ? $trees[$key]['root_id'] : $returnId['id'];

                    $rootIds[] = "WHEN ".$returnId['id']." THEN ".$rootId;

                    $firstLevelNodeRightVal = $trees[$key]['rgt'];

                    if(count($trees[$key]['__children']) > 0)
                    {
                        list($firstLevelNodeRightVal, $itemCount) = self::resourceLoadNestedSetData($trees[$key]['__children'], $trees[$key], $rootId, $firstLevelNodeRightVal, $itemCount);

                        $hasChildrenToInsert = true;
                    }

                    $rgtValues[] = "WHEN ".$returnId['id']." THEN ".$firstLevelNodeRightVal;

                    /*
                    * If items were inserted at the middle of tree then we need to update the left and right values for the existing items
                    */
                    if($shiftExistingRLValues && $targetItem)
                    {
                        $delta = $itemCount * 2;
                        //shift all existing siblings
                        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET lft = (".$delta." + lft), rgt = (".$delta." + rgt) WHERE lft > ".$targetItem->lft." AND root_id = ".$targetItem->root_id." AND trade_id = ".$sorTrade->id." AND deleted_at IS NULL");
                        $stmt->execute();

                        if($targetItem->type == ScheduleOfRateItem::TYPE_HEADER)
                        {
                            $lftSign = "<=";
                            $rgtSign = ">=";
                        }
                        else
                        {
                            $lftSign = "<";
                            $rgtSign = ">";
                        }

                        //update ancestors right values since the family is getting bigger!
                        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET rgt = (".$delta." + rgt) WHERE lft ".$lftSign." ".$targetItem->lft." AND rgt ".$rgtSign." ".$targetItem->rgt." AND root_id = ".$targetItem->root_id." AND trade_id = ".$sorTrade->id." AND deleted_at IS NULL");
                        $stmt->execute();
                    }

                    if($withRate and $returnId['type'] != ScheduleOfRateItem::TYPE_HEADER)
                    {
                        self::copyFormulatedColumnFromResourceItemByType($returnId['id'], $returnId['import_resource_item_id'], ResourceItem::FORMULATED_COLUMN_RATE);
                    }
                }

                $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET root_id = CASE id ".implode(" ", $rootIds)." END, rgt = CASE id ".implode(" ", $rgtValues)." END WHERE root_id IS NULL AND trade_id = ".$sorTrade->id." AND deleted_at IS NULL");
                $stmt->execute();

                if($hasChildrenToInsert)
                {
                    $stmt = $pdo->prepare("INSERT INTO ".self::getInstance()->getTableName()." (description, type, uom_id, trade_id, import_resource_item_id, root_id, priority, lft, rgt, level, created_at, updated_at) VALUES ".implode(",", self::getInstance()->importedBillItemsChildren)." RETURNING id, import_resource_item_id, type");
                    $stmt->execute();

                    if($withRate)
                    {
                        $returnChildrenIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                        foreach($returnChildrenIds as $returnChildrenId)
                        {
                            if($returnChildrenId['type'] != ScheduleOfRateItem::TYPE_HEADER and $returnChildrenId['type'] != ScheduleOfRateItem::TYPE_NOID)
                            {
                                self::copyFormulatedColumnFromResourceItemByType($returnChildrenId['id'], $returnChildrenId['import_resource_item_id'], ResourceItem::FORMULATED_COLUMN_RATE);
                            }

                            unset($returnChildrenId);
                        }

                        unset($returnChildrenIds);
                    }
                }
            }

            unset($trees, $families, self::getInstance()->importedBillItemsChildren);
        }
    }

    public static function resourceLoadNestedSetData(Array $nestedSetData, Array $parent, $rootId, $parentRgtVal, $itemCount)
    {
        $functionName = __FUNCTION__;

        foreach($nestedSetData as $nestedSet)
        {
            unset($nestedSet['id']);

            /*
             * Since this will only be called when the node (parent) has children under it so we just add
             * all nodes in nested set as children for the parent node
             */
            $nestedSet['lft']   = $parentRgtVal;
            $nestedSet['rgt']   = $nestedSet['lft'] + 1;
            $nestedSet['level'] = $parent['level'] + 1;

            $parentRgtVal = $nestedSet['rgt'];

            $nestedSet['priority'] = $parent['priority'];

            $itemCount +=1;

            if(array_key_exists('__children', $nestedSet) and !empty($nestedSet['__children']))
            {
                list($parentRgtVal, $itemCount) = self::$functionName($nestedSet['__children'], $nestedSet, $rootId, $parentRgtVal, $itemCount);

                $nestedSet['rgt'] = $parentRgtVal;
            }

            $parentRgtVal += 1;

            $uomId = $nestedSet['uom_id'] > 0 ? $nestedSet['uom_id'] : 'NULL';

            self::getInstance()->importedBillItemsChildren[] = "(
                '".pg_escape_string(trim($nestedSet['description']))."',
                ".$nestedSet['type'].",
                ".$uomId.",
                ".$nestedSet['trade_id'].",
                ".$nestedSet['import_resource_item_id'].",
                ".$rootId.",
                ".$nestedSet['priority'].",
                ".$nestedSet['lft'].",
                ".$nestedSet['rgt'].",
                ".$nestedSet['level'].",
                NOW(),
                NOW()
            )";
        }

        return array($parentRgtVal, $itemCount);
    }

    public static function importSORItems(Doctrine_Connection $conn, $targetItemId, ScheduleOfRateTrade $sorTrade, Array $sorItemIds, $withRate = false)
    {
        if(count($sorItemIds) > 0 && array_search("", $sorItemIds) === false)
        {
            $pdo = $conn->getDbh();

            $targetItem = $targetItemId > 0 ? self::getInstance()->find($targetItemId) : false;

            $stmt = $pdo->prepare('SELECT c.id, c.description, c.type, c.uom_id, c.level FROM
            '.ScheduleOfRateItemTable::getInstance()->getTableName().' AS c
            LEFT JOIN '.ScheduleOfRateItemTable::getInstance()->getTableName().' AS r ON c.root_id = r.id
            WHERE c.id IN ('.implode(",", $sorItemIds).') AND c.deleted_at IS NULL AND r.deleted_at IS NULL
            ORDER BY r.priority, c.lft, c.level ASC');

            $stmt->execute();

            $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

            $priority = self::getTargetedResourceItemPriority($sorTrade, $targetItem);

            $trees = array();

            if($items and !empty($items))
            {
                // Node Stack. Used to help building the hierarchy
                $stack = array();

                foreach($items as $item)
                {
                    $item['trade_id']           = $sorTrade->id;
                    $item['import_sor_item_id'] = $item['id'];
                    $item['__children']         = array();

                    // Number of stack items
                    $l = count($stack);

                    // Check if we're dealing with different levels
                    while($l > 0 && $stack[$l - 1]['level'] >= $item['level'])
                    {
                        array_pop($stack);
                        $l--;
                    }

                    // Stack is empty (we are inspecting the root)
                    if ($l == 0)
                    {
                        // Assigning the root child
                        $i         = count($trees);
                        $trees[$i] = $item;
                        $stack[]   = & $trees[$i];
                    }
                    else
                    {
                        // Add child to parent
                        $i                               = count($stack[$l - 1]['__children']);
                        $stack[$l - 1]['__children'][$i] = $item;
                        $stack[]                         = & $stack[$l - 1]['__children'][$i];
                    }
                }

                $firstLevelData        = array();
                $shiftExistingRLValues = false;

                foreach($trees as $key => $tree)
                {
                    if(!$targetItem)
                    {
                        ScheduleOfRateItemTable::updateRootPriority($priority, $sorTrade->id);

                        $trees[$key]['priority'] = $priority;
                        $trees[$key]['root_id']  = 0;
                        $trees[$key]['lft']      = 1;
                        $trees[$key]['rgt']      = 2;
                        $trees[$key]['level']    = 0;

                        $priority += 1;
                    }
                    else if($targetItem->type == ScheduleOfRateItem::TYPE_HEADER)
                    {
                        if($key == 0)
                        {
                            $lft = $targetItem->lft + 1;
                        }
                        else
                        {
                            $__childrenCount = 0;
                            array_walk_recursive($trees[$key-1]['__children'], function($v, $k) use(&$__childrenCount){
                                if($k == "id") $__childrenCount++;
                            });

                            $lft = $__childrenCount * 2 + $trees[$key-1]['rgt'] + 1;
                        }

                        $trees[$key]['priority'] = $targetItem->priority;
                        $trees[$key]['root_id']  = $targetItem->root_id;
                        $trees[$key]['lft']      = $lft;
                        $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                        $trees[$key]['level']    = $targetItem->level + 1;
                        $shiftExistingRLValues   = true;
                    }
                    else if($targetItem->node->isRoot() && ($targetItem->type != ScheduleOfRateItem::TYPE_HEADER))
                    {
                        //Update Priority
                        $targetItem->updateRootPriority($priority);

                        $trees[$key]['priority'] = $priority;
                        $trees[$key]['root_id']  = 0;
                        $trees[$key]['lft']      = 1;
                        $trees[$key]['rgt']      = 2;
                        $trees[$key]['level']    = 0;

                        $priority += 1;
                    }
                    else
                    {
                        if($key == 0)
                        {
                            $lft = $targetItem->rgt + 1;
                        }
                        else
                        {
                            $__childrenCount = 0;
                            array_walk_recursive($trees[$key-1]['__children'], function($v, $k) use(&$__childrenCount){
                                if($k == "id") $__childrenCount++;
                            });

                            $lft = $__childrenCount * 2 + $trees[$key-1]['rgt'] + 1;
                        }

                        $trees[$key]['priority'] = $targetItem->priority;
                        $trees[$key]['root_id']  = $targetItem->root_id;
                        $trees[$key]['lft']      = $lft;
                        $trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
                        $trees[$key]['level']    = $targetItem->level;

                        $shiftExistingRLValues = true;
                    }

                    $uomId = $tree['uom_id'] > 0 ? $tree['uom_id'] : 'NULL';

                    $firstLevelData[] = "(
                        '".pg_escape_string(trim($tree['description']))."',
                        ".$tree['type'].",
                        ".$uomId.",
                        ".$tree['trade_id'].",
                        ".$tree['import_sor_item_id'].",
                        ".$trees[$key]['priority'].",
                        ".$trees[$key]['lft'].",
                        ".$trees[$key]['rgt'].",
                        ".$trees[$key]['level'].",
                        NOW(),
                        NOW()
                    )";

                    unset($tree);
                }

                $stmt = $pdo->prepare("INSERT INTO ".self::getInstance()->getTableName()." (description, type, uom_id, trade_id, import_sor_item_id, priority, lft, rgt, level, created_at, updated_at) VALUES ".implode(",", $firstLevelData)." RETURNING id, import_sor_item_id, type");
                $stmt->execute();

                $returnIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                $rootIds = array();
                $rgtValues = array();

                $hasChildrenToInsert = false;

                foreach($returnIds as $key => $returnId)
                {
                    $itemCount = 1;

                    $rootId = $trees[$key]['root_id'] > 0 ? $trees[$key]['root_id'] : $returnId['id'];

                    $rootIds[] = "WHEN ".$returnId['id']." THEN ".$rootId;

                    $firstLevelNodeRightVal = $trees[$key]['rgt'];

                    if(count($trees[$key]['__children']) > 0)
                    {
                        list($firstLevelNodeRightVal, $itemCount) = self::sorLoadNestedSetData($trees[$key]['__children'], $trees[$key], $rootId, $firstLevelNodeRightVal, $itemCount);

                        $hasChildrenToInsert = true;
                    }

                    $rgtValues[] = "WHEN ".$returnId['id']." THEN ".$firstLevelNodeRightVal;

                    /*
                    * If items were inserted at the middle of tree then we need to update the left and right values for the existing items
                    */
                    if($shiftExistingRLValues && $targetItem)
                    {
                        $delta = $itemCount * 2;
                        //shift all existing siblings
                        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET lft = (".$delta." + lft), rgt = (".$delta." + rgt) WHERE lft > ".$targetItem->lft." AND root_id = ".$targetItem->root_id." AND trade_id = ".$sorTrade->id." AND deleted_at IS NULL");
                        $stmt->execute();

                        if($targetItem->type == ScheduleOfRateItem::TYPE_HEADER)
                        {
                            $lftSign = "<=";
                            $rgtSign = ">=";
                        }
                        else
                        {
                            $lftSign = "<";
                            $rgtSign = ">";
                        }

                        //update ancestors right values since the family is getting bigger!
                        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET rgt = (".$delta." + rgt) WHERE lft ".$lftSign." ".$targetItem->lft." AND rgt ".$rgtSign." ".$targetItem->rgt." AND root_id = ".$targetItem->root_id." AND trade_id = ".$sorTrade->id." AND deleted_at IS NULL");
                        $stmt->execute();
                    }

                    if($withRate and ($returnId['type'] != ScheduleOfRateItem::TYPE_HEADER && $returnId['type'] != ScheduleOfRateItem::TYPE_NOID))
                    {
                        self::copyFormulatedColumnFromSORItemByType($returnId['id'], $returnId['import_sor_item_id'], ScheduleOfRateItem::FORMULATED_COLUMN_RATE);
                        self::copyBuildUpRatesFromSORItem($returnId['id'], $returnId['import_sor_item_id']);
                    }
                }

                $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." SET root_id = CASE id ".implode(" ", $rootIds)." END, rgt = CASE id ".implode(" ", $rgtValues)." END WHERE root_id IS NULL AND trade_id = ".$sorTrade->id." AND deleted_at IS NULL");
                $stmt->execute();

                if($hasChildrenToInsert)
                {
                    $stmt = $pdo->prepare("INSERT INTO ".self::getInstance()->getTableName()." (description, type, uom_id, trade_id, import_sor_item_id, root_id, priority, lft, rgt, level, created_at, updated_at) VALUES ".implode(",", self::getInstance()->importedBillItemsChildren)." RETURNING id, import_sor_item_id, type");
                    $stmt->execute();

                    if($withRate)
                    {
                        $returnChildrenIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

                        foreach($returnChildrenIds as $returnChildrenId)
                        {
                            if($returnChildrenId['type'] != ScheduleOfRateItem::TYPE_HEADER and $returnChildrenId['type'] != ScheduleOfRateItem::TYPE_NOID)
                            {
                                self::copyFormulatedColumnFromSORItemByType($returnChildrenId['id'], $returnChildrenId['import_sor_item_id'], ScheduleOfRateItem::FORMULATED_COLUMN_RATE);
                                self::copyBuildUpRatesFromSORItem($returnChildrenId['id'], $returnChildrenId['import_sor_item_id']);
                            }

                            unset($returnChildrenId);
                        }

                        unset($returnChildrenIds);
                    }
                }
            }

            unset($trees, $families, self::getInstance()->importedBillItemsChildren);
        }
    }

    public static function sorLoadNestedSetData(Array $nestedSetData, Array $parent, $rootId, $parentRgtVal, $itemCount)
    {
        $functionName = __FUNCTION__;

        foreach($nestedSetData as $nestedSet)
        {
            unset($nestedSet['id']);

            /*
             * Since this will only be called when the node (parent) has children under it so we just add
             * all nodes in nested set as children for the parent node
             */
            $nestedSet['lft']   = $parentRgtVal;
            $nestedSet['rgt']   = $nestedSet['lft'] + 1;
            $nestedSet['level'] = $parent['level'] + 1;

            $parentRgtVal = $nestedSet['rgt'];

            $nestedSet['priority'] = $parent['priority'];

            $itemCount +=1;

            if(array_key_exists('__children', $nestedSet) and !empty($nestedSet['__children']))
            {
                list($parentRgtVal, $itemCount) = self::$functionName($nestedSet['__children'], $nestedSet, $rootId, $parentRgtVal, $itemCount);

                $nestedSet['rgt'] = $parentRgtVal;
            }

            $parentRgtVal += 1;

            $uomId = $nestedSet['uom_id'] > 0 ? $nestedSet['uom_id'] : 'NULL';

            self::getInstance()->importedBillItemsChildren[] = "(
                '".pg_escape_string(trim($nestedSet['description']))."',
                ".$nestedSet['type'].",
                ".$uomId.",
                ".$nestedSet['trade_id'].",
                ".$nestedSet['import_sor_item_id'].",
                ".$rootId.",
                ".$nestedSet['priority'].",
                ".$nestedSet['lft'].",
                ".$nestedSet['rgt'].",
                ".$nestedSet['level'].",
                NOW(),
                NOW()
            )";
        }

        return array($parentRgtVal, $itemCount);
    }

    private static function getTargetedResourceItemPriority(ScheduleOfRateTrade $sorTrade, $targetItem)
    {
        if ( !$targetItem )
        {
            /* If No Target Item Specify We Get First Root Item as target Item */
            $rootItem = DoctrineQuery::create()->select('i.id')
                ->from('ScheduleOfRateItem i')
                ->where('i.trade_id = ?', array( $sorTrade->id ))
                ->andWhere('i.root_id = i.id')
                ->limit(1)
                ->addOrderBy('i.priority ASC')
                ->fetchOne();

            /*
             * we get target item (assumed root) priority first because later we will increment the priority
             * when we are creating root items.
             */
            $priority = $rootItem ? $rootItem->priority : 0;
        }
        else
        {
            $record = DoctrineQuery::create()->select('i.priority')
                ->from('ScheduleOfRateItem i')
                ->where('i.trade_id = ?', array( $sorTrade->id ))
                ->andWhere('i.root_id = i.id')
                ->andWhere('i.id = ? ', $targetItem->id)
                ->limit(1)
                ->addOrderBy('i.priority ASC')
                ->fetchOne();

            $priority = $record ? $record->priority + 1 : 0;
        }

        return $priority;
    }

    public static function copyFormulatedColumnFromResourceItemByType($newResourceItemId, $oldResourceItemId, $type = ResourceItem::FORMULATED_COLUMN_RATE)
    {
        $formulatedColumn = ResourceItemTable::getFormulatedColumnByRelationIdAndColumnName($oldResourceItemId, $type, Doctrine_Core::HYDRATE_ARRAY);

        self::insertFormulatedColumnRow($newResourceItemId, $formulatedColumn);
    }

    public static function copyFormulatedColumnFromSORItemByType($newResourceItemId, $oldResourceItemId, $type = ScheduleOfRateItem::FORMULATED_COLUMN_RATE)
    {
        $formulatedColumn = ScheduleOfRateItemTable::getFormulatedColumnByRelationIdAndColumnName($oldResourceItemId, $type, Doctrine_Core::HYDRATE_ARRAY);

        self::insertFormulatedColumnRow($newResourceItemId, $formulatedColumn);
    }

    private static function insertFormulatedColumnRow($newResourceItemId, $formulatedColumn)
    {
        if ( $formulatedColumn )
        {
            $pdo = self::getInstance()->getConnection()->getDbh();

            $userId     = sfContext::getInstance()->getUser()->getAttribute('user_id', null, 'sfGuardSecurityUser');
            $finalValue = ( $formulatedColumn['final_value'] ) ? $formulatedColumn['final_value'] : 0;
            $hasBuildUp = ( isset($formulatedColumn['has_build_up']) AND $formulatedColumn['has_build_up'] ) ? 'true' : 'false';

            $stmt = $pdo->prepare("INSERT INTO " . ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName() . " (relation_id, has_build_up, column_name, value, final_value, created_at, updated_at, created_by, updated_by)
                VALUES (" . $newResourceItemId . ", " . $hasBuildUp . ", '" . $formulatedColumn['column_name'] . "', '" . $finalValue . "', " . $finalValue . ", NOW(), NOW(), " . $userId . ", " . $userId . ")");

            $stmt->execute();
        }
    }

    public static function copyBuildUpRatesFromSORItem($newSORItemId, $oldSORItemId)
    {
        $item           = Doctrine_Core::getTable('ScheduleOfRateItem')->find($oldSORItemId);

        $targetItem     = new ScheduleOfRateItem();
        $targetItem->id = $newSORItemId;

        $targetItem->copyBuildUpRatesFromItem($item);

        $item->free();
        $targetItem->free();

        unset($item, $targetItem);
    }

    public static function getRecordsAssociatedWithResourceAndScheduleOfRateTrade(Resource $resource, ScheduleOfRateTrade $sorTrade)
    {
        $data              = array();
        $formulatedColumns = array();
        $itemIds           = array();
        $pdo               = self::getInstance()->getConnection()->getDbh();

        // get affected item's id first
        $stmt = $pdo->prepare('SELECT DISTINCT schedule_of_rate_item_id as id
        FROM '.ScheduleOfRateBuildUpRateResourceTable::getInstance()->getTableName().' sorburr
        JOIN '.ScheduleOfRateItemTable::getInstance()->getTableName().' sori ON (sorburr.schedule_of_rate_item_id = sori.id AND sorburr.deleted_at IS NULL)
        JOIN '.ScheduleOfRateTradeTable::getInstance()->getTableName().' sort ON (sori.trade_id = sort.id AND sort.deleted_at IS NULL)
        JOIN '.ScheduleOfRateTable::getInstance()->getTableName().' sor ON (sort.schedule_of_rate_id = sor.id AND sort.deleted_at IS NULL)
        WHERE sort.id = '.$sorTrade->id.' AND sort.deleted_at IS NULL
        AND sor.id = '.$sorTrade->schedule_of_rate_id.' AND sor.deleted_at IS NULL
        AND sorburr.resource_library_id = '.$resource->id.' AND sorburr.deleted_at IS NULL');

        $stmt->execute();

        $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ( $items as $item )
        {
            $itemIds[$item['id']] = $item['id'];

            unset($item);
        }

        unset($items);

        if (empty($itemIds))
        {
            return array($data, $formulatedColumns);
        }

        // get item's hierarchy structure
        $stmt = $pdo->prepare("SELECT DISTINCT p.id, p.trade_id, p.description, p.type, uom.id as uom_id, p.priority, p.lft, p.level,
        p.updated_at, p.recalculate_resources_library_status, uom.symbol AS uom_symbol
        FROM ".ScheduleOfRateItemTable::getInstance()->getTableName()." i
        JOIN ".ScheduleOfRateItemTable::getInstance()->getTableName()." p
        ON (i.lft BETWEEN p.lft AND p.rgt AND p.deleted_at IS NULL)
        JOIN ".ScheduleOfRateTradeTable::getInstance()->getTableName()." sort ON p.trade_id = sort.id AND sort.deleted_at IS NULL
        LEFT JOIN ".UnitOfMeasurementTable::getInstance()->getTableName()." uom ON p.uom_id = uom.id AND uom.deleted_at IS NULL
        WHERE sort.schedule_of_rate_id = ".$sorTrade->schedule_of_rate_id." AND i.id IN (".implode(',', $itemIds).")
        AND i.root_id = p.root_id AND i.type <> ".ScheduleOfRateItem::TYPE_HEADER." AND i.deleted_at IS NULL
        ORDER BY p.priority, p.lft, p.level ASC");

        $stmt->execute();

        $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if ( empty($items) )
        {
            return array($data, $formulatedColumns);
        }

        // will get item(s) that has build up in place
        $stmt = $pdo->prepare("SELECT ifc.relation_id, ifc.column_name, ifc.final_value, ifc.value, ifc.has_build_up
        FROM ".ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName()." ifc
        JOIN ".ScheduleOfRateItemTable::getInstance()->getTableName()." i ON i.id = ifc.relation_id
        JOIN ".ScheduleOfRateTradeTable::getInstance()->getTableName()." sort ON sort.id = i.trade_id AND sort.deleted_at IS NULL
        WHERE sort.schedule_of_rate_id = ".$sorTrade->schedule_of_rate_id." AND i.id IN (".implode(',', $itemIds).")
        AND ifc.deleted_at IS NULL AND i.deleted_at IS NULL AND ifc.has_build_up = TRUE AND ifc.final_value <> 0");

        $stmt->execute();

        $itemFormulatedColumns = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach($itemFormulatedColumns as $itemFormulatedColumn)
        {
            $itemId              = $itemFormulatedColumn['relation_id'];
            $newItemIds[$itemId] = $itemId;

            if(!array_key_exists($itemId, $formulatedColumns))
            {
                $formulatedColumns[$itemId] = array();
            }

            array_push($formulatedColumns[$itemId], $itemFormulatedColumn);

            unset($itemFormulatedColumn);
        }

        unset($itemFormulatedColumns);

        return array($items, $formulatedColumns);
    }

    public static function getScheduleOfRatesWithNoBuildUp(Array $billItemIds, $scheduleOfRateItemId)
    {
        $rates = array();

        if (!empty($billItemIds))
        {
            $pdo = self::getInstance()->getConnection()->getDbh();

            $stmt = $pdo->prepare("SELECT DISTINCT i.id AS bill_id, si.id AS id, i.grand_total AS total, f.final_value AS value, i.priority, i.root_id, i.lft, i.level
            FROM " .BillItemTable::getInstance()->getTableName(). " i
            JOIN " . BillItemFormulatedColumnTable::getInstance()->getTableName() . " f ON i.id = f.relation_id
            JOIN ".ScheduleOfRateItemFormulatedColumnTable::getInstance()->getTableName()." sf ON sf.id = schedule_of_rate_item_formulated_column_id
            JOIN ".ScheduleOfRateItemTable::getInstance()->getTableName()." si ON si.id = sf.relation_id
            WHERE i.id IN (" . implode(',', $billItemIds) . ") AND si.id = ".$scheduleOfRateItemId."
            AND f.column_name = '".BillItem::FORMULATED_COLUMN_RATE."' AND f.has_build_up IS FALSE
            AND si.deleted_at IS NULL AND sf.deleted_at IS NULL AND f.deleted_at IS NULL
            AND i.deleted_at IS NULL AND i.project_revision_deleted_at IS NULL ORDER BY i.priority, i.root_id, i.lft, i.level");

            $stmt->execute();

            $records = $stmt->fetchAll(PDO::FETCH_ASSOC);

            foreach($records as $record)
            {
                if(!array_key_exists($record['id'], $rates))
                {
                    $rates[ $record['id'] ]['rate']  = $record['value'];
                    $rates[ $record['id'] ]['total'] = 0;
                }

                if($rates[ $record['id'] ]['rate'] != $record['value'])
                {
                    $rates[ $record['id'] ]['rate'] = 'multi';
                }

                $rates[ $record['id'] ]['total'] += $record['total'];
            }
        }

        return $rates;
    }
}