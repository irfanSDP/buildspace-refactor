<?php

/**
 * PostContractSubPackageRemeasurementBuildUpQuantitySummary
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    buildspace
 * @subpackage model
 * @author     1337 developers
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class PostContractSubPackageRemeasurementBuildUpQuantitySummary extends BasePostContractSubPackageRemeasurementBuildUpQuantitySummary
{

	const ROUNDING_TYPE_DISABLED             = 1;
	const ROUNDING_TYPE_UPWARD               = 2;
	const ROUNDING_TYPE_DOWNWARD             = 4;
	const ROUNDING_TYPE_NEAREST_WHOLE_NUMBER = 8;
	const ROUNDING_TYPE_NEAREST_TENTH        = 16;

	public function calculateTotalQuantity()
	{
		$result = DoctrineQuery::create()
		->select('COALESCE(SUM(b.total), 0) as total')
		->from('PostContractSubPackageRemeasurementBuildUpQuantityItem b')
		->where('b.sub_package_post_contract_bill_item_rate_id = ?', $this->sub_package_post_contract_bill_item_rate_id)
		->andWhere('b.bill_column_setting_id = ?', $this->bill_column_setting_id)
		->andWhere('b.type = ?', $this->type)
		->limit(1)
		->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
		->fetchOne();

		$totalQuantity = $result['total'];

		if($totalQuantity != $this->total_quantity)
		{
			$this->total_quantity = $totalQuantity;
			$this->save();
		}

		return $this->total_quantity;
	}

	public function getTotalQuantityAfterConversion()
	{
		$finalQuantity          = $this->calculateTotalQuantity();
		$conversionFactorAmount = $this->conversion_factor_amount;
		$operator               = $this->conversion_factor_operator;

		if($this->apply_conversion_factor)
		{
			$exp = $finalQuantity.$operator.$conversionFactorAmount;

			$evaluator = new EvalMath(true, true);
			$evaluator->suppress_errors = true;
			$evaluatedValue = $evaluator->evaluate($exp);

			$finalQuantity = $evaluatedValue ? $evaluatedValue : 0;
		}

		switch($this->rounding_type)
		{
			case self::ROUNDING_TYPE_UPWARD:
				$finalQuantity  = ceil($finalQuantity);
				break;
			case self::ROUNDING_TYPE_DOWNWARD:
				$finalQuantity  = floor($finalQuantity);
				break;
			case self::ROUNDING_TYPE_NEAREST_WHOLE_NUMBER:
				$finalQuantity  = round($finalQuantity);
				break;
			case self::ROUNDING_TYPE_NEAREST_TENTH:
				$finalQuantity  = round($finalQuantity * 10) / 10;
				break;
			default:
				$finalQuantity  = number_format($finalQuantity, 2, '.', '');
		}

		if($finalQuantity != $this->final_quantity)
		{
			$this->final_quantity = $finalQuantity;
			$this->save();
		}

		return $this->final_quantity;
	}

	public function save(Doctrine_Connection $conn = null)
	{
		//reset all conversion factor information when it's disabled
		if($this->apply_conversion_factor === 'false')
		{
			$this->conversion_factor_amount = 0;
			$this->conversion_factor_operator = Constants::ARITHMETIC_OPERATOR_ADDITION;
		}

		$isNew = $this->isNew();

		parent::save($conn);

		if($this->deleted_at == NULL and !$isNew)
		{
			$this->refresh();

			//update bill item quantity to set flag has_build_up to true;
			$billItemTypeRef = PostContractSubPackageRemeasurementItemTypeReferenceTable::getByItemIdAndColumnId($this->sub_package_post_contract_bill_item_rate_id, $this->bill_column_setting_id);

			if (!$billItemTypeRef or $billItemTypeRef->isNew())
			{
				$billItemTypeRef                                              = new PostContractSubPackageRemeasurementItemTypeReference();
				$billItemTypeRef->sub_package_post_contract_bill_item_rate_id = $this->sub_package_post_contract_bill_item_rate_id;
				$billItemTypeRef->bill_column_setting_id                      = $this->bill_column_setting_id;
				$billItemTypeRef->save($conn);

				$billItemTypeRef->refresh();
			}

			$columnName = $this->type == BillBuildUpQuantityItem::QUANTITY_PER_UNIT_ORIGINAL ? BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT : BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT;

			PostContractSubPackageRemeasurementClaimTable::updateBuildUpQty($this, $conn);
		}
	}

}
