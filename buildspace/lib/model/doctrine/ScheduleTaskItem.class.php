<?php

/**
 * ScheduleTaskItem
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    buildspace
 * @subpackage model
 * @author     1337 developers
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class ScheduleTaskItem extends BaseScheduleTaskItem
{
    const STATUS_ACTIVE = 2;
    const STATUS_DONE   = 4;
    const STATUS_FAILED = 8;
    const STATUS_SUSPENDED = 16;
    const STATUS_UNDEFINED = 32;

    const STATUS_ACTIVE_TEXT = 'STATUS_ACTIVE';
    const STATUS_DONE_TEXT   = 'STATUS_DONE';
    const STATUS_FAILED_TEXT = 'STATUS_FAILED';
    const STATUS_SUSPENDED_TEXT = 'STATUS_SUSPENDED';
    const STATUS_UNDEFINED_TEXT = 'STATUS_UNDEFINED';

    public static function getStatusByStatusText($statusTxt)
    {
        switch($statusTxt)
        {
            case ScheduleTaskItem::STATUS_ACTIVE_TEXT:
                return ScheduleTaskItem::STATUS_ACTIVE;
            case ScheduleTaskItem::STATUS_DONE_TEXT:
                return ScheduleTaskItem::STATUS_DONE;
            case ScheduleTaskItem::STATUS_FAILED_TEXT:
                return ScheduleTaskItem::STATUS_FAILED;
            case ScheduleTaskItem::STATUS_SUSPENDED_TEXT:
                return ScheduleTaskItem::STATUS_SUSPENDED;
            case ScheduleTaskItem::STATUS_UNDEFINED_TEXT:
                return ScheduleTaskItem::STATUS_UNDEFINED;
            default:
                throw new Exception('Invalid status');
        }
    }

    public static function getStatusTextByStatus($status)
    {
        switch($status)
        {
            case ScheduleTaskItem::STATUS_ACTIVE:
                return ScheduleTaskItem::STATUS_ACTIVE_TEXT;
            case ScheduleTaskItem::STATUS_DONE:
                return ScheduleTaskItem::STATUS_DONE_TEXT;
            case ScheduleTaskItem::STATUS_FAILED:
                return ScheduleTaskItem::STATUS_FAILED_TEXT;
            case ScheduleTaskItem::STATUS_SUSPENDED:
                return ScheduleTaskItem::STATUS_SUSPENDED_TEXT;
            case ScheduleTaskItem::STATUS_UNDEFINED:
                return ScheduleTaskItem::STATUS_UNDEFINED_TEXT;
            default:
                throw new Exception('Invalid status');
        }
    }

    public function updateDuration($value,  Doctrine_Connection $conn = null)
    {
        $duration = ((int)$value && $value > 0) ? $value : 1;

        $this->end_date = $this->computeEndDateByDuration($duration);

        $this->save($conn);
    }

    public function updateStartDate($value, Doctrine_Connection $conn = null)
    {
        $this->start_date = $value;

        $this->save($conn);

        $this->refresh();

        $startDate = strtotime($this->start_date);
        $scheduleStartDate = strtotime($this->ProjectSchedule->start_date);

        if($startDate < $scheduleStartDate)
        {
            $this->ProjectSchedule->start_date = $this->start_date;
            $this->ProjectSchedule->save($conn);
        }
    }

    public function updateEndDate($value, Doctrine_Connection $conn = null)
    {
        if(strtotime($value) < strtotime($this->start_date))
        {
            $this->end_date = $this->start_date;
        }
        else
        {
            $this->end_date = $value;
        }

        $this->save($conn);
    }

    public function updateRootPriority($priority, $excludeId=null)
    {
        ScheduleTaskItemTable::updateRootPriority($priority, $this->project_schedule_id, $excludeId);
    }

    public function getActualTaskDuration()
    {
        return ScheduleTaskItemTable::getActualTaskDuration($this->start_date, $this->date_completed, $this->completion_percentage, $this->ProjectSchedule->getNonWorkingDays(), $this->ProjectSchedule->exclude_saturdays, $this->ProjectSchedule->exclude_sundays);
    }

    public function getPlannedTaskPercentage()
    {
        return ScheduleTaskItemTable::calculatePlannedTaskPercentage($this->start_date, $this->end_date, $this->ProjectSchedule->getNonWorkingDays(), $this->ProjectSchedule->exclude_saturdays, $this->ProjectSchedule->exclude_sundays);
    }

    public function getTaggedBillItemTypeReferencesByBillItemId($billItemId)
    {
        $pdo = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT * FROM ".ScheduleTaggedBillItemTypeReference::getInstance()->getTableName()." x
            JOIN ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()." b ON b.id = x.schedule_task_item_bill_item_id
            WHERE b.schedule_task_item_id = ".$this->id." AND b.bill_item_id = ".$billItemId);

        $stmt->execute();

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public function getScheduleTaskItemBillItemByBillItemId($billItemId)
    {
        $pdo = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT * FROM ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()." b
            WHERE b.schedule_task_item_id = ".$this->id." AND b.bill_item_id = ".$billItemId);

        $stmt->execute();

        return $stmt->fetchOne(PDO::FETCH_ASSOC);
    }

    public function tagBillItems(Array $selectedBillItemIds, Array $unSelectedBillItemIds, BillColumnSetting $billColumnSetting, $unitCount)
    {
        $pdo = $this->getTable()->getConnection()->getDbh();
        $postContractId = $billColumnSetting->ProjectStructure->getRoot()->PostContract->id;
        $subPackageId = $this->ProjectSchedule->sub_package_id;

        if($subPackageId > 0)
        {
            $typeReference = DoctrineQuery::create()->select('t.id')
                ->from('SubPackageTypeReference t')
                ->where('t.bill_column_setting_id = ?', array($billColumnSetting->id))
                ->andWhere('t.sub_package_id = ?', array($subPackageId))
                ->andWhere('t.counter = ? ', array($unitCount))
                ->limit(1)
                ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
                ->fetchOne();

            $errMsg = "There is no SubPackageTypeReference with bill_column_setting_id: ".$billColumnSetting->id.", sub_package_id: ".$subPackageId.", counter: ".$unitCount;
        }
        else
        {
            $typeReference = DoctrineQuery::create()->select('t.id')
                ->from('PostContractStandardClaimTypeReference t')
                ->where('t.bill_column_setting_id = ?', array($billColumnSetting->id))
                ->andWhere('t.post_contract_id = ?', array($postContractId))
                ->andWhere('t.counter = ? ', array($unitCount))
                ->limit(1)
                ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
                ->fetchOne();

            $errMsg = "There is no PostContractStandardClaimTypeReference with bill_column_setting_id: ".$billColumnSetting->id.", post_contract_id: ".$postContractId.", counter: ".$unitCount;
        }

        if(!$typeReference)
        {
            throw new Exception($errMsg);
        }

        if(count($unSelectedBillItemIds) > 0 && array_search("", $unSelectedBillItemIds) === false)
        {
            /*
            * Remove all tagged items from unselected bill items list
            */

            $sql = $subPackageId > 0 ? "x.sub_package_type_reference_id = ".$typeReference['id']." AND x.standard_type_reference_id IS NULL" : "x.sub_package_type_reference_id IS NULL AND x.standard_type_reference_id = ".$typeReference['id'];

            $stmt = $pdo->prepare("DELETE FROM ".ScheduleTaggedBillItemTypeReferenceTable::getInstance()->getTableName()." x WHERE ".$sql."
            AND x.schedule_task_item_bill_item_id IN (SELECT id FROM ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()." WHERE
            schedule_task_item_id = ".$this->id." AND bill_column_setting_id = ".$billColumnSetting->id." AND bill_item_id IN(".implode(',', $unSelectedBillItemIds)."))");

            $stmt->execute();
        }

        if(count($selectedBillItemIds) > 0 && array_search("", $selectedBillItemIds) === false)
        {
            $sql = $subPackageId > 0 ? "x.sub_package_type_reference_id = ".$typeReference['id']." AND x.standard_type_reference_id IS NULL" : "x.sub_package_type_reference_id IS NULL AND x.standard_type_reference_id = ".$typeReference['id'];

            $stmt = $pdo->prepare("SELECT DISTINCT t.bill_item_id FROM ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()." t
            JOIN ".ScheduleTaggedBillItemTypeReferenceTable::getInstance()->getTableName()." x ON x.schedule_task_item_bill_item_id = t.id
            WHERE t.bill_item_id IN (".implode(',', $selectedBillItemIds).")  AND t.bill_column_setting_id = ".$billColumnSetting->id." AND t.schedule_task_item_id =".$this->id." AND ".$sql);

            $stmt->execute();

            $existingTaggedItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

            $stmt = $pdo->prepare("SELECT DISTINCT i.id FROM ".BillItemTable::getInstance()->getTableName()." i
            WHERE i.id IN (".implode(',', $selectedBillItemIds).") AND i.type = ".BillItem::TYPE_HEADER." AND i.type = ".BillItem::TYPE_HEADER_N."
            AND i.type = ".BillItem::TYPE_ITEM_PC_RATE." AND i.type = ".BillItem::TYPE_NOID);

            $stmt->execute();

            $invalidBillItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

            if(($key = array_search(-1, $selectedBillItemIds)) !== false)
            {
                unset($selectedBillItemIds[$key]);
            }

            foreach($existingTaggedItems as $existingTaggedItem)
            {
                if(($key = array_search($existingTaggedItem['bill_item_id'], $selectedBillItemIds)) !== false)
                {
                    unset($selectedBillItemIds[$key]);
                }
            }

            foreach($invalidBillItems as $invalidBillItem)
            {
                if(($key = array_search($invalidBillItem['id'], $selectedBillItemIds)) !== false)
                {
                    unset($selectedBillItemIds[$key]);
                }
            }
        }

        if(count($selectedBillItemIds) > 0 && array_search("", $selectedBillItemIds) === false)
        {
            $stmt = $pdo->prepare("SELECT id, bill_item_id FROM ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()."
            WHERE bill_item_id IN (".implode(',', $selectedBillItemIds).")  AND bill_column_setting_id = ".$billColumnSetting->id." AND schedule_task_item_id =".$this->id);

            $stmt->execute();

            $scheduleTaskItemBillItemIds = $stmt->fetchAll(PDO::FETCH_COLUMN, 0);

            $stmt->execute();

            $scheduleTaskItemBillItems = $stmt->fetchAll(PDO::FETCH_COLUMN, 1);

            $filteredBillItems = array_diff($selectedBillItemIds, $scheduleTaskItemBillItems);

            $userId = sfContext::getInstance()->getUser()->getAttribute('user_id', null, 'sfGuardSecurityUser');
            $dataToInsert = array();

            foreach($filteredBillItems as $filteredBillItem)
            {
                $dataToInsert[] = "(".$this->id.", ".$filteredBillItem.", ".$billColumnSetting->id.", NOW(), NOW(), ".$userId.", ".$userId.")";
            }

            if(count($dataToInsert) > 0)
            {
                $stmt = $pdo->prepare("INSERT INTO ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()." (schedule_task_item_id, bill_item_id, bill_column_setting_id, created_at, updated_at, created_by, updated_by)
                        VALUES ".implode(",", $dataToInsert)." RETURNING id");

                $stmt->execute();

                $newScheduleTaskItemBillItemIds = $stmt->fetchAll(PDO::FETCH_COLUMN, 0);

                $scheduleTaskItemBillItemIds = array_merge($scheduleTaskItemBillItemIds, $newScheduleTaskItemBillItemIds);

                $dataToInsert = array();
            }

            if($subPackageId > 0)
            {
                $subPackageTypeReferenceId = $typeReference['id'];
                $standClaimTypeReferenceId = "NULL";
            }
            else
            {
                $subPackageTypeReferenceId = "NULL";
                $standClaimTypeReferenceId = $typeReference['id'];
            }

            foreach($scheduleTaskItemBillItemIds as $scheduleTaskItemBillItemId)
            {
                $dataToInsert[] = "(".$scheduleTaskItemBillItemId.", ".$subPackageTypeReferenceId.", ".$standClaimTypeReferenceId.", NOW(), NOW(), ".$userId.", ".$userId.")";
            }

            if(count($dataToInsert) > 0)
            {
                $stmt = $pdo->prepare("INSERT INTO ".ScheduleTaggedBillItemTypeReferenceTable::getInstance()->getTableName()." (schedule_task_item_bill_item_id, sub_package_type_reference_id, standard_type_reference_id, created_at, updated_at, created_by, updated_by)
                        VALUES ".implode(",", $dataToInsert));

                $stmt->execute();
            }
        }
    }

    public function updateHoursPerDay($value, Doctrine_Connection $con = null)
    {
        $con = $con ? $con : $this->getTable()->getConnection();

        $value = is_numeric($value) ? $value : 8;

        $value = $value < 0 ? 1 : $value;
        $value = $value > 24 ? 24 : $value;

        $this->hours_per_day = $value;

        $this->save($con);
    }

    public function recalculateProductivities()
    {
        $pdo = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT DISTINCT p.id, t.id AS schedule_task_item_bill_item_id, p.productivity, p.number_of_gang, p.duration_hours, p.duration_days
            FROM ".ScheduleBillItemProductivityTable::getInstance()->getTableName()." p
            JOIN ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()." AS t ON p.schedule_task_item_bill_item_id = t.id
            JOIN ".ScheduleTaggedBillItemTypeReferenceTable::getInstance()->getTableName()." str ON str.schedule_task_item_bill_item_id = t.id
            WHERE t.schedule_task_item_id = ".$this->id." ORDER BY p.id");

        $stmt->execute();

        $productivities = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $stmt = $pdo->prepare("SELECT t.id, COALESCE(COUNT(x.id), 0) AS total_unit
            FROM ".ScheduleTaggedBillItemTypeReferenceTable::getInstance()->getTableName()." x
            JOIN ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()." AS t ON x.schedule_task_item_bill_item_id = t.id
            JOIN ".BillItemTable::getInstance()->getTableName()." i ON t.bill_item_id = i.id
            JOIN ".BillElementTable::getInstance()->getTableName()." e ON i.element_id = e.id
            JOIN ".ProjectStructureTable::getInstance()->getTableName()." s ON e.project_structure_id = s.id
            WHERE s.root_id = ".$this->ProjectSchedule->project_structure_id."
            AND t.schedule_task_item_id = ".$this->id."
            AND i.project_revision_deleted_at IS NULL AND i.deleted_at IS NULL
            AND e.deleted_at IS NULL AND s.deleted_at IS NULL GROUP BY t.id ORDER BY t.id");

        $stmt->execute();

        $totalUnits = $stmt->fetchAll(PDO::FETCH_COLUMN|PDO::FETCH_GROUP);

        if($this->ProjectSchedule->sub_package_id > 0)
        {
            $sql = "SELECT x.id, SUM(DISTINCT ifc.final_value)
            FROM ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()." x
            JOIN ".ScheduleTaggedBillItemTypeReferenceTable::getInstance()->getTableName()." str ON str.schedule_task_item_bill_item_id = x.id
            JOIN ".SubPackageTypeReferenceTable::getInstance()->getTableName()." spr ON str.sub_package_type_reference_id = spr.id
            JOIN ".BillColumnSettingTable::getInstance()->getTableName()." bc ON spr.bill_column_setting_id = bc.id
            JOIN ".BillItemTypeReferenceTable::getInstance()->getTableName()." r ON r.bill_column_setting_id = bc.id
            JOIN ".BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName()." ifc ON r.id = ifc.relation_id AND
            CASE WHEN bc.use_original_quantity IS TRUE THEN
            ifc.column_name = '".BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT."' ELSE
            ifc.column_name = '".BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT."'
            END
            WHERE x.schedule_task_item_id = ".$this->id." AND spr.sub_package_id = ".$this->ProjectSchedule->sub_package_id." AND str.standard_type_reference_id IS NULL
            AND r.bill_item_id = x.bill_item_id AND r.include IS TRUE AND ifc.final_value <> 0
            AND bc.deleted_at IS NULL AND r.deleted_at IS NULL AND ifc.deleted_at IS NULL GROUP BY x.id ORDER BY x.id";
        }
        else
        {
            $sql = "SELECT x.id, SUM(DISTINCT ifc.final_value)
            FROM ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()." x
            JOIN ".ScheduleTaggedBillItemTypeReferenceTable::getInstance()->getTableName()." str ON str.schedule_task_item_bill_item_id = x.id
            JOIN ".PostContractStandardClaimTypeReferenceTable::getInstance()->getTableName()." pcr ON str.standard_type_reference_id = pcr.id
            JOIN ".BillColumnSettingTable::getInstance()->getTableName()." bc ON pcr.bill_column_setting_id = bc.id
            JOIN ".BillItemTypeReferenceTable::getInstance()->getTableName()." r ON r.bill_column_setting_id = bc.id
            JOIN ".BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName()." ifc ON r.id = ifc.relation_id AND
            CASE WHEN bc.use_original_quantity IS TRUE THEN
            ifc.column_name = '".BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT."' ELSE
            ifc.column_name = '".BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT."'
            END
            WHERE x.schedule_task_item_id = ".$this->id." AND str.sub_package_type_reference_id IS NULL
            AND r.bill_item_id = x.bill_item_id AND r.include IS TRUE AND ifc.final_value <> 0
            AND bc.deleted_at IS NULL AND r.deleted_at IS NULL AND ifc.deleted_at IS NULL GROUP BY x.id ORDER BY x.id";
        }

        $stmt = $pdo->prepare($sql);

        $stmt->execute();

        $qtyPerUnits = $stmt->fetchAll(PDO::FETCH_COLUMN|PDO::FETCH_GROUP);

        $recordsToUpdate = array();

        foreach($productivities as $productivity)
        {
            if(array_key_exists($productivity['schedule_task_item_bill_item_id'], $totalUnits) and array_key_exists($productivity['schedule_task_item_bill_item_id'], $qtyPerUnits))
            {
                if($productivity['productivity'] != 0)
                {
                    $hours = ($totalUnits[$productivity['schedule_task_item_bill_item_id']][0] * $qtyPerUnits[$productivity['schedule_task_item_bill_item_id']][0]) / $productivity['productivity'];

                    $hours = $productivity['number_of_gang'] != 0 ? $hours / $productivity['number_of_gang'] : $hours;
                }
                else if($productivity['productivity'] == 0 and $productivity['duration_hours'] != 0)
                {
                    $hours = $productivity['duration_hours'];
                }
                else
                {
                    $hours = 0;
                }

                $days = $this->hours_per_day != 0 ? $hours / $this->hours_per_day : 0;

                $recordsToUpdate[] = "(".$productivity['id'].", ".$productivity['schedule_task_item_bill_item_id'].", ".$hours.", ".$days.")";
            }
        }

        if(count($recordsToUpdate) > 0)
        {
            $stmt = $pdo->prepare("UPDATE ".ScheduleBillItemProductivityTable::getInstance()->getTableName()." AS prod SET
                duration_hours = q.hours, duration_days = q.days
                FROM (VALUES ".implode(',', $recordsToUpdate).")
                AS q(id, schedule_task_item_bill_item_id, hours, days)
                WHERE q.id = prod.id AND q.schedule_task_item_bill_item_id = prod.schedule_task_item_bill_item_id");

            $stmt->execute();
        }
    }

    public function distanceInWorkingDays($fromDate, $toDate)
    {
        return Utilities::distanceInWorkingDays($fromDate, $toDate, $this->ProjectSchedule->getNonWorkingDays(), $this->ProjectSchedule->exclude_saturdays, $this->ProjectSchedule->exclude_sundays);
    }

    public function computeEndDateByDuration($duration)
    {
        $endDate = $this->start_date;
        $q = $duration - 1;

        $nonWorkingDays = $this->ProjectSchedule->getNonWorkingDays();
        $excludeSaturdays = $this->ProjectSchedule->exclude_saturdays;
        $excludeSundays = $this->ProjectSchedule->exclude_sundays;

        while($q > 0)
        {
            $endDate = date('Y-m-d',strtotime("+1 day", strtotime($endDate)));

            if(!Utilities::isNonWorkingDay($endDate, $nonWorkingDays, $excludeSaturdays, $excludeSundays))
                $q--;
        }

        return $endDate;
    }
}
