<?php

/**
 * ProjectSchedule
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    buildspace
 * @subpackage model
 * @author     1337 developers
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class ProjectSchedule extends BaseProjectSchedule
{
    const TYPE_MAIN_PROJECT = 1;
    const TYPE_SUB_PACKAGE = 2;

    const PRINT_TYPE_PLAN = 2;
    const PRINT_TYPE_ACTUAL = 4;

    const DEFAULT_GANTT_NUMBER_OF_DAYS = 100;

    public function delete(Doctrine_Connection $conn = null)
    {
        Doctrine_Query::create()
            ->delete('ScheduleTaskItem i')
            ->where('i.project_schedule_id = ?', $this->id)
            ->execute();

        parent::delete($conn);
    }

    public function getNonWorkingDays()
    {
        $nonWorkingDays = Utilities::getCalendarEventsByProject($this->ProjectStructure, GlobalCalendar::TYPE_HOLIDAY);

        $projectScheduleWorkingDays = DoctrineQuery::create()->select('e.event_date')
            ->from('ScheduleCalendarEventWorkingDay e')
            ->where('e.project_schedule_id = ?', $this->id)
            ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
            ->execute();

        $workingDays = new SplFixedArray(count($projectScheduleWorkingDays));

        foreach($projectScheduleWorkingDays as $idx => $day)
        {
            $workingDays[$idx] = $day['event_date'];
        }

        unset($projectScheduleWorkingDays);

        foreach($nonWorkingDays as $idx => $date)
        {
            $day = date('N', strtotime($date));

            switch($day)
            {
                case 6:
                    if(!$this->exclude_saturdays)
                        $nonWorkingDays->offsetUnset($idx);
                    break;
                case 7:
                    if(!$this->exclude_sundays)
                        $nonWorkingDays->offsetUnset($idx);
                    break;
                default:
                    break;
            }

            if(in_array($date, $workingDays->toArray()))
            {
                $nonWorkingDays->offsetUnset($idx);
            }
        }

        return $nonWorkingDays;
    }

    /*
     * This is to get the maximum end date from the list of schedule task items
     * so that we know to determine how many days to be displayed in the gantt chart.
     * We use actual end date (not planned end date) as the maximum end date
     */
    public function getMaxEndDate()
    {
        $pdo  = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT DISTINCT t.id, t.start_date, t.end_date,
        t.completed_date, t.progress, t.hours_per_day, t.priority, t.lft, t.level
        FROM " .ScheduleTaskItemTable::getInstance()->getTableName(). " t
        WHERE t.project_schedule_id = " . $this->id . " AND t.temp_deleted IS FALSE
        ORDER BY t.priority, t.lft, t.level");

        $stmt->execute();
        $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $nonWorkingDays = $this->getNonWorkingDays();
        $excludeSaturdays = $this->exclude_saturdays;
        $excludeSundays = $this->exclude_sundays;

        $maxDate = date('Y-m-d',strtotime("+".ProjectSchedule::DEFAULT_GANTT_NUMBER_OF_DAYS." day", strtotime($this->start_date)));

        foreach ( $items as $item )
        {
            $actualProgressDuration = ScheduleTaskItemTable::getActualTaskDuration($item['start_date'], $item['date_completed'],$item['completion_percentage'], $nonWorkingDays, $excludeSaturdays, $excludeSundays);

            $maxActualProgressEndDate = date('Y-m-d',strtotime("+".$actualProgressDuration." day", strtotime($item['start_date'])));

            $maxDate = date('Y-m-d', max(strtotime($maxDate), strtotime($item['end_date']), strtotime($maxActualProgressEndDate)));
        }

        return $maxDate;
    }

    public function getMaxDays()
    {
        //return max date plus with extra 2 days;
        return Utilities::distanceFromDateToDate($this->start_date, $this->getMaxEndDate(), false, false)+2;
    }

    public function computeStartDate($date)
    {
        while(Utilities::isNonWorkingDay($date, $this->getNonWorkingDays(), $this->exclude_saturdays, $this->exclude_sundays))
        {
            $date = strtotime("+1 day", strtotime($date));
        }

        return $date;
    }

    public function getCostVersusTimeData()
    {
        $pdo  = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT DISTINCT t.id, t.title, t.start_date, t.end_date,
        t.duration, (t.total_cost / t.duration) AS cost_per_day,  t.priority, t.lft, t.level
        FROM " .ScheduleTaskItemTable::getInstance()->getTableName(). " t
        WHERE t.project_schedule_id = " . $this->id . " AND t.temp_deleted IS FALSE
        AND (t.rgt - t.lft) = 1
        ORDER BY t.priority, t.lft, t.level");

        $stmt->execute();
        $items = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $data = array();
        $currentItemId = null;

        foreach($items as $item)
        {
            $current = strtotime($item['start_date']);
            $end = strtotime($item['end_date']);
            $monthByYear = null;

            while($current <= $end) {
                $monthByYear = date('Y-m', $current);
                if (!isset($data[$item['id']][$monthByYear])) {
                    $data[$item['id']][$monthByYear] = 0;
                }

                if(!Utilities::isNonWorkingDay(date("Y-m-d", $current), $this->getNonWorkingDays(), $this->exclude_saturdays, $this->exclude_sundays))
                {
                    $data[$item['id']][$monthByYear]++;
                }

                $current = strtotime('+1 day', $current);
            }

            if(is_null($currentItemId) or $currentItemId != $item['id'])
            {
                foreach($data[$item['id']] as $key => $duration)
                {
                    $data[$item['id']][$key] = $duration * number_format($item['cost_per_day'], 2, '.', '');
                }

                $currentItemId = $item['id'];
            }
        }

        $result = array();

        foreach($data as $itemCostByTime)
        {
            foreach($itemCostByTime as $key => $costByTime)
            {
                if (!isset($result[$key])) {
                    $result[$key] = 0;
                }

                $result[$key] +=$costByTime;
            }
        }

        unset($data);

        ksort($result);

        return $result;
    }
}
