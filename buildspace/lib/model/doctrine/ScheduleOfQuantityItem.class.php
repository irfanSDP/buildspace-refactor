<?php

/**
 * ScheduleOfQuantityItem
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    buildspace
 * @subpackage model
 * @author     1337 developers
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class ScheduleOfQuantityItem extends BaseScheduleOfQuantityItem
{
    const TYPE_HEADER = 1;
    const TYPE_WORK_ITEM = 2;

    const TYPE_HEADER_TEXT = 'HEAD';
    const TYPE_WORK_ITEM_TEXT = 'ITEM';

    const FORMULATED_COLUMN_QUANTITY = 'quantity';

    public $itemContainerAfterCopy = array();
    public $itemFormulatedColumnContainerAfterCopy = array();
    public $buildUpQuantitiesContainerAfterCopy = array();
    public $buildUpQuantitiesFormulatedColumnContainerAfterCopy = array();

    /*
     * When we change unit of measurement for item, we need to flush
     * all build up quantities since information for build up quantity
     * were saved based on dimensions in unit of measurement.
     */
    public function updateUomId($unitOfMeasurementId)
    {
        $affectedScheduleOfQuantityItems = array();

        if($this->BuildUpQuantities->count() > 0 && $this->uom_id != (integer)$unitOfMeasurementId)
        {
            $affectedScheduleOfQuantityItems = $this->deleteFormulatedColumns();

            $this->deleteBuildUpQuantities();
        }

        //if type changed reset any imported item as manual
        if($this->uom_id != $unitOfMeasurementId && $this->identifier_type != ScheduleOfQuantity::IDENTIFIER_TYPE_MANUAL)
        {
            $this->third_party_identifier = NULL;
            $this->identifier_type = ScheduleOfQuantity::IDENTIFIER_TYPE_MANUAL;
        }

        $this->uom_id = $unitOfMeasurementId;

        $this->save();

        return $affectedScheduleOfQuantityItems;
    }

    public function updateType($type)
    {
        $affectedScheduleOfQuantityItems = array();

        if($type == self::TYPE_HEADER)
        {
            $affectedScheduleOfQuantityItems = $this->deleteFormulatedColumns();

            $this->deleteBuildUpQuantities();

            $this->uom_id = NULL;
        }

        //if type changed reset any imported item as manual
        if($this->type != $type && $this->identifier_type != ScheduleOfQuantity::IDENTIFIER_TYPE_MANUAL)
        {
            $this->third_party_identifier = NULL;
            $this->identifier_type = ScheduleOfQuantity::IDENTIFIER_TYPE_MANUAL;
        }

        $this->type = (integer)$type;

        $this->save();

        return $affectedScheduleOfQuantityItems;
    }

    public function canBeDeleted()
    {
        return ScheduleOfQuantityItemTable::canBeDeletedById($this->id);
    }

    public function delete(Doctrine_Connection $conn = null)
    {
        if($this->canBeDeleted())
        {
            //we need to update any related column from formulated columns before deleting it
            $items = DoctrineQuery::create()->select('*')
                ->from('ScheduleOfQuantityItem i')
                ->andWhere('i.root_id = ?', $this->root_id)
                ->andWhere('i.schedule_of_quantity_trade_id = ?', $this->schedule_of_quantity_trade_id)
                ->andWhere('i.lft >= ? AND i.rgt <= ?', array($this->lft, $this->rgt))
                ->addOrderBy('i.lft')
                ->execute();

            $affectedItemList = array();

            foreach($items as $item)
            {
                $affectedItemList[] = $item->deleteFormulatedColumns($conn);
            }

            if($this->type == ScheduleOfQuantityItem::TYPE_HEADER)
            {
                Doctrine_Query::create()
                    ->delete('ScheduleOfQuantityItem i')
                    ->where('i.root_id = ?', $this->root_id)
                    ->andWhere('i.schedule_of_quantity_trade_id = ?', $this->schedule_of_quantity_trade_id)
                    ->andWhere('i.lft > ?', $this->lft)
                    ->andWhere('i.rgt < ?', $this->rgt)
                    ->execute();
            }

            $this->deleteBuildUpQuantities($conn);

            parent::delete($conn);

            //recalculate left-right values when deleting child nodes
            if(!$this->node->isRoot())
            {
                $first = $this->rgt + 1;
                $delta = $this->lft - $this->rgt - 1;

                Utilities::shiftRightLeftNestedSet(get_class($this), $first, $delta, $this->root_id, $conn);
            }

            return $affectedItemList;
        }
        else
        {
            throw new Exception('Schedule of quantity item with id:'.$this->id.' cannot be deleted');
        }
    }

    public function deleteFormulatedColumns(Doctrine_Connection $conn = null)
    {
        $scheduleOfQuantityItemIds = array();
        $affectedItems = array();
        $formulatedColumnIds = array();
        $nodes = null;

        $conn = $conn ? $conn : $this->getTable()->getConnection();

        try
        {
            $conn->beginTransaction();

            foreach($this->FormulatedColumns as $formulatedColumn)
            {
                $nodes = $formulatedColumn->getNodesRelatedByColumnName($formulatedColumn->column_name);

                if(is_array($nodes))
                {
                    foreach($nodes as $node)
                    {
                        $referencedNode = Doctrine_Core::getTable('ScheduleOfQuantityItemFormulatedColumn')->find($node['node_from']);

                        if($referencedNode)
                        {
                            $pattern = '/\b(R'.$this->id.')\b/i';
                            $value = preg_replace($pattern, '#REF!', $referencedNode->value);

                            $referencedNode->setFormula($value);

                            $referencedNode->save();

                            $scheduleOfQuantityItemIds[$referencedNode->relation_id] = $referencedNode->relation_id;
                        }
                    }
                }

                $formulatedColumn->delete($conn);

                $formulatedColumnIds[] = $formulatedColumn->id;
            }

            if(count($formulatedColumnIds) > 0)
            {
                //now we can remove all edges after we've updated related nodes
                Doctrine_Query::create()
                    ->delete('ScheduleOfQuantityItemEdge e')
                    ->whereIn('e.node_from', $formulatedColumnIds)
                    ->execute();

                Doctrine_Query::create()
                    ->delete('ScheduleOfQuantityItemEdge e')
                    ->whereIn('e.node_to', $formulatedColumnIds)
                    ->execute();
            }

            $conn->commit();
        }
        catch(Exception $e)
        {
            $conn->rollback();
            throw $e;
        }

        foreach($scheduleOfQuantityItemIds as $itemId)
        {
            $affectedItem = array();
            $affectedScheduleOfQuantityItem = $this->getTable()->find($itemId);

            $affectedItem['id'] = $affectedScheduleOfQuantityItem->id;

            foreach($affectedScheduleOfQuantityItem->FormulatedColumns as $formulatedColumn)
            {
                $columnName = $formulatedColumn->column_name;
                $affectedItem[$columnName."-final_value"] = $formulatedColumn->final_value;
                $affectedItem[$columnName."-value"] = $formulatedColumn->value;
                $affectedItem[$columnName.'-has_cell_reference'] = $formulatedColumn->hasCellReference();
                $affectedItem[$columnName.'-has_formula'] = $formulatedColumn->hasFormula();
            }

            array_push($affectedItems, $affectedItem);

            unset($affectedScheduleOfQuantityItem);
        }

        return $affectedItems;
    }

    public function moveTo(ScheduleOfQuantityItem $targetItem, $lastPosition=false)
    {
        $con = $this->getTable()->getConnection();

        try
        {
            $con->beginTransaction();

            if($targetItem->node->isRoot())
            {
                $priority       = $lastPosition ? $targetItem->priority + 1 : $targetItem->priority;
                $this->priority = $priority;

                $this->save();

                if(!$this->node->isRoot() and $this->node->isValidNode())
                {
                    $this->node->makeRoot($this->id);
                    $this->save();
                }

                if(!$lastPosition)
                {
                    $this->updateRootPriority($priority, $this->id);
                }
            }
            else
            {
                if($lastPosition)
                {
                    $this->node->moveAsNextSiblingOf($targetItem);
                }
                else
                {
                    $this->node->moveAsPrevSiblingOf($targetItem);
                }

                $this->priority = $targetItem->priority;

                $this->save();

                $this->refresh();
            }

            /*
             * Update priority for all nodes under the family to its root priority.
             * We exclude this step for case the target item is root node and $lastPosition is false
             * because the priority already been update by calling updateRootPriority()
             */
            if(($targetItem->node->isRoot() && $lastPosition) or !$targetItem->node->isRoot())
            {
                Doctrine_Query::create()->update('ScheduleOfQuantityItem i')
                    ->set('priority', $this->priority)
                    ->where('i.lft BETWEEN ? AND ?', array($this->lft, $this->rgt))
                    ->andWhere('i.root_id = ?', $this->root_id)
                    ->andWhere('i.schedule_of_quantity_trade_id = ?', $this->schedule_of_quantity_trade_id)
                    ->andWhere('i.priority <> ?', $this->priority)
                    ->execute();
            }

            $con->commit();

            return true;
        }
        catch(Exception $e)
        {
            $con->rollback();
            throw $e;
        }
    }

    public function copyTo(ScheduleOfQuantityItem $targetItem, $lastPosition=false)
    {
        $con = $this->getTable()->getConnection();

        try
        {
            $con->beginTransaction();

            if($this->node->hasChildren())
            {
                $children = $this->getTable()
                    ->createQuery('i')
                    ->select('i.id, i.description, i.uom_id, i.schedule_of_quantity_trade_id, i.type, i.level')
                    ->where('i.root_id = ?', $this->root_id)
                    ->andWhere('i.schedule_of_quantity_trade_id = ?', $this->schedule_of_quantity_trade_id)
                    ->addWhere('i.lft > ? AND i.rgt < ?', array($this->lft, $this->rgt))
                    ->orderBy('i.lft ASC')
                    ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY_HIERARCHY)
                    ->execute();
            }
            else
            {
                $children = false;
            }

            $cloneItem                                = new ScheduleOfQuantityItem();
            $cloneItem->description                   = $this->description;
            $cloneItem->type                          = $this->type;
            $cloneItem->uom_id                        = $this->uom_id;
            $cloneItem->identifier_type               = ScheduleOfQuantity::IDENTIFIER_TYPE_MANUAL;
            $cloneItem->schedule_of_quantity_trade_id = $this->schedule_of_quantity_trade_id;

            if($targetItem->node->isRoot())
            {
                $priority = $lastPosition ? $targetItem->priority + 1 : $targetItem->priority;
                $cloneItem->priority = $priority;

                $cloneItem->save($con);

                $cloneItem->getTable()->getTree()->createRoot($cloneItem);

                if(!$lastPosition)
                {
                    $this->updateRootPriority($priority, $cloneItem->id);
                }
            }
            else
            {
                if($lastPosition)
                {
                    $cloneItem->node->insertAsNextSiblingOf($targetItem);
                }
                else
                {
                    $cloneItem->node->insertAsPrevSiblingOf($targetItem);
                }

                $cloneItem->priority = $targetItem->priority;

                $cloneItem->save($con);
            }

            $cloneItem->refresh();

            array_push($this->itemContainerAfterCopy, array(
                'id' => $cloneItem->id,
                'origin' => $this->id
            ));

            if($children)
            {
                $this->_loadNestedSetData($children, $this, $cloneItem);
            }

            if($cloneItem->type != ScheduleOfQuantityItem::TYPE_HEADER)
            {
                $cloneItem->copyFormulatedColumnsFromItem($this, $this);
            }

            $this->updateItemRowLinkingAfterCopy();

            $cloneItem->copyBuildUpQuantitiesFromItem($this);

            $con->commit();

            $cloneItem->refresh(true);

            return $cloneItem;
        }
        catch(Exception $e)
        {
            $con->rollback();
            throw $e;
        }
    }

    public function copyFormulatedColumnsFromItem(ScheduleOfQuantityItem $item, ScheduleOfQuantityItem $containerScope)
    {
        if($formulatedColumn = $item->getFormulatedColumnByName(ScheduleOfQuantityItem::FORMULATED_COLUMN_QUANTITY))
        {
            $cloneFormulatedColumn = $this->getFormulatedColumnByName(ScheduleOfQuantityItem::FORMULATED_COLUMN_QUANTITY);

            $cloneFormulatedColumn = $cloneFormulatedColumn ? $cloneFormulatedColumn : new ScheduleOfQuantityItemFormulatedColumn();

            $cloneFormulatedColumn->column_name = $formulatedColumn->column_name;
            $cloneFormulatedColumn->linked = $formulatedColumn->linked;
            $cloneFormulatedColumn->has_build_up = $formulatedColumn->has_build_up;
            $cloneFormulatedColumn->value = $formulatedColumn->value;
            $cloneFormulatedColumn->final_value = $formulatedColumn->final_value;
            $cloneFormulatedColumn->relation_id = $this->id;

            $cloneFormulatedColumn->save();

            array_push($containerScope->itemFormulatedColumnContainerAfterCopy, array(
                'id' => $cloneFormulatedColumn->id,
                'origin' => $formulatedColumn->id
            ));

            ScheduleOfQuantityItemEdgeTable::getInstance()->getConnection()->fetchAssoc("INSERT INTO ".ScheduleOfQuantityItemEdgeTable::getInstance()->getTableName()."
                (node_from, node_to, column_name, created_at, updated_at)
                SELECT ".$cloneFormulatedColumn->id.", old.node_to, old.column_name, NOW(), NOW() FROM ".ScheduleOfQuantityItemEdgeTable::getInstance()->getTableName()." AS old
                WHERE old.node_from = ".$formulatedColumn->id." AND old.deleted_at IS NULL");
        }
    }

    public function copyBuildUpQuantitiesFromItem(ScheduleOfQuantityItem $originBillItem)
    {
        if($originBillItem->BuildUpQuantities->count() > 0)
        {
            $buildUpQuantities = $originBillItem->BuildUpQuantities;

            $dimensions = array();

            if($this->uom_id == 0)
            {
                $this->uom_id = $originBillItem->uom_id;
                $this->save();

                $this->refresh();
            }

            foreach($this->UnitOfMeasurement->Dimensions as $dimension)
            {
                $dimensions[$dimension->id.'-dimension_column'] = $dimension->id;
            }

            foreach($buildUpQuantities as $buildUpQuantity)
            {
                $cloneBuildUpQuantity = $buildUpQuantity->copy();
                $cloneBuildUpQuantity->schedule_of_quantity_item_id = $this->id;
                $cloneBuildUpQuantity->can_edit = true;

                $cloneBuildUpQuantity->save();

                array_push($this->buildUpQuantitiesContainerAfterCopy, array(
                    'id' => $cloneBuildUpQuantity->id,
                    'origin' => $buildUpQuantity->id
                ));

                $formulatedColumns = DoctrineQuery::create()->select('c.value, c.final_value, c.column_name')
                    ->from('ScheduleOfQuantityBuildUpFormulatedColumn c')
                    ->where('c.relation_id = ?', $buildUpQuantity->id)
                    ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
                    ->execute();

                foreach($formulatedColumns as $formulatedColumn)
                {
                    if($formulatedColumn['column_name'] == ScheduleOfQuantityBuildUpItem::FORMULATED_COLUMN_FACTOR or array_key_exists($formulatedColumn['column_name'], $dimensions))
                    {
                        $cloneFormulatedColumn = new ScheduleOfQuantityBuildUpFormulatedColumn();
                        $cloneFormulatedColumn->relation_id = $cloneBuildUpQuantity->id;
                        $cloneFormulatedColumn->value = $formulatedColumn['value'];
                        $cloneFormulatedColumn->final_value = $formulatedColumn['final_value'];
                        $cloneFormulatedColumn->column_name = $formulatedColumn['column_name'];

                        $cloneFormulatedColumn->save();

                        array_push($this->buildUpQuantitiesFormulatedColumnContainerAfterCopy, array(
                            'id' => $cloneFormulatedColumn->id,
                            'origin' => $formulatedColumn['id']
                        ));

                        ScheduleOfQuantityBuildUpEdgeTable::getInstance()->getConnection()->fetchAssoc("INSERT INTO ".ScheduleOfQuantityBuildUpEdgeTable::getInstance()->getTableName()." (node_from, node_to, column_name, created_at, updated_at)
                            SELECT ".$cloneFormulatedColumn->id.", old.node_to, old.column_name, NOW(), NOW() FROM ".ScheduleOfQuantityBuildUpEdgeTable::getInstance()->getTableName()." AS old
                            WHERE old.node_from = ".$formulatedColumn['id']." AND old.deleted_at IS NULL");
                    }
                }

                $cloneBuildUpQuantity->calculateTotal();

                unset($cloneBuildUpQuantity);
            }

            $this->updateBuildUpQuantitiesRowLinkingAfterCopy();

            return true;
        }

        return false;
    }

    public function updateBuildUpQuantitiesRowLinkingAfterCopy()
    {
        if(count($this->buildUpQuantitiesFormulatedColumnContainerAfterCopy) > 0)
        {
            $formulatedColumnIdList = array();
            $formulatedColumnOriginList = array();

            foreach($this->buildUpQuantitiesFormulatedColumnContainerAfterCopy as $list)
            {
                array_push($formulatedColumnIdList, $list['id']);
                array_push($formulatedColumnOriginList, $list['origin']);
            }

            $records = DoctrineQuery::create()->select('e.id, e.node_from, e.node_to')
                ->from('ScheduleOfQuantityBuildUpEdge e')
                ->whereIn('e.node_from', $formulatedColumnIdList)
                ->andWhereIn('e.node_to', $formulatedColumnOriginList)
                ->addOrderBy('e.node_from ASC')
                ->execute();

            foreach($records as $record)
            {
                $nodeFrom = $record->NodeFrom;
                if($nodeFrom->hasCellReference())
                {
                    $value = $nodeFrom->value;
                    foreach($this->buildUpQuantitiesContainerAfterCopy as $buildUpList)
                    {
                        $pattern = '/\b(R'.$buildUpList['origin'].')\b/i';
                        $value = preg_replace($pattern, 'R'.$buildUpList['id'], $value);
                    }

                    $nodeFrom->value = $value;
                    $nodeFrom->save();
                }
            }

            $this->buildUpQuantitiesFormulatedColumnContainerAfterCopy = array();
            $this->buildUpQuantitiesContainerAfterCopy = array();
        }
    }

    public function updateItemRowLinkingAfterCopy()
    {
        if(count($this->itemFormulatedColumnContainerAfterCopy) > 0)
        {
            $formulatedColumnIdList = array();
            $formulatedColumnOriginList = array();

            foreach($this->itemFormulatedColumnContainerAfterCopy as $list)
            {
                array_push($formulatedColumnIdList, $list['id']);
                array_push($formulatedColumnOriginList, $list['origin']);
            }

            $records = DoctrineQuery::create()->select('e.id, e.node_from, e.node_to')
                ->from('ScheduleOfQuantityItemEdge e')
                ->whereIn('e.node_from', $formulatedColumnIdList)
                ->andWhereIn('e.node_to', $formulatedColumnOriginList)
                ->addOrderBy('e.node_from ASC')
                ->execute();

            foreach($records as $record)
            {
                $nodeFrom = $record->NodeFrom;

                if($nodeFrom->hasCellReference())
                {
                    $value = $nodeFrom->value;

                    foreach($this->itemContainerAfterCopy as $list)
                    {
                        $pattern = '/\b(R'.$list['origin'].')\b/i';
                        $value = preg_replace($pattern, 'R'.$list['id'], $value);
                    }

                    $nodeFrom->value = $value;

                    $nodeFrom->save();
                }
                unset($nodeFrom);
            }

            $this->itemFormulatedColumnContainerAfterCopy = array();
            $this->itemContainerAfterCopy = array();
        }
    }

    private function _loadNestedSetData(Array $nestedSetData, ScheduleOfQuantityItem $containerScope, ScheduleOfQuantityItem $parent)
    {
        $nestedSetData = array_reverse($nestedSetData, true);

        foreach($nestedSetData as $nestedSet)
        {
            $children = array();
            $originItem = $this->getTable()->find($nestedSet['id']);

            unset($nestedSet['id']);

            if(array_key_exists('__children', $nestedSet))
            {
                $children = (array) $nestedSet['__children'];
                unset($nestedSet['__children']);
            }

            $obj = new ScheduleOfQuantityItem();

            foreach($nestedSet as $key => $value)
            {
                $func = 'set' . Doctrine_Inflector::classify($key);
                $obj->$func($value);
            }

            $obj->third_party_identifier = NULL;
            $obj->identifier_type = ScheduleOfQuantity::IDENTIFIER_TYPE_MANUAL;

            $parent->node->addChild($obj);

            $obj->priority = $parent->priority;

            $obj->save();

            array_push($containerScope->itemContainerAfterCopy, array(
                'id' => $obj->id,
                'origin' => $originItem->id
            ));

            if($obj->type != ScheduleOfQuantityItem::TYPE_HEADER)
            {
                $obj->copyFormulatedColumnsFromItem($originItem, $containerScope);
                $obj->copyBuildUpQuantitiesFromItem($originItem);
            }

            if(is_array($children) and !empty($children))
            {
                $this->_loadNestedSetData($children, $containerScope, $obj);
            }
        }
    }

    public function indent()
    {
        $indented = false;
        $previousRoot = $this->getPreviousRoot();

        if($this->node->isRoot() and $previousRoot and $previousRoot->type == ScheduleOfQuantityItem::TYPE_HEADER)
        {
            $this->node->moveAsLastChildOf($previousRoot);

            $this->refresh();

            $pdo = $this->getTable()->getConnection()->getDbh();

            $stmt = $pdo->prepare("UPDATE ".$this->getTable()->getTableName()." SET priority = ".$previousRoot->priority."
            WHERE root_id = ".$previousRoot->root_id." AND priority <> ".$previousRoot->priority."
            AND schedule_of_quantity_trade_id = ".$this->schedule_of_quantity_trade_id." AND deleted_at IS NULL");

            $stmt->execute();

            $indented = true;
        }
        else if(!$this->node->isRoot() and $this->node->hasPrevSibling() and $this->node->getPrevSibling()->type == ScheduleOfQuantityItem::TYPE_HEADER)
        {
            $this->node->moveAsLastChildOf($this->node->getPrevSibling());

            $this->refresh();

            $indented = true;
        }

        return $indented;
    }

    public function outdent()
    {
        if(!$this->node->isRoot() and ($this->type == ScheduleOfQuantityItem::TYPE_HEADER or ($this->type != ScheduleOfQuantityItem::TYPE_HEADER and !$this->node->hasNextSibling())))
        {
            $parent = $this->node->getParent();

            if(!$parent || !$parent->node)
            {
                return false;
            }
            
            $siblings = $this->getTable()
                ->createQuery('i')
                ->select('i.id')
                ->where('i.root_id = ?',$this->root_id)
                ->andWhere('i.schedule_of_quantity_trade_id = ?', $this->schedule_of_quantity_trade_id)
                ->andWhere('i.level = ?', $this->level)
                ->andWhere('i.lft BETWEEN ? AND ?', array($parent->lft, $parent->rgt))
                ->andWhere('i.lft > ?', $this->rgt)
                ->addOrderBy('i.lft ASC')
                ->execute();

            foreach($siblings as $sibling)
            {
                $sibling->node->moveAsLastChildOf($this);

                $this->refresh();
            }

            unset($siblings);

            if(!$parent->node->isRoot())
            {
                $this->node->moveAsNextSiblingOf($parent);
            }
            else
            {
                $this->node->makeRoot($this->id);

                parent::save();

                $this->priority = $parent->priority + 1;

                $this->save();

                $this->updateRootPriority($parent->priority + 1, $this->id);
            }

            $this->refresh();

            return true;
        }
        else
        {
            return false;
        }
    }

    public function getFormulatedColumnByName($columnName, $hydrate=null)
    {
        return ScheduleOfQuantityItemTable::getFormulatedColumnByRelationIdAndColumnName($this->id, $columnName, $hydrate);
    }

    public function getPreviousRoot()
    {
        $rootId = $this->root_id > 0 ? $this->root_id : $this->id;
        $root = $this->getTable()->find($rootId);

        return $this->getTable()
            ->createQuery('i')
            ->select('i.id')
            ->where('i.root_id = i.id')
            ->addWhere('i.schedule_of_quantity_trade_id = ?', $this->schedule_of_quantity_trade_id)
            ->addWhere('i.priority < ?', $root->priority)
            ->orderBy('i.priority DESC')
            ->limit(1)
            ->fetchOne();
    }

    public function deleteBuildUpQuantities(Doctrine_Connection $conn = null)
    {
        ScheduleOfQuantityItemTable::deleteBuildUpQuantitiesByItemId($this->id);
    }

    public function updateRootPriority($priority, $excludeId=null)
    {
        ScheduleOfQuantityItemTable::updateRootPriority($priority, $this->schedule_of_quantity_trade_id, $excludeId);
    }

    public function getBuildUpTotalByCanEditStatus($canEdit=true)
    {
        return ScheduleOfQuantityItemTable::getBuildUpTotalByIdAndCanEditStatus($this->id, $canEdit);
    }

    public function postSave($event)
    {
        if($this->deleted_at == NULL)
        {
            ScheduleOfQuantityItemTable::updateTimeStamp($this);
            ScheduleOfQuantityTradeTable::updateTimeStamp($this->Trade);
        }

        return parent::postSave($event);
    }

    public function unlinkFromBillBuildUpQuantity($billItemId, $billColumnSettingId, $type)
    {
        $pdo = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT DISTINCT c.id
            FROM ".ScheduleOfQuantityItemTable::getInstance()->getTableName()." c
            JOIN ".ScheduleOfQuantityBillItemXrefTable::getInstance()->getTableName()." xref ON xref.schedule_of_quantity_item_id = c.id
            JOIN ".ScheduleOfQuantityItemTable::getInstance()->getTableName()." p ON c.lft BETWEEN p.lft AND p.rgt
            JOIN ".ScheduleOfQuantityTradeTable::getInstance()->getTableName()." trade ON p.schedule_of_quantity_trade_id = trade.id
            JOIN ".ScheduleOfQuantityTable::getInstance()->getTableName()." soq ON trade.schedule_of_quantity_id = soq.id
            WHERE p.id = ".$this->id." AND xref.bill_item_id = ".$billItemId." AND xref.bill_column_setting_id = ".$billColumnSettingId." AND xref.type = ".$type."
            AND c.root_id = p.root_id AND c.schedule_of_quantity_trade_id = p.schedule_of_quantity_trade_id AND c.deleted_at IS NULL AND p.deleted_at IS NULL
            AND soq.project_structure_id = ".$this->Trade->ScheduleOfQuantity->ProjectStructure->root_id." AND trade.deleted_at IS NULL AND soq.deleted_at IS NULL");

        $stmt->execute();

        $items = $stmt->fetchAll(PDO::FETCH_COLUMN, 0);

        if(count($items) > 0)
        {
            try
            {
                $pdo->beginTransaction();

                $stmt = $pdo->prepare("DELETE FROM ".ScheduleOfQuantityBillItemXrefTable::getInstance()->getTableName()."
                WHERE schedule_of_quantity_item_id IN (".implode(',', $items).") AND bill_item_id = ".$billItemId."
                AND bill_column_setting_id = ".$billColumnSettingId." AND type = ".$type);

                $stmt->execute();

                $pdo->commit();
            }
            catch(Exception $e)
            {
                $pdo->rollBack();

                throw $e;
            }
        }

        return $items;
    }
}
