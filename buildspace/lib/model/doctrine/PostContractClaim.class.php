<?php

/**
 * PostContractClaim
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    buildspace
 * @subpackage model
 * @author     1337 developers
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class PostContractClaim extends BasePostContractClaim
{
    const TYPE_LETTER_OF_AWARD                      = 1;
    const TYPE_WATER_DEPOSIT                        = 2;
    const TYPE_DEPOSIT                              = 3;
    const TYPE_OUT_OF_CONTRACT_ITEM                 = 4;
    const TYPE_PURCHASE_ON_BEHALF                   = 5;
    const TYPE_ADVANCED_PAYMENT                     = 6;
    const TYPE_WORK_ON_BEHALF                       = 7;
    const TYPE_WORK_ON_BEHALF_BACK_CHARGE           = 8;
    const TYPE_PENALTY                              = 9;
    const TYPE_PERMIT                               = 10;
    const TYPE_POST_CONTRACT_CLAIM_MATERIAL_ON_SITE = 11;
    const TYPE_CLAIM_CERTIFICATE                    = 12;
    const TYPE_VARIATION_ORDER                      = 32;
    const TYPE_MATERIAL_ON_SITE                     = 64;
    const TYPE_REQUEST_FOR_VARIATION_CLAIM          = 128;
    const TYPE_DEBIT_CREDIT_NOTE                    = 256;

    const STATUS_APPROVED  = 1;
    const STATUS_PENDING   = 2;
    const STATUS_PREPARING = 4;

	const TYPE_ADVANCE_PAYMENT_TEXT             = "ADVANCE PAYMENT";
    const TYPE_DEPOSIT_TEXT                     = "DEPOSIT";
    const TYPE_PURCHASE_ON_BEHALF_TEXT          = "PURCHASE ON BEHALF";
    const TYPE_PERMIT_TEXT                      = "PERMIT";
    const TYPE_OUT_OF_CONTRACT_ITEM_TEXT        = "KONG SI KONG";
    const TYPE_WORK_ON_BEHALF_TEXT              = "WORK ON BEHALF";
    const TYPE_WORK_ON_BEHALF_BACK_CHARGE_TEXT  = "WORK ON BEHALF (BACKCHARGE)";
    const TYPE_PENALTY_TEXT                     = "PENALTY";
    const TYPE_WATER_DEPOSIT_TEXT               = "UTILITY";
    const TYPE_VARIATION_ORDER_TEXT             = "VARIATION ORDER";
    const TYPE_MATERIAL_ON_SITE_TEXT            = "MATERIAL ON SITE";
    const TYPE_CLAIM_CERTIFICATE_TEXT           = "CLAIM CERTIFICATE";
    const TYPE_REQUEST_FOR_VARIATION_CLAIM_TEXT = "REQUEST FOR VARIATION CLAIMS";
    const TYPE_DEBIT_CREDIT_NOTE_TEXT           = "DEBIT AND CREDIT NOTE";

    public static function getModuleName($type)
    {
        switch($type)
        {
            case self::TYPE_ADVANCED_PAYMENT:
                return self::TYPE_ADVANCE_PAYMENT_TEXT;
            case self::TYPE_DEPOSIT:
                return self::TYPE_DEPOSIT_TEXT;
            case self::TYPE_PURCHASE_ON_BEHALF:
                return self::TYPE_PURCHASE_ON_BEHALF_TEXT;
            case self::TYPE_PERMIT:
                return self::TYPE_PERMIT_TEXT;
            case self::TYPE_OUT_OF_CONTRACT_ITEM:
                return self::TYPE_OUT_OF_CONTRACT_ITEM_TEXT;
            case self::TYPE_WORK_ON_BEHALF:
                return self::TYPE_WORK_ON_BEHALF_TEXT;
            case self::TYPE_WORK_ON_BEHALF_BACK_CHARGE:
                return self::TYPE_WORK_ON_BEHALF_BACK_CHARGE_TEXT;
            case self::TYPE_PENALTY:
                return self::TYPE_PENALTY_TEXT;
            case self::TYPE_WATER_DEPOSIT:
                return self::TYPE_WATER_DEPOSIT_TEXT;
            case self::TYPE_VARIATION_ORDER:
                return self::TYPE_VARIATION_ORDER_TEXT;
            case self::TYPE_POST_CONTRACT_CLAIM_MATERIAL_ON_SITE:
                return self::TYPE_MATERIAL_ON_SITE_TEXT;
            case self::TYPE_CLAIM_CERTIFICATE:
                return self::TYPE_CLAIM_CERTIFICATE_TEXT;
            case self::TYPE_REQUEST_FOR_VARIATION_CLAIM:
                return self::TYPE_REQUEST_FOR_VARIATION_CLAIM_TEXT;
            case self::TYPE_DEBIT_CREDIT_NOTE:
                return self::TYPE_DEBIT_CREDIT_NOTE_TEXT;
            default:
                throw new Exception('Invalid type.');
        }
    }

    public static function getObjectByModuleIdentifier($moduleIdentifier, $objectId)
    {
        $object = null;

        switch($moduleIdentifier)
        {
            case self::TYPE_CLAIM_CERTIFICATE:
                $object = Doctrine_Core::getTable('ClaimCertificate')->find($objectId);
                break;
            case self::TYPE_VARIATION_ORDER:
                $object = Doctrine_Core::getTable('VariationOrder')->find($objectId);
                break;
        }

        return $object;
    }

    public function preSave($event)
    {
        if( $this->isNew() ) $this->status = self::STATUS_PREPARING;

        return parent::preSave($event);
    }

    public function save(Doctrine_Connection $conn = null)
    {
        if($this->status == self::STATUS_APPROVED)
        {
            if($this->ProjectStructure->PostContract->published_type == PostContract::PUBLISHED_TYPE_NEW and
            $openClaimRevision = $this->ProjectStructure->PostContract->getOpenClaimRevision() and $openClaimRevision->ClaimCertificate->id)
            {
                $this->claim_certificate_id = $openClaimRevision->ClaimCertificate->id;
            }
        }

        parent::save();
    }

    public function postSave($event)
    {
        if( $this->status == self::STATUS_PENDING )
        {
            ContractManagementClaimVerifierTable::initialiseVerifierList($this->ProjectStructure, $this->type, $this->id);
            $this->onClaimReview();
        }

        return parent::postSave($event);
    }

    public function onClaimReview()
    {
        if( ContractManagementClaimVerifierTable::isApproved($this->ProjectStructure, $this->type, $this->id) )
        {
            $this->status = self::STATUS_APPROVED;
            $this->save();
        }
        elseif(ContractManagementClaimVerifierTable::isRejected($this->ProjectStructure, $this->type, $this->id))
        {
            $this->status = self::STATUS_PREPARING;
            $this->save();
        }
    }

    public function canAddNewClaim()
    {
        $record = DoctrineQuery::create()->select('c.id')
            ->from('PostContractClaimClaim c')
            ->where('c.post_contract_claim_id = ?',$this->id)
            ->andWhere('c.status = ?', PostContractClaimClaim::STATUS_PROGRESSING)
            ->limit(1)
            ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
            ->fetchOne();

        return $record ? false : true;
    }

    public function getViewingClaim()
    {
        $record = DoctrineQuery::create()->select('c.*')
            ->from('PostContractClaimClaim c')
            ->where('c.post_contract_claim_id = ?',$this->id)
            ->andWhere('c.is_viewing IS TRUE')
            ->limit(1)
            ->fetchOne();

        return $record;
    }

    public function canEditClaimAmount()
    {
        $record = DoctrineQuery::create()->select('c.id')
            ->from('PostContractClaimClaim c')
            ->where('c.post_contract_claim_id = ?',$this->id)
            ->andWhere('c.status = ?', PostContractClaimClaim::STATUS_PROGRESSING)
            ->andWhere('c.is_viewing IS TRUE')
            ->limit(1)
            ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
            ->fetchOne();

        return $record ? true : false;
    }

    public function canBeEdited()
    {
        return $this->status == PostContractClaim::STATUS_PREPARING;
    }

    public function canClaim()
    {
        return ($this->status == PostContractClaim::STATUS_APPROVED) && ($this->Claims->count() > 0);
    }

    public function getClaimItems($claimRevisionId = null)
    {
        $pdo = $this->getTable()->getConnection()->getDbh();

        if( $claimRevisionId )
        {
            $stmt = $pdo->prepare("SELECT i.id AS post_contract_claim_item_id, ROUND(COALESCE(SUM(ci.current_quantity), 0), 2) AS current_quantity, ROUND(COALESCE(SUM(ci.current_amount), 0), 2) AS current_amount, ROUND(COALESCE(SUM(ci.current_percentage), 0), 2) AS current_percentage
            FROM " . PostContractClaimItemTable::getInstance()->getTableName() . " i
            JOIN " . PostContractClaimClaimTable::getInstance()->getTableName() . " c ON i.post_contract_claim_id = c.post_contract_claim_id
            LEFT JOIN " . PostContractClaimClaimItemTable::getInstance()->getTableName() . " ci ON ci.post_contract_claim_claim_id = c.id AND ci.post_contract_claim_item_id = i.id
            LEFT JOIN " . ClaimCertificateTable::getInstance()->getTableName() . " cert ON cert.id = c.claim_certificate_id
            LEFT JOIN " . PostContractClaimRevisionTable::getInstance()->getTableName() . " rev ON rev.id = cert.post_contract_claim_revision_id
            WHERE i.post_contract_claim_id = {$this->id}
            AND rev.id = " . $claimRevisionId . "
            AND i.deleted_at IS NULL AND c.deleted_at IS NULL AND ci.deleted_at IS NULL GROUP BY i.id");

            $stmt->execute();

            $currentValues = $stmt->fetchAll(PDO::FETCH_UNIQUE | PDO::FETCH_ASSOC);

            $previousClaimCertificates = PostContractClaimRevisionTable::getClaimCertificates($claimRevisionId, '<');

            $selectedRevisionClause = ( count($certIds = array_column($previousClaimCertificates, 'id')) > 0 ) ? "AND c.claim_certificate_id in (" . implode(',', $certIds) . ")" : "";

            $stmt = $pdo->prepare("SELECT DISTINCT i.id AS post_contract_claim_item_id, SUM(COALESCE(ci.current_quantity, 0)) as previous_quantity, SUM(COALESCE(ci.current_amount, 0)) as previous_amount, SUM(COALESCE(ci.current_percentage, 0)) as previous_percentage
            FROM " . PostContractClaimItemTable::getInstance()->getTableName() . " i
            JOIN " . PostContractClaimClaimTable::getInstance()->getTableName() . " c ON i.post_contract_claim_id = c.post_contract_claim_id
            LEFT JOIN " . PostContractClaimClaimItemTable::getInstance()->getTableName() . " ci ON ci.post_contract_claim_claim_id = c.id AND ci.post_contract_claim_item_id = i.id
            LEFT JOIN " . ClaimCertificateTable::getInstance()->getTableName() . " cert ON cert.id = c.claim_certificate_id
            LEFT JOIN " . PostContractClaimRevisionTable::getInstance()->getTableName() . " rev ON rev.id = cert.post_contract_claim_revision_id
            WHERE i.post_contract_claim_id = " . $this->id . "
            {$selectedRevisionClause}
            AND i.deleted_at IS NULL AND c.deleted_at IS NULL AND ci.deleted_at IS NULL group by i.id");

            $stmt->execute();

            $previousValues = $stmt->fetchAll(PDO::FETCH_UNIQUE | PDO::FETCH_ASSOC);

            $previousClaimCertificates = PostContractClaimRevisionTable::getClaimCertificates($claimRevisionId, '<=');

            $selectedRevisionClause = ( count($certIds = array_column($previousClaimCertificates, 'id')) > 0 ) ? "AND c.claim_certificate_id in (" . implode(',', $certIds) . ")" : "";

            $stmt = $pdo->prepare("SELECT DISTINCT i.id AS post_contract_claim_item_id, SUM(COALESCE(ci.current_quantity, 0)) as up_to_date_quantity, SUM(COALESCE(ci.current_amount, 0)) as up_to_date_amount, SUM(COALESCE(ci.current_percentage, 0)) as up_to_date_percentage
            FROM " . PostContractClaimItemTable::getInstance()->getTableName() . " i
            JOIN " . PostContractClaimClaimTable::getInstance()->getTableName() . " c ON i.post_contract_claim_id = c.post_contract_claim_id
            LEFT JOIN " . PostContractClaimClaimItemTable::getInstance()->getTableName() . " ci ON ci.post_contract_claim_claim_id = c.id AND ci.post_contract_claim_item_id = i.id
            LEFT JOIN " . ClaimCertificateTable::getInstance()->getTableName() . " cert ON cert.id = c.claim_certificate_id
            LEFT JOIN " . PostContractClaimRevisionTable::getInstance()->getTableName() . " rev ON rev.id = cert.post_contract_claim_revision_id
            WHERE i.post_contract_claim_id = " . $this->id . "
            {$selectedRevisionClause}
            AND i.deleted_at IS NULL AND c.deleted_at IS NULL AND ci.deleted_at IS NULL group by i.id");

            $stmt->execute();

            $claimItems = $stmt->fetchAll(PDO::FETCH_ASSOC);

            foreach($claimItems as $key => $claimItem)
            {
                $claimItems[$key]['previous_quantity']   = $previousValues[ $claimItem['post_contract_claim_item_id'] ]['previous_quantity'] ?? 0;
                $claimItems[$key]['previous_percentage'] = $previousValues[ $claimItem['post_contract_claim_item_id'] ]['previous_percentage'] ?? 0;
                $claimItems[$key]['previous_amount']     = $previousValues[ $claimItem['post_contract_claim_item_id'] ]['previous_amount'] ?? 0;

                $claimItems[$key]['current_quantity']   = $currentValues[ $claimItem['post_contract_claim_item_id'] ]['current_quantity'] ?? 0;
                $claimItems[$key]['current_percentage'] = $currentValues[ $claimItem['post_contract_claim_item_id'] ]['current_percentage'] ?? 0;
                $claimItems[$key]['current_amount']     = $currentValues[ $claimItem['post_contract_claim_item_id'] ]['current_amount'] ?? 0;
            }
        }
        else
        {
            $stmt = $pdo->prepare("SELECT DISTINCT i.id AS post_contract_claim_item_id, ci.current_quantity, ci.current_amount, ci.current_percentage, ci.up_to_date_quantity, ci.up_to_date_amount, ci.up_to_date_percentage,
            COALESCE(pci.up_to_date_quantity, 0) AS previous_quantity, COALESCE(pci.up_to_date_amount, 0) AS previous_amount, COALESCE(pci.up_to_date_percentage, 0) AS previous_percentage
            FROM " . PostContractClaimItemTable::getInstance()->getTableName() . " i
            JOIN " . PostContractClaimClaimTable::getInstance()->getTableName() . " c ON i.post_contract_claim_id = c.post_contract_claim_id
            LEFT JOIN " . PostContractClaimClaimItemTable::getInstance()->getTableName() . " ci ON ci.post_contract_claim_claim_id = c.id AND ci.post_contract_claim_item_id = i.id
            LEFT JOIN " . PostContractClaimClaimTable::getInstance()->getTableName() . " pc ON pc.post_contract_claim_id = c.post_contract_claim_id AND pc.revision = c.revision - 1
            LEFT JOIN " . PostContractClaimClaimItemTable::getInstance()->getTableName() . " pci ON pci.post_contract_claim_claim_id = pc.id AND pci.post_contract_claim_item_id = i.id
            LEFT JOIN " . ClaimCertificateTable::getInstance()->getTableName() . " cert ON cert.id = c.claim_certificate_id
            LEFT JOIN " . PostContractClaimRevisionTable::getInstance()->getTableName() . " rev ON rev.id = cert.post_contract_claim_revision_id
            WHERE i.post_contract_claim_id = " . $this->id . " 
            AND c.is_viewing IS TRUE
            AND i.deleted_at IS NULL AND c.deleted_at IS NULL AND ci.deleted_at IS NULL AND pc.deleted_at IS NULL AND pci.deleted_at IS NULL");

            $stmt->execute();

            $claimItems = $stmt->fetchAll(PDO::FETCH_ASSOC);
        }

        return $claimItems;
    }

    public static function getPostContractClaimTopManagementVerifiers($projectId, $moduleIdentifier)
    {
        $client = new GuzzleHttp\Client(array(
            'debug'    => false,
            'verify'   => sfConfig::get('app_guzzle_ssl_verification'),
            'base_uri' => sfConfig::get('app_e_project_url')
        ));

        try
        {
            $res = $client->post('buildspace/getPostContractClaimTopManagementVerifiers', [
                'form_params' => [
                    'projectId'         => $projectId,
                    'module_identifier' => $moduleIdentifier,
                ]
            ]);

            $content                = $res->getBody()->getContents();
            $jsonObj                = json_decode($content);
            $topManagementVerifiers = (array) $jsonObj->topManagementVerifiers;
        }
        catch(Exception $e)
        {
            throw $e;
        }

        return $topManagementVerifiers;
    }

    public static function getLatestFreeSequence($projectId, $moduleIdentifier)
    {
        $pdo = PostContractClaimTable::getInstance()->getConnection()->getDbh();

        $query = "SELECT max(c.sequence) AS max_sequence
                  FROM bs_post_contract_claims c
                  WHERE c.project_structure_id = {$projectId}
                  AND c.type = {$moduleIdentifier}
                  AND deleted_at IS NULL;";

        $stmt = $pdo->prepare($query);

        $stmt->execute();

        $result = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $sequence = 0;

        if($result[0]['max_sequence'] !== null)
        {
            $sequence = $result[0]['max_sequence'] + 1;
        }

        return $sequence;
    }
}
