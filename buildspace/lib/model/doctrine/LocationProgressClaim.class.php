<?php

/**
 * LocationProgressClaim
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 *
 * @package    buildspace
 * @subpackage model
 * @author     1337 developers
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class LocationProgressClaim extends BaseLocationProgressClaim
{
    public function updateCurrentQuantity($value)
    {
        $value = is_numeric($value) ? $value : 0;

        $billItemQty = $this->getBillItemQty();

        $proRatedQty   = ($this->LocationBillItemQuantityProrate->percentage != 0) ? ($this->LocationBillItemQuantityProrate->percentage / 100) * $billItemQty : 0;
        $previousClaim = $this->getPreviousClaim(Doctrine_Core::HYDRATE_ARRAY);

        if($previousClaim)
        {
            $previousUpToDateQuantity   = $previousClaim['up_to_date_quantity'];
            $previousUpToDatePercentage = $previousClaim['up_to_date_percentage'];
        }
        else
        {
            $previousUpToDateQuantity   = 0;
            $previousUpToDatePercentage = 0;
        }

        if($previousUpToDateQuantity + $value > $proRatedQty)
        {
            $currentQuantity = $value - (($previousUpToDateQuantity + $value) - $proRatedQty);
        }
        else
        {
            $currentQuantity = $value;
        }

        $currentQuantity   = round($currentQuantity, 2);
        $currentPercentage = round($currentQuantity /  $proRatedQty * 100, 2);

        $this->current_quantity   = $currentQuantity;
        $this->current_percentage = $currentPercentage;

        $this->up_to_date_quantity   = round($previousUpToDateQuantity + $currentQuantity, 2);
        $this->up_to_date_percentage = round($previousUpToDatePercentage + $currentPercentage, 2);
    }

    public function updateCurrentPercentage($value)
    {
        $value = is_numeric($value) ? $value : 0;

        $billItemQty = $this->getBillItemQty();

        $previousClaim = $this->getPreviousClaim(Doctrine_Core::HYDRATE_ARRAY);

        if($previousClaim)
        {
            $previousUpToDateQuantity   = $previousClaim['up_to_date_quantity'];
            $previousUpToDatePercentage = $previousClaim['up_to_date_percentage'];
        }
        else
        {
            $previousUpToDateQuantity   = 0;
            $previousUpToDatePercentage = 0;
        }

        if($previousUpToDatePercentage + $value > 100)
        {
            $currentPercentage = $value - (($previousUpToDatePercentage + $value) - 100);
        }
        else
        {
            $currentPercentage = $value;
        }

        $currentPercentage = round($currentPercentage, 2);
        $proRatedQty       = ($this->LocationBillItemQuantityProrate->percentage != 0) ? ($this->LocationBillItemQuantityProrate->percentage / 100) * $billItemQty : 0;
        $currentQuantity   = ($currentPercentage != 0) ? round(($currentPercentage / 100) * $proRatedQty, 2) : 0;

        $this->current_quantity   = $currentQuantity;
        $this->current_percentage = $currentPercentage;

        $this->up_to_date_quantity   = round($previousUpToDateQuantity + $currentQuantity, 2);
        $this->up_to_date_percentage = round($previousUpToDatePercentage + $currentPercentage, 2);
    }

    public function updateUpToDateQuantity($value)
    {
        $value = is_numeric($value) ? $value : 0;

        $billItemQty   = $this->getBillItemQty();
        $proRatedQty   = ($this->LocationBillItemQuantityProrate->percentage != 0) ? ($this->LocationBillItemQuantityProrate->percentage / 100) * $billItemQty : 0;
        $previousClaim = $this->getPreviousClaim(Doctrine_Core::HYDRATE_ARRAY);

        if($previousClaim)
        {
            $previousUpToDateQuantity   = $previousClaim['up_to_date_quantity'];
            $previousUpToDatePercentage = $previousClaim['up_to_date_percentage'];
        }
        else
        {
            $previousUpToDateQuantity   = 0;
            $previousUpToDatePercentage = 0;
        }

        if($value > $proRatedQty)
        {
            $upToDateQuantity = $proRatedQty;
        }
        else
        {
            $upToDateQuantity = $value;
        }

        $upToDateQuantity   = round($upToDateQuantity, 2);
        $upToDatePercentage = round($upToDateQuantity / $proRatedQty * 100, 2);

        $this->up_to_date_quantity   = $upToDateQuantity;
        $this->up_to_date_percentage = $upToDatePercentage;

        $this->current_quantity   = round($upToDateQuantity - $previousUpToDateQuantity, 2);
        $this->current_percentage = round($upToDatePercentage - $previousUpToDatePercentage, 2);
    }

    public function updateUpToDatePercentage($value)
    {
        $value = is_numeric($value) ? $value : 0;

        $billItemQty   = $this->getBillItemQty();
        $proRatedQty   = ($this->LocationBillItemQuantityProrate->percentage != 0) ? ($this->LocationBillItemQuantityProrate->percentage / 100) * $billItemQty : 0;
        $previousClaim = $this->getPreviousClaim(Doctrine_Core::HYDRATE_ARRAY);

        if($previousClaim)
        {
            $previousUpToDateQuantity   = $previousClaim['up_to_date_quantity'];
            $previousUpToDatePercentage = $previousClaim['up_to_date_percentage'];
        }
        else
        {
            $previousUpToDateQuantity   = 0;
            $previousUpToDatePercentage = 0;
        }

        if($value > 100)
        {
            $upToDatePercentage = 100;
        }
        else
        {
            $upToDatePercentage = $value;
        }

        $upToDatePercentage = round($upToDatePercentage, 2);
        $upToDateQuantity   = ($upToDatePercentage != 0) ? round(($upToDatePercentage / 100) * $proRatedQty, 2) : 0;

        $this->up_to_date_quantity   = $upToDateQuantity;
        $this->up_to_date_percentage = $upToDatePercentage;

        $this->current_quantity   = round($upToDateQuantity - $previousUpToDateQuantity, 2);
        $this->current_percentage = round($upToDatePercentage - $previousUpToDatePercentage, 2);
    }

    public function getPreviousClaim($hydrate = null)
    {
        $prevProjectRevision = PostContractClaimRevisionTable::getPreviousProjectRevision($this->PostContractClaimRevision->PostContract, $this->PostContractClaimRevision->version);

        $query = DoctrineQuery::create()->select('c.*')
            ->from('LocationProgressClaim c')
            ->where('c.post_contract_claim_revision_id = ?', $prevProjectRevision['id'])
            ->andWhere('c.location_bill_item_quantity_prorates_id = ?', $this->location_bill_item_quantity_prorates_id)
            ->limit(1);

        if($hydrate)
        {
            $query->setHydrationMode($hydrate);

        }

        return $query->fetchOne();
    }

    public function updateStandardBillClaim()
    {
        $currentProjectRevision = PostContractClaimRevisionTable::getCurrentProjectRevision($this->PostContractClaimRevision->PostContract, false);

        if(!$currentProjectRevision)
        {
            throw new Exception('No open claim revision. Cannot update bill claim.');
        }

        $locationBillItemQuantityProrate = $this->LocationBillItemQuantityProrate;

        $claimTypeRef = DoctrineQuery::create()
            ->select('t.id, t.post_contract_id, t.bill_column_setting_id, t.counter, t.new_name')
            ->from('PostContractStandardClaimTypeReference t')
            ->where('t.post_contract_id = ? AND t.bill_column_setting_id = ? AND t.counter = ?', array(
                $this->PostContractClaimRevision->post_contract_id,
                $locationBillItemQuantityProrate->bill_column_setting_id,
                $locationBillItemQuantityProrate->unit
            ))
            ->fetchOne();

        if ( !$claimTypeRef )
        {
            $claimTypeRef                         = new PostContractStandardClaimTypeReference();
            $claimTypeRef->post_contract_id       = $this->PostContractClaimRevision->post_contract_id;
            $claimTypeRef->bill_column_setting_id = $locationBillItemQuantityProrate->bill_column_setting_id;
            $claimTypeRef->counter                = $locationBillItemQuantityProrate->unit;

            $claimTypeRef->save();
        }

        $claimItem = DoctrineQuery::create()->select('*')
            ->from('PostContractStandardClaim c')
            ->where('c.claim_type_ref_id = ? AND c.bill_item_id = ? AND c.revision_id = ? ', array(
                $claimTypeRef->id,
                $locationBillItemQuantityProrate->LocationAssignment->bill_item_id,
                $currentProjectRevision->id
            ))
            ->fetchOne();

        if ( !$claimItem )
        {
            $claimItem = new PostContractStandardClaim();
            $claimItem->setClaimTypeRefId($claimTypeRef->id);
            $claimItem->setBillItemId($locationBillItemQuantityProrate->LocationAssignment->bill_item_id);
            $claimItem->setRevisionId($currentProjectRevision->id);
        }

        $pdo = $this->getTable()->getConnection()->getDbh();

        $stmt = $pdo->prepare("SELECT COALESCE(SUM(c.up_to_date_quantity), 0)
        FROM " . LocationProgressClaimTable::getInstance()->getTableName() . " c
        JOIN " . LocationBillItemQuantityProrateTable::getInstance()->getTableName() . " q ON c.location_bill_item_quantity_prorates_id = q.id
        JOIN " . LocationAssignmentTable::getInstance()->getTableName() . " l ON q.location_assignment_id = l.id
        WHERE c.post_contract_claim_revision_id = ".$currentProjectRevision->id."
        AND q.bill_column_setting_id = ".$locationBillItemQuantityProrate->bill_column_setting_id."
        AND q.unit = ".$locationBillItemQuantityProrate->unit."
        AND l.bill_item_id = ".$locationBillItemQuantityProrate->LocationAssignment->bill_item_id);

        $stmt->execute();

        $totalUpToDateQuantity = $stmt->fetch(PDO::FETCH_COLUMN, 0);

        $claimItem->updateUpToDateQty($totalUpToDateQuantity, $currentProjectRevision);
        $claimItem->save();
    }

    protected function getBillItemQty()
    {
        $pdo = $this->getTable()->getConnection()->getDbh();

        $locationBillItemQuantityProrate = $this->LocationBillItemQuantityProrate;

        $stmt = $pdo->prepare("SELECT l.use_original_qty
        FROM " . LocationBQSettingTable::getInstance()->getTableName() . " l
        WHERE l.bill_column_setting_id = ".$locationBillItemQuantityProrate->bill_column_setting_id);

        $stmt->execute();

        $locationBQSetting = $stmt->fetch(PDO::FETCH_ASSOC);

        $useOriginalQty = ($locationBQSetting) ? $locationBQSetting['use_original_qty'] : true;

        $quantityFieldName = $useOriginalQty ? BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT : BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT;

        $stmt = $pdo->prepare("SELECT COALESCE(fc.final_value, 0) AS value
        FROM " . BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName() . " fc
        JOIN " . BillItemTypeReferenceTable::getInstance()->getTableName() . " r ON fc.relation_id = r.id
        JOIN " . LocationAssignmentTable::getInstance()->getTableName() . " a ON a.bill_item_id = r.bill_item_id
        WHERE a.id = ".$locationBillItemQuantityProrate->location_assignment_id." AND r.bill_column_setting_id = " . $locationBillItemQuantityProrate->bill_column_setting_id . "
        AND fc.column_name = '" . $quantityFieldName . "' AND fc.final_value <> 0
        AND r.deleted_at IS NULL AND fc.deleted_at IS NULL");

        $stmt->execute();

        $billItemQty = $stmt->fetch(PDO::FETCH_COLUMN, 0);

        return !empty($billItemQty) ? $billItemQty : 0;
    }
}
