<?php

/**
 * VariationOrderBuildUpQuantitySummary
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    buildspace
 * @subpackage model
 * @author     1337 developers
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class VariationOrderBuildUpQuantitySummary extends BaseVariationOrderBuildUpQuantitySummary
{
    const ROUNDING_TYPE_DISABLED = 1;
    const ROUNDING_TYPE_UPWARD = 2;
    const ROUNDING_TYPE_DOWNWARD = 4;
    const ROUNDING_TYPE_NEAREST_WHOLE_NUMBER = 8;
    const ROUNDING_TYPE_NEAREST_TENTH = 16;

    public function calculateTotalQuantity()
    {
        $result = DoctrineQuery::create()->select('COALESCE(SUM(b.total), 0) as total')
            ->from('VariationOrderBuildUpQuantityItem b')
            ->where('b.variation_order_item_id = ?', $this->variation_order_item_id)
            ->andWhere('b.type = ?', $this->type)
            ->limit(1)
            ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
            ->fetchOne();

        $totalQuantity = $result['total'];

        if($totalQuantity != $this->total_quantity)
        {
            $this->total_quantity = $totalQuantity;
            $this->save();
        }

        return $this->total_quantity;
    }

    public function getTotalQuantityAfterConversion()
    {
        $linkedTotalQuantity = $this->VariationOrderItem->getScheduleOfQuantitiesTotalAmount($this->type);
        $finalQuantity = $this->calculateTotalQuantity() + $linkedTotalQuantity;
        $conversionFactorAmount = $this->conversion_factor_amount;
        $operator = $this->conversion_factor_operator;

        if($this->apply_conversion_factor)
        {
            $exp = $finalQuantity.$operator.$conversionFactorAmount;

            $evaluator = new EvalMath(true, true);
            $evaluator->suppress_errors = true;
            $evaluatedValue = $evaluator->evaluate($exp);

            $finalQuantity = $evaluatedValue ? $evaluatedValue : 0;
        }

        switch($this->rounding_type)
        {
            case self::ROUNDING_TYPE_UPWARD:
                $finalQuantity  = ceil($finalQuantity);
                break;
            case self::ROUNDING_TYPE_DOWNWARD:
                $finalQuantity  =  floor($finalQuantity);
                break;
            case self::ROUNDING_TYPE_NEAREST_WHOLE_NUMBER:
                $finalQuantity  =  round($finalQuantity);
                break;
            case self::ROUNDING_TYPE_NEAREST_TENTH:
                $finalQuantity  =  round($finalQuantity * 10) / 10;
                break;
            default:
                $finalQuantity  =  number_format($finalQuantity, 2, '.', '');
        }

        if($finalQuantity != $this->final_quantity)
        {
            $this->final_quantity = $finalQuantity;
            $this->save();
        }

        return $this->final_quantity;
    }

    public function save(Doctrine_Connection $conn = null)
    {
        //reset all conversion factor information when it's disabled
        if($this->apply_conversion_factor === 'false')
        {
            $this->conversion_factor_amount = 0;
            $this->conversion_factor_operator = Constants::ARITHMETIC_OPERATOR_ADDITION;
        }

        $isNew = $this->isNew();

        parent::save($conn);

        if($this->deleted_at == NULL and !$isNew)
        {
            $this->refresh();

            if($this->type == VariationOrderBuildUpQuantityItem::TYPE_ADDITIONAL_QTY)
            {
                $this->VariationOrderItem->addition_quantity = $this->final_quantity;
                $this->VariationOrderItem->has_addition_build_up_quantity = true;
            }
            else
            {
                $this->VariationOrderItem->omission_quantity = $this->final_quantity;
                $this->VariationOrderItem->has_omission_build_up_quantity = true;
            }

            $this->VariationOrderItem->save($conn);
        }
    }
}
