<?php

/**
 * ScheduleOfQuantityItemTable
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class ScheduleOfQuantityItemTable extends Doctrine_Table
{
    /**
     * Returns an instance of this class.
     *
     * @return object ScheduleOfQuantityItemTable
     */
    public static function getInstance()
    {
        return Doctrine_Core::getTable('ScheduleOfQuantityItem');
    }

    public static function updateLinkedValues($scheduleOfQuantityItemId, PDO $pdo=null)
    {
        if(!$pdo)
        {
            $pdo = self::getInstance()->getConnection()->getDbh();
        }

        /*
         * First: We need to update linked_total_quantity in BillBuildUpQuantitySummary to a new qty. We also need all the information
         * from the updated BillBuildUpQuantitySummary to use it in next update steps
         */
        $stmt = $pdo->prepare("UPDATE ".BillBuildUpQuantitySummaryTable::getInstance()->getTableName()." AS s SET linked_total_quantity = sum.total
            FROM(SELECT COALESCE(SUM(xfc.final_value), 0) AS total, x.bill_item_id, x.bill_column_setting_id, x.type
                FROM ".ScheduleOfQuantityItemFormulatedColumnTable::getInstance()->getTableName()." xfc
                JOIN ".ScheduleOfQuantityBillItemXrefTable::getInstance()->getTableName()." x ON x.schedule_of_quantity_item_id = xfc.relation_id
                JOIN ".ScheduleOfQuantityBillItemXrefTable::getInstance()->getTableName()." x2 ON x2.bill_item_id = x.bill_item_id AND x2.bill_column_setting_id = x.bill_column_setting_id AND x2.type = x.type
                WHERE x2.schedule_of_quantity_item_id = ".$scheduleOfQuantityItemId."
                AND xfc.deleted_at IS NULL GROUP BY x.bill_item_id, x.bill_column_setting_id, x.type) AS sum
            WHERE sum.bill_item_id = s.bill_item_id AND sum.bill_column_setting_id = s.bill_column_setting_id AND sum.type = s.type AND s.deleted_at IS NULL
            RETURNING s.id, s.bill_item_id, s.linked_total_quantity, s.total_quantity, s.rounding_type, s.apply_conversion_factor, s.rounding_type, s.conversion_factor_amount, s.conversion_factor_operator");

        $stmt->execute();

        /*
         * Second: Get all updated records from BillBuildUpQuantitySummary and calculate the final_quantity. We have to do this because
         * in order to get final_quantity we have to calculate it with any conversion factor (if applied). All the calculated final_quantity
         * will be insert into a list that will be used in sql query to update BillBuildUpQuantitySummary final_quantity
         */
        $returnSummaries = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $evaluator = new EvalMath(true, true);
        $evaluator->suppress_errors = true;

        $summariesToUpdate = new SplFixedArray(count($returnSummaries));

        $billItemIds = array();

        foreach($returnSummaries as $key => $returnSummary)
        {
            $finalQuantity = $returnSummary['total_quantity'] + $returnSummary['linked_total_quantity'];

            if($returnSummary['apply_conversion_factor'])
            {
                $exp = $finalQuantity.$returnSummary['conversion_factor_operator'].$returnSummary['conversion_factor_amount'];

                $evaluatedValue = $evaluator->evaluate($exp);

                $finalQuantity = $evaluatedValue ? $evaluatedValue : 0;
            }

            switch($returnSummary['rounding_type'])
            {
                case BillBuildUpQuantitySummary::ROUNDING_TYPE_UPWARD:
                    $finalQuantity = ceil($finalQuantity);
                    break;
                case BillBuildUpQuantitySummary::ROUNDING_TYPE_DOWNWARD:
                    $finalQuantity = floor($finalQuantity);
                    break;
                case BillBuildUpQuantitySummary::ROUNDING_TYPE_NEAREST_WHOLE_NUMBER:
                    $finalQuantity = round($finalQuantity);
                    break;
                case BillBuildUpQuantitySummary::ROUNDING_TYPE_NEAREST_TENTH:
                    $finalQuantity = round($finalQuantity * 10) / 10;
                    break;
                default:
                    $finalQuantity = number_format($finalQuantity, 2, '.', '');
            }

            $summariesToUpdate[$key] = "(".$returnSummary['id'].", ".$finalQuantity.")";

            $billItemIds[] = $returnSummary['bill_item_id'];
        }

        unset($returnSummaries);

        if($summariesToUpdate->count() > 0)
        {
            $stmt = $pdo->prepare("UPDATE ".BillBuildUpQuantitySummaryTable::getInstance()->getTableName()." AS sum SET
                final_quantity = c.final_quantity
                FROM (VALUES ".implode(',', $summariesToUpdate->toArray()).")
                AS c(id, final_quantity)
                WHERE c.id = sum.id");

            $stmt->execute();
        }

        /*
         * Third: Update BillItemTypeReferenceFormulatedColumn final_value to the updated BillBuildUpQuantitySummary final_qty. This is the qty value for bill item
         * based on BillItem, BillColumnSetting and type (original qty or remeasurement)
         */
        $stmt = $pdo->prepare("UPDATE ".BillItemTypeReferenceFormulatedColumnTable::getInstance()->getTableName()." AS fc
        SET value = s.final_quantity, final_value = s.final_quantity FROM (SELECT r.id, sum.final_quantity,
        CASE WHEN sum.type = ".BillBuildUpQuantityItem::QUANTITY_PER_UNIT_ORIGINAL."
            THEN '".BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT."'
            ELSE '".BillItemTypeReference::FORMULATED_COLUMN_QTY_PER_UNIT_REMEASUREMENT."'
        END AS column_name
        FROM ".BillItemTypeReferenceTable::getInstance()->getTableName()." r
        JOIN ".BillBuildUpQuantitySummaryTable::getInstance()->getTableName()." sum
        ON r.bill_item_id = sum.bill_item_id AND r.bill_column_setting_id = sum.bill_column_setting_id
        JOIN ".ScheduleOfQuantityBillItemXrefTable::getInstance()->getTableName()." x
        ON x.bill_item_id = sum.bill_item_id AND x.bill_column_setting_id = sum.bill_column_setting_id AND x.type = sum.type
        WHERE x.schedule_of_quantity_item_id = ".$scheduleOfQuantityItemId." AND sum.deleted_at IS NULL AND r.deleted_at IS NULL)
        AS s(id, final_quantity, column_name)
        WHERE s.id = fc.relation_id AND s.column_name = fc.column_name AND fc.deleted_at IS NULL
        RETURNING fc.id, fc.column_name");

        $stmt->execute();

        $returnRecords = $stmt->fetchAll(PDO::FETCH_ASSOC);

        /*
         * Fourth: get all updated records from BillItemTypeReferenceFormulatedColumn and check if there's any node that uses it's value as referenced values.
         * Then update the nodes value to the updated qty column
         */
        foreach($returnRecords as $record)
        {
            $nodes = BillItemTypeReferenceFormulatedColumnTable::getInstance()->getNodesRelatedByRelationIdAndColumnName($record['id'], $record['column_name']);

            foreach($nodes as $node)
            {
                if($referencedNode = BillItemTypeReferenceFormulatedColumnTable::getInstance()->find($node['node_from']))
                {
                    $referencedNode->setFormula($referencedNode->value);

                    $referencedNode->save(self::getInstance()->getConnection());

                    $billItemIds[] = $referencedNode->BillItemTypeReference->bill_item_id;

                    unset($referencedNode);
                }
            }

            unset($nodes);
        }

        /*
            * Insert into recalculate bill item table so we can track the affected bil items and do recalculation
            * after schedule of qty item updates.
            */
        if(count($billItemIds) > 0)
        {
            $billItemIds = array_values(array_unique($billItemIds));

            $stmt = $pdo->prepare("INSERT INTO ".RecalculateBillItemTable::getInstance()->getTableName()."
                (bill_item_id, type, created_at, updated_at)
                SELECT i.id, ".RecalculateBillItem::TYPE_SCHEDULE_OF_QUANTITY_UPDATE.", NOW(), NOW() FROM ".BillItemTable::getInstance()->getTableName()." AS i WHERE
                i.id IN (".implode(',', $billItemIds).") AND i.project_revision_deleted_at IS NULL AND i.deleted_at IS NULL AND
                NOT EXISTS (SELECT 1 FROM ".RecalculateBillItemTable::getInstance()->getTableName()." AS r
                WHERE r.bill_item_id = i.id AND r.type = ".RecalculateBillItem::TYPE_SCHEDULE_OF_QUANTITY_UPDATE.")");

            $stmt->execute();

            $stmt = $pdo->prepare("UPDATE ".BillTypeTable::getInstance()->getTableName()." AS b SET status = ".BillType::STATUS_SCHEDULE_OF_QUANTITY_RECALCULATE_ELEMENT."
                FROM (SELECT DISTINCT e.project_structure_id FROM ".BillElementTable::getInstance()->getTableName()." e
                JOIN ".BillItemTable::getInstance()->getTableName()." i ON i.element_id = e.id WHERE i.id IN(".implode(',', $billItemIds).")
                AND i.project_revision_deleted_at IS NULL AND i.deleted_at IS NULL AND e.deleted_at IS NULL) AS p
                WHERE p.project_structure_id = b.project_structure_id AND b.deleted_at IS NULL");

            $stmt->execute();
        }
    }

    public static function canBeDeletedById($scheduleOfQuantityItemId)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $scheduleOfQuantityItem = self::getInstance()
            ->createQuery('i')->select('i.root_id, i.lft, i.rgt, i.schedule_of_quantity_trade_id')
            ->where('i.id = ?', $scheduleOfQuantityItemId)
            ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
            ->limit(1)
            ->fetchOne();

        $count = 0;

        if($scheduleOfQuantityItem)
        {
            $stmt = $pdo->prepare("SELECT COUNT(x.id) FROM ".ScheduleOfQuantityBillItemXrefTable::getInstance()->getTableName()." x
            JOIN ".ScheduleOfQuantityItemTable::getInstance()->getTableName()." i ON x.schedule_of_quantity_item_id = i.id
            WHERE i.lft >= ".$scheduleOfQuantityItem['lft']." AND i.rgt <= ".$scheduleOfQuantityItem['rgt']."
            AND i.schedule_of_quantity_trade_id = ".$scheduleOfQuantityItem['schedule_of_quantity_trade_id']."
            AND i.root_id = ".$scheduleOfQuantityItem['root_id']." AND i.deleted_at IS NULL");

            $stmt->execute();

            $count = $stmt->fetch(PDO::FETCH_COLUMN, 0);
        }

        return $count > 0 ? false : true;
    }

    public static function getFormulatedColumnByRelationIdAndColumnName($id, $columnName, $hydrate=null)
    {
        $query = DoctrineQuery::create()->select('*')
            ->from('ScheduleOfQuantityItemFormulatedColumn c')
            ->where('c.relation_id = ?', $id)
            ->andWhere('c.column_name = ?', $columnName)
            ->limit(1);

        if(!is_null($hydrate))
        {
            $query->setHydrationMode($hydrate);
        }

        return $query->fetchOne();
    }

    public static function createItemFromLastRow($previousItem, ScheduleOfQuantityTrade $trade, $fieldName=null, $fieldValue=null)
    {
        $item = new ScheduleOfQuantityItem();

        $item->schedule_of_quantity_trade_id = $trade->id;
        $item->identifier_type = ScheduleOfQuantity::IDENTIFIER_TYPE_MANUAL;

        if($fieldName)
        {
            $columns = array_keys(self::getInstance()->getColumns());
            if(in_array($fieldName, $columns) and $fieldName != ScheduleOfQuantityItem::FORMULATED_COLUMN_QUANTITY)
            {
                $fieldValue = ($fieldName == 'uom_id' and $fieldValue == -1) ? null : $fieldValue;
                $item->{'set'.sfInflector::camelize($fieldName)}($fieldValue);
            }
        }

        if($fieldName != 'type')
        {
            $item->type = ScheduleOfQuantityItem::TYPE_WORK_ITEM;
        }

        $asRoot = true;
        $priority = 0;

        if($previousItem instanceof ScheduleOfQuantityItem)
        {
            if($previousItem->node->isRoot())
            {
                $priority = $previousItem->priority + 1;
            }
            else
            {
                $asRoot = false;
                $item->node->insertAsNextSiblingOf($previousItem);

                $priority = $previousItem->priority;
            }
        }

        $item->priority = $priority;

        $item->save();

        if($asRoot)
        {
            $item->getTable()->getTree()->createRoot($item);

            $item->updateRootPriority($priority, $item->id);
        }

        return $item;
    }

    public static function createItem(ScheduleOfQuantityItem $nextItem)
    {
        $item                                = new ScheduleOfQuantityItem();
        $item->schedule_of_quantity_trade_id = $nextItem->schedule_of_quantity_trade_id;
        $item->type                          = ScheduleOfQuantityItem::TYPE_WORK_ITEM;
        $item->identifier_type               = ScheduleOfQuantity::IDENTIFIER_TYPE_MANUAL;

        if($nextItem->node->isRoot())
        {
            $priority = $nextItem->priority;

            $item->priority = $priority;

            $item->save();

            $node = $item->node;

            if ($node->isValidNode())
            {
                $node->makeRoot($item->id);
            }
            else
            {
                $item->getTable()->getTree()->createRoot($item);
            }

            $item->updateRootPriority($priority, $item->id);
        }
        else
        {
            $item->node->insertAsPrevSiblingOf($nextItem);
            $item->priority = $nextItem->priority;
        }

        $item->save();

        return $item;
    }

    public static function updateRootPriority($priority, $tradeId, $excludeId = null)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $sqlUpdateRoot = "UPDATE ".self::getInstance()->getTableName()." SET priority = priority + 1
            WHERE schedule_of_quantity_trade_id =".$tradeId." AND priority >=".$priority." AND id = root_id";

        if($excludeId and $excludeId > 0)
        {
            $sqlUpdateRoot .= " AND id <> ".$excludeId;
        }

        $sqlUpdateRoot .= " AND deleted_at IS NULL";

        $stmt = $pdo->prepare($sqlUpdateRoot);

        $stmt->execute();

        //update children priority same as root priority
        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." AS i SET priority = r.priority
            FROM ".self::getInstance()->getTableName()." AS r
            WHERE i.root_id = r.id AND i.id <> r.id AND i.priority <> r.priority AND i.schedule_of_quantity_trade_id = ".$tradeId."
            AND i.deleted_at IS NULL");

        $stmt->execute();
    }

    public static function deleteBuildUpQuantitiesByItemId($scheduleOfQuantityItemId)
    {
        $con = self::getInstance()->getConnection();

        $con->fetchAssoc("UPDATE ".ScheduleOfQuantityBuildUpFormulatedColumnTable::getInstance()->getTableName()." SET deleted_at = NOW() WHERE
        relation_id IN (SELECT id FROM ".ScheduleOfQuantityBuildUpItemTable::getInstance()->getTableName()."
        WHERE schedule_of_quantity_item_id = ".$scheduleOfQuantityItemId." AND deleted_at IS NULL)");

        Doctrine_Query::create()
            ->delete('ScheduleOfQuantityBuildUpItem i')
            ->where('i.schedule_of_quantity_item_id = ?', $scheduleOfQuantityItemId)
            ->execute();

        self::updateLinkedValues($scheduleOfQuantityItemId);
    }

    public static function getBuildUpTotalByIdAndCanEditStatus($scheduleOfQuantityItemId, $canEdit=true)
    {
        $val = ScheduleOfQuantityBuildUpItemTable::getInstance()
            ->createQuery('bi')->select('COALESCE(SUM(bi.total), 0) AS total')
            ->where('bi.schedule_of_quantity_item_id = ?', $scheduleOfQuantityItemId)
            ->andWhere('bi.can_edit = ?', $canEdit)
            ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
            ->fetchOne();

        return $val['total'];
    }

    public static function updateTimeStamp(ScheduleOfQuantityItem $scheduleOfQuantityItem)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $stmt = $pdo->prepare("UPDATE ".ScheduleOfQuantityItemTable::getInstance()->getTableName()." SET updated_at = NOW() WHERE id = ".$scheduleOfQuantityItem->id." AND deleted_at IS NULL");
        $stmt->execute(array());

        $stmt = $pdo->prepare("UPDATE ".ScheduleOfQuantityTradeTable::getInstance()->getTableName()." SET updated_at = NOW() WHERE id = ".$scheduleOfQuantityItem->schedule_of_quantity_trade_id." AND deleted_at IS NULL");
        $stmt->execute(array());
    }

}