<?php

/**
 * MaterialOnSiteItemTable
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class MaterialOnSiteItemTable extends Doctrine_Table {

	private $importedMaterialOnSiteItemsChildren = array();

	/**
	 * Returns an instance of this class.
	 *
	 * @return object MaterialOnSiteItemTable
	 */
	public static function getInstance()
	{
		return Doctrine_Core::getTable('MaterialOnSiteItem');
	}

	public static function createItemFromLastRow($previousItem, $materialOnSiteId, $fieldName = null, $fieldValue = null)
	{
		$item = new MaterialOnSiteItem();

		$item->material_on_site_id = $materialOnSiteId;

		if ( $fieldName )
		{
			$columns = array_keys(self::getInstance()->getColumns());

			if ( in_array($fieldName, $columns) )
			{
				$fieldValue = ( $fieldName == 'uom_id' and $fieldValue == - 1 ) ? null : $fieldValue;

				if ( $fieldName == 'rate' )
				{
					$fieldValue = is_numeric($fieldValue) ? $fieldValue : 0;
					$item->rate = number_format($fieldValue, 2, '.', '');
				}
				else
				{
					$item->{'set' . sfInflector::camelize($fieldName)}($fieldValue);
				}
			}
		}

		if ( $fieldName != 'type' )
		{
			$item->type = ResourceItem::TYPE_WORK_ITEM;
		}

		$asRoot   = true;
		$priority = 0;

		if ( $previousItem )
		{
			if ( $previousItem->node->isRoot() )
			{
				$priority = $previousItem->priority + 1;
			}
			else
			{
				$asRoot = false;

				$item->node->insertAsNextSiblingOf($previousItem);

				$priority = $previousItem->priority;
			}
		}

		$item->priority = $priority;
		$item->save();

		if ( $asRoot )
		{
			$item->getTable()->getTree()->createRoot($item);

			$item->updateRootPriority($priority, $item->id);
		}

		return $item;
	}

	public static function createItem(MaterialOnSiteItem $nextItem, $materialOnSiteId)
	{
		$item                      = new MaterialOnSiteItem();
		$item->material_on_site_id = $materialOnSiteId;
		$item->type                = ResourceItem::TYPE_WORK_ITEM;

		if ( $nextItem->node->isRoot() )
		{
			$priority = $nextItem->priority;

			$item->priority = $priority;

			$item->save();

			$node = $item->node;

			if ( $node->isValidNode() )
			{
				$node->makeRoot($item->id);
			}
			else
			{
				$item->getTable()->getTree()->createRoot($item);
			}

			$item->updateRootPriority($priority, $item->id);
		}
		else
		{
			$item->node->insertAsPrevSiblingOf($nextItem);
			$item->priority = $nextItem->priority;
		}

		$item->save();

		return $item;
	}

	public static function importStockOutItems(Doctrine_Connection $conn, $targetItemId, MaterialOnSite $mos, Array $resourceItemIds)
	{
		$resourceTradeId = - 1;

		if ( count($resourceItemIds) > 0 && array_search("", $resourceItemIds) === false )
		{
			$pdo = $conn->getDbh();

			$targetItem = $targetItemId > 0 ? self::getInstance()->find($targetItemId) : false;

			$newDOQuantities = StockInDeliveryOrderItemQuantityTable::getOverAllItemQuantitiesFilterByResourceItemIdByProject($mos->Project, $resourceItemIds);
			$newSOQuantities = StockOutUsedQuantityItemQuantityTable::getOverAllItemQuantitiesFilterByResourceItemIdByProject($mos->Project, $resourceItemIds);

			$items = StockInInvoiceItemTable::queryToGetResourceItemWithHead($resourceItemIds);

			foreach ( $items as $item )
			{
				$resourceTradeId = $item['resource_trade_id'];
			}

			$resourceTrade     = new ResourceTrade();
			$resourceTrade->id = $resourceTradeId;

			$invoiceItemRemarks = StockInInvoiceItemTable::getInvoiceRemarks($mos->Project, $resourceTrade);

			$priority = self::getTargetedResourceItemPriority($mos, $targetItem);

			if ( $items and !empty( $items ) )
			{
				$trees = array();

				// Node Stack. Used to help building the hierarchy
				$stack = array();

				foreach ( $items as $item )
				{
					$generatedRemarks = null;
					$doQuantity       = 0;
					$soQuantity       = 0;

					if ( isset( $newDOQuantities[$item['id']] ) )
					{
						$doQuantity = $newDOQuantities[$item['id']];
					}

					if ( isset( $newSOQuantities[$item['id']] ) )
					{
						$soQuantity = $newSOQuantities[$item['id']];
					}

					if ( isset( $invoiceItemRemarks[$item['id']] ) )
					{
						$remarks = array_unique($invoiceItemRemarks[$item['id']]);

						$generatedRemarks = StockInInvoiceItemTable::formatRemark($remarks, true);

						unset( $remarks, $invoiceItemRemarks[$item['id']] );
					}

					$item['description']             = $item['description'] . $generatedRemarks;
					$item['material_on_site_id']     = $mos->id;
					$item['import_resource_item_id'] = $item['id'];
					$item['delivered_qty']           = $doQuantity;
					$item['used_qty']                = $soQuantity;
					$item['balance_qty']             = $doQuantity - $soQuantity;
					$item['rate']                    = 0;
					$item['amount']                  = 0;
					$item['__children']              = array();

					// Number of stack items
					$l = count($stack);

					// Check if we're dealing with different levels
					while ($l > 0 && $stack[$l - 1]['level'] >= $item['level'])
					{
						array_pop($stack);
						$l --;
					}

					// Stack is empty (we are inspecting the root)
					if ( $l == 0 )
					{
						// Assigning the root child
						$i         = count($trees);
						$trees[$i] = $item;
						$stack[]   = &$trees[$i];
					}
					else
					{
						// Add child to parent
						$i                               = count($stack[$l - 1]['__children']);
						$stack[$l - 1]['__children'][$i] = $item;
						$stack[]                         = &$stack[$l - 1]['__children'][$i];
					}
				}

				$firstLevelData        = array();
				$shiftExistingRLValues = false;

				foreach ( $trees as $key => $tree )
				{
					if ( !$targetItem )
					{
						MaterialOnSiteItemTable::updateRootPriority($priority, $mos);

						$trees[$key]['priority'] = $priority;
						$trees[$key]['root_id']  = 0;
						$trees[$key]['lft']      = 1;
						$trees[$key]['rgt']      = 2;
						$trees[$key]['level']    = 0;

						$priority += 1;
					}
					else if ( $targetItem->type == ResourceItem::TYPE_HEADER )
					{
						if ( $key == 0 )
						{
							$lft = $targetItem->lft + 1;
						}
						else
						{
							$__childrenCount = 0;
							array_walk_recursive($trees[$key - 1]['__children'], function ($v, $k) use (&$__childrenCount)
							{
								if ( $k == "id" )
								{
									$__childrenCount ++;
								}
							});

							$lft = $__childrenCount * 2 + $trees[$key - 1]['rgt'] + 1;
						}

						$trees[$key]['priority'] = $targetItem->priority;
						$trees[$key]['root_id']  = $targetItem->root_id;
						$trees[$key]['lft']      = $lft;
						$trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
						$trees[$key]['level']    = $targetItem->level + 1;
						$shiftExistingRLValues   = true;
					}
					else if ( $targetItem->node->isRoot() && ( $targetItem->type != ResourceItem::TYPE_HEADER ) )
					{
						//Update Priority
						$targetItem->updateRootPriority($priority);

						$trees[$key]['priority'] = $priority;
						$trees[$key]['root_id']  = 0;
						$trees[$key]['lft']      = 1;
						$trees[$key]['rgt']      = 2;
						$trees[$key]['level']    = 0;

						$priority += 1;
					}
					else
					{
						if ( $key == 0 )
						{
							$lft = $targetItem->rgt + 1;
						}
						else
						{
							$__childrenCount = 0;
							array_walk_recursive($trees[$key - 1]['__children'], function ($v, $k) use (&$__childrenCount)
							{
								if ( $k == "id" )
								{
									$__childrenCount ++;
								}
							});

							$lft = $__childrenCount * 2 + $trees[$key - 1]['rgt'] + 1;
						}

						$trees[$key]['priority'] = $targetItem->priority;
						$trees[$key]['root_id']  = $targetItem->root_id;
						$trees[$key]['lft']      = $lft;
						$trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
						$trees[$key]['level']    = $targetItem->level;

						$shiftExistingRLValues = true;
					}

					$uomId = $tree['uom_id'] > 0 ? $tree['uom_id'] : 'NULL';

					$firstLevelData[] = "(
						'" . pg_escape_string(trim($tree['description'])) . "',
						" . $tree['type'] . ",
						" . $uomId . ",
						" . $tree['material_on_site_id'] . ",
						" . $tree['import_resource_item_id'] . ",
						" . $trees[$key]['priority'] . ",
						" . $trees[$key]['lft'] . ",
						" . $trees[$key]['rgt'] . ",
						" . $trees[$key]['level'] . ",
						" . $trees[$key]['delivered_qty'] . ",
						" . $trees[$key]['used_qty'] . ",
						" . $trees[$key]['balance_qty'] . ",
						" . $trees[$key]['rate'] . ",
						" . $trees[$key]['amount'] . ",
						NOW(),
						NOW()
					)";

					unset( $tree );
				}

				$stmt = $pdo->prepare("INSERT INTO " . self::getInstance()->getTableName() . "
				(description, type, uom_id, material_on_site_id, import_resource_item_id, priority, lft, rgt,
				level, delivered_qty, used_qty, balance_qty, rate, amount, created_at, updated_at)
				VALUES " . implode(",", $firstLevelData) . "
				RETURNING id, import_resource_item_id, type");

				$stmt->execute();

				$returnIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

				$rootIds   = array();
				$rgtValues = array();

				$hasChildrenToInsert = false;

				foreach ( $returnIds as $key => $returnId )
				{
					$itemCount = 1;

					$rootId = $trees[$key]['root_id'] > 0 ? $trees[$key]['root_id'] : $returnId['id'];

					$rootIds[] = "WHEN " . $returnId['id'] . " THEN " . $rootId;

					$firstLevelNodeRightVal = $trees[$key]['rgt'];

					if ( count($trees[$key]['__children']) > 0 )
					{
						list( $firstLevelNodeRightVal, $itemCount ) = self::materialOnSiteLoadNestedSetData($trees[$key]['__children'], $trees[$key], $rootId, $firstLevelNodeRightVal, $itemCount);

						$hasChildrenToInsert = true;
					}

					$rgtValues[] = "WHEN " . $returnId['id'] . " THEN " . $firstLevelNodeRightVal;

					/*
					* If items were inserted at the middle of tree then we need to update the left and right values for the existing items
					*/
					if ( $shiftExistingRLValues && $targetItem )
					{
						$delta = $itemCount * 2;

						//shift all existing siblings
						$stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . "
						SET lft = (" . $delta . " + lft), rgt = (" . $delta . " + rgt) WHERE lft > " . $targetItem->lft . "
						AND root_id = " . $targetItem->root_id . " AND material_on_site_id = " . $mos->id . "
						AND deleted_at IS NULL");

						$stmt->execute();

						$lftSign = "<";
						$rgtSign = ">";

						if ( $targetItem->type == ResourceItem::TYPE_HEADER )
						{
							$lftSign = "<=";
							$rgtSign = ">=";
						}

						//update ancestors right values since the family is getting bigger!
						$stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . "
						SET rgt = (" . $delta . " + rgt) WHERE lft " . $lftSign . " " . $targetItem->lft . "
						AND rgt " . $rgtSign . " " . $targetItem->rgt . " AND root_id = " . $targetItem->root_id . "
						AND material_on_site_id = " . $mos->id . " AND deleted_at IS NULL");

						$stmt->execute();
					}
				}

				$stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . "
				SET root_id = CASE id " . implode(" ", $rootIds) . " END, rgt = CASE id " . implode(" ", $rgtValues) . "
				END WHERE root_id IS NULL AND material_on_site_id = " . $mos->id . "
				AND deleted_at IS NULL");

				$stmt->execute();

				if ( $hasChildrenToInsert )
				{
					$stmt = $pdo->prepare("INSERT INTO " . self::getInstance()->getTableName() . "
					(description, type, uom_id, material_on_site_id, import_resource_item_id, root_id, priority,
					lft, rgt, level, delivered_qty, used_qty, balance_qty, rate, amount, created_at, updated_at)
					VALUES " . implode(",", self::getInstance()->importedMaterialOnSiteItemsChildren) . "
					RETURNING id, import_resource_item_id, type");

					$stmt->execute();
				}
			}

			unset( $trees, $families, self::getInstance()->importedMaterialOnSiteItemsChildren );
		}
	}

	public static function importMaterialOnSiteItems(Doctrine_Connection $conn, $targetItemId, MaterialOnSite $mos, Array $mosItemIds)
	{
		if ( count($mosItemIds) > 0 && array_search("", $mosItemIds) === false )
		{
			$pdo = $conn->getDbh();

			$targetItem = $targetItemId > 0 ? self::getInstance()->find($targetItemId) : false;

			$stmt = $pdo->prepare("SELECT i.id, i.description, i.type, i.delivered_qty, i.used_qty, i.balance_qty, i.rate,
			i.amount, i.priority, i.lft, i.level, i.rate, uom.id AS uom_id, uom.symbol AS uom_symbol
			FROM " . MaterialOnSiteItemTable::getInstance()->getTableName() . " i
			LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom ON i.uom_id = uom.id AND uom.deleted_at IS NULL
			WHERE i.id IN (" . implode(',', $mosItemIds) . ") AND i.deleted_at IS NULL
			ORDER BY i.priority, i.lft, i.level ASC");

			$stmt->execute();

			$items = $stmt->fetchAll(PDO::FETCH_ASSOC);

			$priority = self::getTargetedResourceItemPriority($mos, $targetItem);

			if ( $items and !empty( $items ) )
			{
				$trees = array();

				// Node Stack. Used to help building the hierarchy
				$stack = array();

				foreach ( $items as $item )
				{
					$item['material_on_site_id']     = $mos->id;
					$item['import_resource_item_id'] = 'NULL';
					$item['__children']              = array();

					// Number of stack items
					$l = count($stack);

					// Check if we're dealing with different levels
					while ($l > 0 && $stack[$l - 1]['level'] >= $item['level'])
					{
						array_pop($stack);
						$l --;
					}

					// Stack is empty (we are inspecting the root)
					if ( $l == 0 )
					{
						// Assigning the root child
						$i         = count($trees);
						$trees[$i] = $item;
						$stack[]   = &$trees[$i];
					}
					else
					{
						// Add child to parent
						$i                               = count($stack[$l - 1]['__children']);
						$stack[$l - 1]['__children'][$i] = $item;
						$stack[]                         = &$stack[$l - 1]['__children'][$i];
					}
				}

				$firstLevelData        = array();
				$shiftExistingRLValues = false;

				foreach ( $trees as $key => $tree )
				{
					if ( !$targetItem )
					{
						MaterialOnSiteItemTable::updateRootPriority($priority, $mos);

						$trees[$key]['priority'] = $priority;
						$trees[$key]['root_id']  = 0;
						$trees[$key]['lft']      = 1;
						$trees[$key]['rgt']      = 2;
						$trees[$key]['level']    = 0;

						$priority += 1;
					}
					else if ( $targetItem->type == ResourceItem::TYPE_HEADER )
					{
						if ( $key == 0 )
						{
							$lft = $targetItem->lft + 1;
						}
						else
						{
							$__childrenCount = 0;
							array_walk_recursive($trees[$key - 1]['__children'], function ($v, $k) use (&$__childrenCount)
							{
								if ( $k == "id" )
								{
									$__childrenCount ++;
								}
							});

							$lft = $__childrenCount * 2 + $trees[$key - 1]['rgt'] + 1;
						}

						$trees[$key]['priority'] = $targetItem->priority;
						$trees[$key]['root_id']  = $targetItem->root_id;
						$trees[$key]['lft']      = $lft;
						$trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
						$trees[$key]['level']    = $targetItem->level + 1;
						$shiftExistingRLValues   = true;
					}
					else if ( $targetItem->node->isRoot() && ( $targetItem->type != ResourceItem::TYPE_HEADER ) )
					{
						//Update Priority
						$targetItem->updateRootPriority($priority);

						$trees[$key]['priority'] = $priority;
						$trees[$key]['root_id']  = 0;
						$trees[$key]['lft']      = 1;
						$trees[$key]['rgt']      = 2;
						$trees[$key]['level']    = 0;

						$priority += 1;
					}
					else
					{
						if ( $key == 0 )
						{
							$lft = $targetItem->rgt + 1;
						}
						else
						{
							$__childrenCount = 0;
							array_walk_recursive($trees[$key - 1]['__children'], function ($v, $k) use (&$__childrenCount)
							{
								if ( $k == "id" )
								{
									$__childrenCount ++;
								}
							});

							$lft = $__childrenCount * 2 + $trees[$key - 1]['rgt'] + 1;
						}

						$trees[$key]['priority'] = $targetItem->priority;
						$trees[$key]['root_id']  = $targetItem->root_id;
						$trees[$key]['lft']      = $lft;
						$trees[$key]['rgt']      = $trees[$key]['lft'] + 1;
						$trees[$key]['level']    = $targetItem->level;

						$shiftExistingRLValues = true;
					}

					$uomId = $tree['uom_id'] > 0 ? $tree['uom_id'] : 'NULL';

					$firstLevelData[] = "(
						'" . pg_escape_string(trim($tree['description'])) . "',
						" . $tree['type'] . ",
						" . $uomId . ",
						" . $tree['material_on_site_id'] . ",
						" . $tree['import_resource_item_id'] . ",
						" . $trees[$key]['priority'] . ",
						" . $trees[$key]['lft'] . ",
						" . $trees[$key]['rgt'] . ",
						" . $trees[$key]['level'] . ",
						" . $trees[$key]['delivered_qty'] . ",
						" . $trees[$key]['used_qty'] . ",
						" . $trees[$key]['balance_qty'] . ",
						" . $trees[$key]['rate'] . ",
						" . $trees[$key]['amount'] . ",
						NOW(),
						NOW()
					)";

					unset( $tree );
				}

				$stmt = $pdo->prepare("INSERT INTO " . self::getInstance()->getTableName() . "
				(description, type, uom_id, material_on_site_id, import_resource_item_id, priority, lft, rgt,
				level, delivered_qty, used_qty, balance_qty, rate, amount, created_at, updated_at)
				VALUES " . implode(",", $firstLevelData) . "
				RETURNING id, import_resource_item_id, type");

				$stmt->execute();

				$returnIds = $stmt->fetchAll(PDO::FETCH_ASSOC);

				$rootIds   = array();
				$rgtValues = array();

				$hasChildrenToInsert = false;

				foreach ( $returnIds as $key => $returnId )
				{
					$itemCount = 1;

					$rootId = $trees[$key]['root_id'] > 0 ? $trees[$key]['root_id'] : $returnId['id'];

					$rootIds[] = "WHEN " . $returnId['id'] . " THEN " . $rootId;

					$firstLevelNodeRightVal = $trees[$key]['rgt'];

					if ( count($trees[$key]['__children']) > 0 )
					{
						list( $firstLevelNodeRightVal, $itemCount ) = self::materialOnSiteLoadNestedSetData($trees[$key]['__children'], $trees[$key], $rootId, $firstLevelNodeRightVal, $itemCount);

						$hasChildrenToInsert = true;
					}

					$rgtValues[] = "WHEN " . $returnId['id'] . " THEN " . $firstLevelNodeRightVal;

					/*
					* If items were inserted at the middle of tree then we need to update the left and right values for the existing items
					*/
					if ( $shiftExistingRLValues && $targetItem )
					{
						$delta = $itemCount * 2;

						//shift all existing siblings
						$stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . "
						SET lft = (" . $delta . " + lft), rgt = (" . $delta . " + rgt) WHERE lft > " . $targetItem->lft . "
						AND root_id = " . $targetItem->root_id . " AND material_on_site_id = " . $mos->id . "
						AND deleted_at IS NULL");

						$stmt->execute();

						$lftSign = "<";
						$rgtSign = ">";

						if ( $targetItem->type == ResourceItem::TYPE_HEADER )
						{
							$lftSign = "<=";
							$rgtSign = ">=";
						}

						//update ancestors right values since the family is getting bigger!
						$stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . "
						SET rgt = (" . $delta . " + rgt) WHERE lft " . $lftSign . " " . $targetItem->lft . "
						AND rgt " . $rgtSign . " " . $targetItem->rgt . " AND root_id = " . $targetItem->root_id . "
						AND material_on_site_id = " . $mos->id . " AND deleted_at IS NULL");

						$stmt->execute();
					}
				}

				$stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . "
				SET root_id = CASE id " . implode(" ", $rootIds) . " END, rgt = CASE id " . implode(" ", $rgtValues) . "
				END WHERE root_id IS NULL AND material_on_site_id = " . $mos->id . "
				AND deleted_at IS NULL");

				$stmt->execute();

				if ( $hasChildrenToInsert )
				{
					$stmt = $pdo->prepare("INSERT INTO " . self::getInstance()->getTableName() . "
					(description, type, uom_id, material_on_site_id, import_resource_item_id, root_id, priority,
					lft, rgt, level, delivered_qty, used_qty, balance_qty, rate, amount, created_at, updated_at)
					VALUES " . implode(",", self::getInstance()->importedMaterialOnSiteItemsChildren) . "
					RETURNING id, import_resource_item_id, type");

					$stmt->execute();
				}
			}

			unset( $trees, $families, self::getInstance()->importedMaterialOnSiteItemsChildren );
		}
	}

	public static function updateRootPriority($priority, MaterialOnSite $mos, $excludeId = null)
	{
		$pdo = self::getInstance()->getConnection()->getDbh();

		$sqlUpdateRoot = "UPDATE " . self::getInstance()->getTableName() . " SET priority = priority + 1
		WHERE material_on_site_id =" . $mos->id . " AND priority >=" . $priority . " AND id = root_id";

		if ( $excludeId and $excludeId > 0 )
		{
			$sqlUpdateRoot .= " AND id <> " . $excludeId;
		}

		$sqlUpdateRoot .= " AND deleted_at IS NULL";

		$stmt = $pdo->prepare($sqlUpdateRoot);

		$stmt->execute();

		//update children priority same as root priority
		$stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . " AS i SET priority = r.priority
		FROM " . self::getInstance()->getTableName() . " AS r
		WHERE i.root_id = r.id AND i.id <> r.id AND i.priority <> r.priority AND i.material_on_site_id = " . $mos->id . "
		AND i.deleted_at IS NULL");

		$stmt->execute();
	}

	private static function getTargetedResourceItemPriority(MaterialOnSite $mos, $targetItem)
	{
		if ( !$targetItem )
		{
			/* If No Target Item Specify We Get First Root Item as target Item */
			$rootItem = DoctrineQuery::create()->select('i.id')
				->from('MaterialOnSiteItem i')
				->where('i.material_on_site_id = ?', array( $mos->id ))
				->andWhere('i.root_id = i.id')
				->limit(1)
				->addOrderBy('i.priority ASC')
				->fetchOne();

			/*
			 * we get target item (assumed root) priority first because later we will increment the priority
			 * when we are creating root items.
			 */
			$priority = $rootItem ? $rootItem->priority : 0;
		}
		else
		{
			$record = DoctrineQuery::create()->select('i.priority')
				->from('MaterialOnSiteItem i')
				->where('i.material_on_site_id = ?', array( $mos->id ))
				->andWhere('i.root_id = i.id')
				->andWhere('i.id = ? ', $targetItem->id)
				->limit(1)
				->addOrderBy('i.priority ASC')
				->fetchOne();

			$priority = $record ? $record->priority + 1 : 0;
		}

		return $priority;
	}

	public static function materialOnSiteLoadNestedSetData(Array $nestedSetData, Array $parent, $rootId, $parentRgtVal, $itemCount)
	{
		$functionName = __FUNCTION__;

		foreach ( $nestedSetData as $nestedSet )
		{
			unset( $nestedSet['id'] );

			/*
			 * Since this will only be called when the node (parent) has children under it so we just add
			 * all nodes in nested set as children for the parent node
			 */
			$nestedSet['lft']   = $parentRgtVal;
			$nestedSet['rgt']   = $nestedSet['lft'] + 1;
			$nestedSet['level'] = $parent['level'] + 1;

			$parentRgtVal = $nestedSet['rgt'];

			$nestedSet['priority'] = $parent['priority'];

			$itemCount += 1;

			if ( array_key_exists('__children', $nestedSet) and !empty( $nestedSet['__children'] ) )
			{
				list( $parentRgtVal, $itemCount ) = self::$functionName($nestedSet['__children'], $nestedSet, $rootId, $parentRgtVal, $itemCount);

				$nestedSet['rgt'] = $parentRgtVal;
			}

			$parentRgtVal += 1;

			$uomId = $nestedSet['uom_id'] > 0 ? $nestedSet['uom_id'] : 'NULL';

			self::getInstance()->importedMaterialOnSiteItemsChildren[] = "(
				'" . pg_escape_string(trim($nestedSet['description'])) . "',
				" . $nestedSet['type'] . ",
				" . $uomId . ",
				" . $nestedSet['material_on_site_id'] . ",
				" . $nestedSet['import_resource_item_id'] . ",
				" . $rootId . ",
				" . $nestedSet['priority'] . ",
				" . $nestedSet['lft'] . ",
				" . $nestedSet['rgt'] . ",
				" . $nestedSet['level'] . ",
				" . $nestedSet['delivered_qty'] . ",
				" . $nestedSet['used_qty'] . ",
				" . $nestedSet['balance_qty'] . ",
				" . $nestedSet['rate'] . ",
				" . $nestedSet['amount'] . ",
				NOW(),
				NOW()
			)";
		}

		return array( $parentRgtVal, $itemCount );
	}

	public static function getItemsByIds(ProjectStructure $projectStructure, $itemIds)
	{
		$items   = array();
		$itemIds = json_decode($itemIds);

		if ( empty( $itemIds ) )
		{
			return $items;
		}

		$pdo = self::getInstance()->getConnection()->getDbh();

		$stmt = $pdo->prepare("SELECT DISTINCT p.id, p.description, p.type, p.delivered_qty,
			p.used_qty, p.balance_qty, p.rate, p.amount, p.priority, p.lft, p.level, p.rate, uom.id AS uom_id,
			uom.symbol AS uom_symbol, mos.id as material_on_site_id, mos.description as material_on_site_name, mos.priority
			FROM " . MaterialOnSiteItemTable::getInstance()->getTableName() . " i
			JOIN " . MaterialOnSiteItemTable::getInstance()->getTableName() . " p
			ON (i.lft BETWEEN p.lft AND p.rgt AND p.deleted_at IS NULL)
			LEFT JOIN " . MaterialOnSiteTable::getInstance()->getTableName() . " mos ON mos.id = p.material_on_site_id
			LEFT JOIN " . UnitOfMeasurementTable::getInstance()->getTableName() . " uom ON p.uom_id = uom.id AND uom.deleted_at IS NULL
			WHERE mos.project_structure_id = " . $projectStructure->id . " AND i.id IN (" . implode(',', $itemIds) . ")
			AND p.deleted_at IS NULL AND i.root_id = p.root_id AND i.type <> " . ResourceItem::TYPE_HEADER . "
			ORDER BY mos.priority, p.priority, p.lft, p.level ASC");

		$stmt->execute(array());

		$items = $stmt->fetchAll(PDO::FETCH_ASSOC);

		foreach ( $items as $key => $item )
		{
			$items[$key]['rate-value'] = $item['rate'];
			$items[$key]['type']       = (string) $item['type'];
			$items[$key]['uom_id']     = $item['uom_id'] > 0 ? (string) $item['uom_id'] : '-1';
			$items[$key]['uom_symbol'] = $item['uom_id'] > 0 ? $item['uom_symbol'] : '';
		}

		return $items;
	}

}