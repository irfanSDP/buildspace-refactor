<?php

/**
 * ScheduleTaskItemTable
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class ScheduleTaskItemTable extends Doctrine_Table
{
    protected static $newItems           = array();
    protected static $itemsWithBillItems = array();

    public static function getInstance()
    {
        return Doctrine_Core::getTable('ScheduleTaskItem');
    }

    public static function deleteFromGantt(array $data, ProjectSchedule $projectSchedule)
    {
        Doctrine_Query::create()
            ->delete('ScheduleTaskItem i')
            ->where('i.project_schedule_id = ?', $projectSchedule->id)
            ->andWhereIn('i.id',$data)
            ->execute();
    }

    public static function saveFromGantt(array $data, ProjectSchedule $projectSchedule, Doctrine_Connection $conn)
    {
        self::$newItems = array();
        self::$itemsWithBillItems = array();

        $hierarchyData = self::buildTree($data, $projectSchedule, $conn);

        $pdo  = $conn->getDbh();

        self::prepareItems($hierarchyData, $projectSchedule);

        //soft delete previous items so we can swap any tagged bill items to the newly created items
        Doctrine_Query::create()
            ->update('ScheduleTaskItem i')
            ->set('i.temp_deleted', '?', true)
            ->where('i.project_schedule_id = ?', $projectSchedule->id)
            ->execute();

        if(!empty(self::$newItems))
        {
            $returnedIds = self::insertItems($projectSchedule, $conn);

            //swap schedule_task_item_id with the newly created id
            if(!empty(self::$itemsWithBillItems))
            {
                $scheduleTaskItemBillItemsToUpdate = array();

                $caseSql = "";

                foreach($returnedIds as $beforeId => $afterId)
                {
                    if(array_key_exists($beforeId, self::$itemsWithBillItems) && !empty(self::$itemsWithBillItems[$beforeId]))
                    {
                        foreach(self::$itemsWithBillItems[$beforeId] as $scheduleTaskItemBillItemId)
                        {
                            $caseSql .= "WHEN ".$scheduleTaskItemBillItemId." THEN ".$afterId." ";
                            $scheduleTaskItemBillItemsToUpdate[] = $scheduleTaskItemBillItemId;
                        }
                    }
                }

                if(!empty($scheduleTaskItemBillItemsToUpdate))
                {
                    $stmt = $pdo->prepare("UPDATE ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()."
                    SET schedule_task_item_id = CASE id
                        ".$caseSql."
                        ELSE schedule_task_item_id
                        END
                    WHERE id IN(".implode(",", $scheduleTaskItemBillItemsToUpdate).");");

                    $stmt->execute();
                }
            }
        }

        $stmt = $pdo->prepare("DELETE FROM ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()." WHERE
                schedule_task_item_id IN (SELECT id FROM ".self::getInstance()->getTableName()."
                WHERE (rgt - lft) > 1 AND project_schedule_id = ".$projectSchedule->id.")");

        $stmt->execute();

        Doctrine_Query::create()
            ->delete('ScheduleTaskItem i')
            ->where('i.project_schedule_id = ?', $projectSchedule->id)
            ->andWhere('i.temp_deleted IS TRUE')
            ->execute();
    }

    private static function insertItems(ProjectSchedule $projectSchedule, Doctrine_Connection $conn)
    {
        $userId = sfContext::getInstance()->getUser()->getAttribute('user_id', null, 'sfGuardSecurityUser');

        $root = DoctrineQuery::create()->select('i.id')
            ->from('ScheduleTaskItem i')
            ->where('i.project_schedule_id = ?', array($projectSchedule->id))
            ->andWhere('i.root_id IS NOT NULL')
            ->andWhere('i.id = i.root_id')
            ->andWhere('i.temp_deleted IS TRUE')
            ->limit(1)
            ->setHydrationMode(Doctrine_Core::HYDRATE_ARRAY)
            ->fetchOne();

        $stmt = new sfImportExcelStatementGenerator($conn);

        $stmt->createInsert(
            self::getInstance()->getTableName(),
            array(
                'title',
                'description',
                'code',
                'start_date',
                'end_date',
                'completed_date',
                'hours_per_day',
                'total_cost',
                'project_schedule_id',
                'status',
                'progress',
                'duration',
                'depends',
                'start_is_milestone',
                'end_is_milestone',
                'lft',
                'rgt',
                'level',
                'root_id',
                'priority',
                'created_at',
                'updated_at',
                'created_by',
                'updated_by'
            )
        );

        $childrenForRoots = array();

        foreach ( self::$newItems as $tmpId => $item )
        {
            if(!array_key_exists($item['root_id'], $childrenForRoots))
            {
                $childrenForRoots[$item['root_id']] = array();
            }

            $childrenForRoots[$item['root_id']][] = $tmpId;

            $stmt->addRecord(array(
                pg_escape_string((string) $item['title']),
                pg_escape_string((string) $item['description']),
                pg_escape_string((string) $item['code']),
                $item['start_date'],
                $item['end_date'],
                $item['completed_date'],
                $item['hours_per_day'],
                $item['total_cost'],
                $projectSchedule->id,
                $item['status'],
                $item['progress'],
                $item['duration'],
                pg_escape_string((string) $item['depends']),
                $item['start_is_milestone'] ? 't' : 'f',
                $item['end_is_milestone'] ? 't' : 'f',
                $item['lft'],
                $item['rgt'],
                $item['level'],
                empty($root) ? null : $root['id'],
                $item['priority'],
                'NOW()',
                'NOW()',
                $userId,
                $userId
            ), $tmpId);
        }

        $stmt->save();

        $savedItemIds = $stmt->returningIds;

        self::reassignRootIds($childrenForRoots, $savedItemIds, $conn);

        return $savedItemIds;
    }

    private static function reassignRootIds(Array $roots, Array $importedItemToItemIds, Doctrine_Connection $conn)
    {
        $pdo  = $conn->getDbh();

        $rootIds = array();
        $itemIds = array();

        foreach ( $roots as $rootId => $root )
        {
            foreach ( $root as $itemId )
            {
                if ( array_key_exists($rootId, $importedItemToItemIds) && array_key_exists($itemId, $importedItemToItemIds) && !empty($importedItemToItemIds[$itemId]) && !empty($importedItemToItemIds[$rootId]))
                {
                    $itemIds[] = $importedItemToItemIds[$itemId];
                    $rootIds[] = $importedItemToItemIds[$rootId];
                }
            }
        }

        if ( !empty($rootIds) && !empty($itemIds) )
        {
            $stmt = $pdo->prepare("UPDATE " . self::getInstance()->getTableName() . " SET root_id = cast(virtual_table.root_id AS int)
            FROM
            (SELECT UNNEST(ARRAY[" . implode(",", $itemIds) . "]) AS id,
                UNNEST(ARRAY['" . implode("','", $rootIds) . "']) AS root_id
            ) AS virtual_table WHERE " . self::getInstance()->getTableName() . ".id = virtual_table.id");

            $stmt->execute();
        }
    }

    private static function prepareItems(Array $data, ProjectSchedule $projectSchedule)
    {
        foreach($data as $item)
        {
            $item['title']               = pg_escape_string((string) $item['title']);
            $item['description']         = pg_escape_string((string) $item['description']);
            $item['code']                = pg_escape_string((string) $item['code']);
            $item['depends']             = pg_escape_string((string) $item['depends']);
            $item['project_schedule_id'] = $projectSchedule->id;

            $children = $item['__children'];

            unset($item['__children']);

            self::$newItems[$item['id']] = $item;

            if(isset($children) && !empty($children))
            {
                $item['tagged_bill_items'] = array();
                self::prepareItems($children, $projectSchedule);
            }

            if(isset($item['tagged_bill_items']))
            {
                self::$itemsWithBillItems[$item['id']] = $item['tagged_bill_items'];
            }
        }
    }

    private static function buildTree(array $elements, ProjectSchedule $projectSchedule, Doctrine_Connection $conn)
    {
        $priority = 0;
        $trees = array();
        // Node Stack. Used to help building the hierarchy
        $stack = array();

        $pdo = $conn->getDbh();

        $stmt = $pdo->prepare("SELECT DISTINCT stbi.id, i.id
            FROM ".ScheduleTaskItemTable::getInstance()->getTableName()." i
            JOIN ".ScheduleTaskItemBillItemTable::getInstance()->getTableName()." stbi ON stbi.schedule_task_item_id = i.id
            WHERE i.project_schedule_id = ".$projectSchedule->id);

        $stmt->execute();

        $taskItemWithBillItems = $stmt->fetchAll(PDO::FETCH_KEY_PAIR);

        foreach ($elements as $child)
        {
            if(empty($child->name))
                continue;

            if($child->level == 0)
            {
                $rootId = (is_numeric($child->idFromDB)) ? $child->idFromDB : $child->id;
                $priority++;
            }

            $id = (is_numeric($child->idFromDB)) ? $child->idFromDB : $child->id;

            if(ScheduleTaskItem::getStatusByStatusText($child->status) == ScheduleTaskItem::STATUS_DONE)
            {
                $completedDate = (is_integer($child->completedDate)) ? date('Y-m-d', ($child->completedDate / 1000)) : null;
            }
            else
            {
                $completedDate = null;
            }

            $item = array(
                'id'                 => $id,
                'id_from_db'         => $child->idFromDB,
                'title'              => $child->name,
                'completed_date'     => $completedDate,
                'description'        => $child->description,
                'code'               => $child->code,
                'start_date'         => date('Y-m-d', ($child->start / 1000)),
                'end_date'           => date('Y-m-d', ($child->end / 1000)),
                'hours_per_day'      => $child->hoursPerDay,
                'total_cost'         => $child->totalCost,
                'status'             => ScheduleTaskItem::getStatusByStatusText($child->status),
                'progress'           => $child->progress,
                'duration'           => $child->duration,
                'start_is_milestone' => $child->startIsMilestone,
                'end_is_milestone'   => $child->endIsMilestone,
                'depends'            => $child->depends,
                'tagged_bill_items'  => array(),
                'level'              => $child->level,
                'root_id'            => $rootId,
                'priority'           => $priority,
                'lft'                => 1,
                'rgt'                => 2
            );

            foreach($taskItemWithBillItems as $taskItemBillItemId => $taskItemId)
            {
                if($taskItemId == $item['id'])
                {
                    $item['tagged_bill_items'][] = $taskItemBillItemId;

                    unset($taskItemWithBillItems[$taskItemBillItemId]);
                }
            }

            $item['__children'] = array();

            // Number of stack items
            $l = count($stack);

            // Check if we're dealing with different levels
            while ($l > 0 && $stack[$l - 1]['level'] >= $item['level'])
            {
                array_pop($stack);
                $l --;
            }

            // Stack is empty (we are inspecting the root)
            if ($l == 0)
            {
                // Assigning the root child
                $i         = count($trees);
                $trees[$i] = $item;
                $stack[]   = &$trees[$i];
            }
            else
            {
                $item['lft'] = $stack[$l - 1]['rgt'];
                $item['rgt'] = $item['lft'] + 1;

                // Add child to parent
                $i                               = count($stack[$l - 1]['__children']);
                $stack[$l - 1]['__children'][$i] = $item;
                $stack[]                         = &$stack[$l - 1]['__children'][$i];

                $x = $l;
                while($x-1 >= 0)
                {
                    $stack[$x - 1]['rgt'] = $stack[$x - 1]['rgt'] + 2;
                    $x--;
                }
            }
        }

        return $trees;
    }

    public static function updateRootPriority($priority, $projectScheduleId, $excludeId = null)
    {
        $pdo = self::getInstance()->getConnection()->getDbh();

        $sqlUpdateRoot = "UPDATE ".self::getInstance()->getTableName()." SET priority = priority + 1
            WHERE project_schedule_id =".$projectScheduleId." AND priority >=".$priority." AND id = root_id";

        if($excludeId and $excludeId > 0)
        {
            $sqlUpdateRoot .= " AND id <> ".$excludeId;
        }

        $sqlUpdateRoot .= " AND deleted_at IS NULL";

        $stmt = $pdo->prepare($sqlUpdateRoot);

        $stmt->execute();

        //update children priority same as root priority
        $stmt = $pdo->prepare("UPDATE ".self::getInstance()->getTableName()." AS i SET priority = r.priority
            FROM ".self::getInstance()->getTableName()." AS r
            WHERE i.root_id = r.id AND i.id <> r.id AND i.priority <> r.priority AND i.project_schedule_id = ".$projectScheduleId."
            AND i.deleted_at IS NULL");

        $stmt->execute();
    }

    public static function getActualTaskDuration($startDate, $completionDate, $completionPercentage, SplFixedArray $nonWorkingDays, $excludeSaturdays=true, $excludeSundays=true)
    {
        if(strtotime(date('Y-m-d')) >= strtotime($startDate) && $completionPercentage != 0)
        {
            $completionDate = $completionDate ? $completionDate : date("Y-m-d");

            $aDur = Utilities::distanceInWorkingDays($startDate, $completionDate, $nonWorkingDays, $excludeSaturdays, $excludeSundays);

            $q = ceil($aDur / ($completionPercentage/100));


            $actualEndDate = $startDate;

            while($q > 1)
            {
                $actualEndDate = date('Y-m-d',strtotime("+1 day", strtotime($actualEndDate)));

                if(!Utilities::isNonWorkingDay($actualEndDate, $nonWorkingDays, $excludeSaturdays, $excludeSundays))
                    $q--;
            }

            $duration = Utilities::distanceInWorkingDays($startDate, $actualEndDate, $nonWorkingDays, $excludeSaturdays, $excludeSundays);
        }
        else
        {
            $duration = 0;
        }

        return round(abs($duration));
    }

    public static function calculatePlannedTaskPercentage($startDate, $endDate, SplFixedArray $nonWorkingDays, $excludeSaturdays=true, $excludeSundays=true)
    {
        $currentDateToTime = strtotime(date('Y-m-d'));
        $percentage = 0;

        if($currentDateToTime < strtotime($startDate))
        {
            return $percentage;
        }

        if(strtotime($endDate) <= $currentDateToTime)
        {
            $percentage = 100;
        }
        else
        {

            $aDur = Utilities::distanceInWorkingDays($startDate, date('Y-m-d'), $nonWorkingDays, $excludeSaturdays, $excludeSundays);
            $bDur = Utilities::distanceInWorkingDays($startDate, $endDate, $nonWorkingDays, $excludeSaturdays, $excludeSundays);
            $percentage = $aDur / $bDur * 100;
        }

        return $percentage;
    }

    public static function getPredecessorStartDate(ScheduleTaskItem $successor, $lag)
    {
        $lag = (int)$lag;

        $endDate = $successor->end_date;//calculate start date for predecessor based on successor end date
        $q = $lag+1;

        $nonWorkingDays = $successor->ProjectSchedule->getNonWorkingDays();
        $excludeSaturdays = $successor->ProjectSchedule->exclude_saturdays;
        $excludeSundays = $successor->ProjectSchedule->exclude_sundays;

        while($q > 0)
        {
            $endDate = date('Y-m-d',strtotime("+1 day", strtotime($endDate)));

            if(!Utilities::isNonWorkingDay($endDate, $nonWorkingDays, $excludeSaturdays, $excludeSundays))
                $q--;
        }

        return $endDate;
    }
}