<?php namespace PCK\TenderDocumentFolders;

use Baum\Node;
use PCK\Base\Upload;
use PCK\Helpers\Files;
use PCK\Helpers\ModelOperations;
use PCK\Projects\Project;
use PCK\StructuredDocument\StructuredDocument;
use PCK\TemplateTenderDocumentFolders\TemplateTenderDocumentFile;
use PCK\TemplateTenderDocumentFolders\TemplateTenderDocumentFolder;

class TenderDocumentFolder extends Node {

    CONST DEFAULT_BQ_FILES_FOLDER_NAME       = 'BQ Files';
    CONST DEFAULT_FORM_OF_TENDER_FOLDER_NAME = 'Form of Tender';

    CONST DEFAULT_BQ_FOLDER_NAME = 'BQ';

    CONST DEFAULT_ADDENDUM_FOLDER_NAME = 'Addendum';

    CONST TYPE_FOLDER              = 1;
    CONST TYPE_STRUCTURED_DOCUMENT = 2;

    protected $table = 'tender_document_folders';

    protected static function boot()
    {
        parent::boot();

        static::created(function(TenderDocumentFolder $node)
        {
            if( $node->depth == 0 && is_null($node->parent_id) )
            {
                $node->root_id = $node->id;
                $node->lft     = 1;
                $node->rgt     = 2;

                $node->save();
            }
        });

        static::deleting(function(self $node)
        {
            if( ! $node->canBeDeleted() )
            {
                throw new \LogicException('Cannot delete due to currently deleting folder is generated by the System.');
            }
            $node->augmentedDestroyDescendants();

            foreach($node->files as $file)
            {
                $file->delete();
            }

            if( $structuredDocument = StructuredDocument::getDocument($node) )
            {
                ModelOperations::deleteWithTrigger($structuredDocument);
            }
        });
    }

    /**
     * Checks if the resource can be deleted.
     * Will check if current folder is system generated folder.
     * Will not allow user to delete if it is a system generated folder.
     *
     * @return bool
     */
    private function canBeDeleted()
    {
        return ( ! $this->system_generated_folder );
    }

    public function project()
    {
        return $this->belongsTo('PCK\Projects\Project');
    }

    public function files()
    {
        // Todo: Disable saving files if it is a structured document.
        return $this->hasMany('PCK\TenderDocumentFolders\TenderDocumentFile', 'tender_document_folder_id')->orderBy('id', 'desc');
    }

    public function getUploadedFiles()
    {
        return $this->hasMany('PCK\TenderDocumentFolders\TenderDocumentFile', 'tender_document_folder_id')->orderBy('created_at', 'DESC');
    }

    public function firstRevisionFiles()
    {
        return $this->hasMany('PCK\TenderDocumentFolders\TenderDocumentFile', 'tender_document_folder_id')->where('revision', '=', 0)->orderBy('created_at', 'DESC');
    }

    /**
     * Static query scope. Returns a query scope with all root nodes.
     *
     * @param Project $project
     *
     * @return \Illuminate\Database\Query\Builder
     */
    public static function getRootsByProject(Project $project)
    {
        $instance = new static;

        return $instance
            ->whereNull($instance->getParentColumnName())
            ->where($instance->getDepthColumnName(), '=', 0)
            ->whereRaw('root_id = id')
            ->where('project_id', '=', $project->id)
            ->orderBy('priority')
            ->get();
    }

    public function ancestorsAndSelf()
    {
        return $this->newNestedSetQuery()
            ->where($this->getLeftColumnName(), '<=', $this->getLeft())
            ->where($this->getRightColumnName(), '>=', $this->getRight())
            ->where('root_id', '=', $this->root_id)
            ->where('project_id', '=', $this->project_id);
    }

    public function descendantsAndSelf()
    {
        return $this->newNestedSetQuery()
            ->where($this->getLeftColumnName(), '>=', $this->getLeft())
            ->where($this->getLeftColumnName(), '<', $this->getRight())
            ->where('root_id', '=', $this->root_id)
            ->where('project_id', '=', $this->project_id);
    }

    protected function moveTo($target, $position)
    {
        return TenderDocumentFolderMove::to($this, $target, $position);
    }

    // Overwrite the normal destroyDescendants function to prevent BAUM's model deleting from amending tree structure
    public function destroyDescendants()
    {
        return false;
    }

    /**
     * Prunes a branch off the tree, shifting all the elements on the right
     * back to the left so the counts work.
     *
     * @return void;
     */
    public function augmentedDestroyDescendants()
    {
        if( is_null($this->getRight()) || is_null($this->getLeft()) )
        {
            return;
        }

        $self = $this;

        $this->getConnection()->transaction(function() use ($self)
        {
            $self->reload();

            $self->applyLock();

            $self->pruneChildren();

            $self->recalculateBoundaries();
        });
    }

    /**
     * Apply a lock to the rows which fall past the deletion point.
     */
    public function applyLock()
    {
        list( $lftCol, $rgtCol, $lft, $rgt ) = $this->getRightAndLeftParams();

        $this->newNestedSetQuery()
            ->where($lftCol, '>=', $lft)
            ->where('root_id', '=', $this->root_id)
            ->where('project_id', '=', $this->project_id)
            ->select($this->getKeyName())
            ->lockForUpdate()
            ->get();
    }

    /**
     * Get all children, then proceed with delete file(s) associated with the children nodes.
     */
    public function pruneChildren()
    {
        list( $lftCol, $rgtCol, $lft, $rgt ) = $this->getRightAndLeftParams();

        $children = $this->newNestedSetQuery()
            ->with('files')
            ->where($lftCol, '>', $lft)
            ->where($rgtCol, '<', $rgt)
            ->where('root_id', '=', $this->root_id)
            ->where('parent_id', '=', $this->id)
            ->where('project_id', '=', $this->project_id)
            ->get();

        foreach($children as $child)
        {
            foreach($child->files as $file)
            {
                $file->delete();
            }
            $child->setSystemGeneratedAttribute($this->system_generated_folder);
            $child->delete();
        }
    }

    /**
     * Recalculates left and right indexes for the other nodes.
     */
    public function recalculateBoundaries()
    {
        list( $lftCol, $rgtCol, $lft, $rgt ) = $this->getRightAndLeftParams();

        $diff = $rgt - $lft + 1;

        // ancestor folders + folders on the right of "folder to be deleted"
        $this->newNestedSetQuery()
            ->where($lftCol, '>', $rgt)
            ->where('root_id', '=', $this->root_id)
            ->where('project_id', '=', $this->project_id)
            ->decrement($lftCol, $diff);

        $this->newNestedSetQuery()
            ->where($rgtCol, '>', $rgt)
            ->where('root_id', '=', $this->root_id)
            ->where('project_id', '=', $this->project_id)
            ->decrement($rgtCol, $diff);
    }

    /**
     * Returns the column names and values for rgt and lft.
     *
     * @return array
     */
    public function getRightAndLeftParams()
    {
        return array(
            $this->getLeftColumnName(),
            $this->getRightColumnName(),
            $this->getLeft(),
            $this->getRight()
        );
    }

    /**
     * Explicitly set the system generated folder attribute to true or false.
     *
     * @param $isSystemGenerated
     */
    public function setSystemGeneratedAttribute($isSystemGenerated)
    {
        $this->system_generated_folder = $isSystemGenerated;
        $this->save();
    }

    /**
     * Creates a new folder hierarchy based on the template.
     * Copies a template folder including all its descendants.
     *
     * @param Project                      $project
     * @param TemplateTenderDocumentFolder $template
     * @param TenderDocumentFolder         $parent
     *
     * @return TenderDocumentFolder
     * @throws \Exception
     */
    public static function copyTemplateFolderAndDescendants(Project $project, TemplateTenderDocumentFolder $template, TenderDocumentFolder $parent = null)
    {
        $newFolder = new TenderDocumentFolder();

        $newFolder->copyFromTemplate($project, $template, $parent);

        if( $parent )
        {
            $newFolder->makeChildOf($parent);
        }

        // Copy File and upload.
        foreach($template->files as $templateFile)
        {
            if( ( $project->work_category_id == $templateFile->work_category_id ) or empty( $templateFile->work_category_id ) )
            {
                $newFolder->copyTemplateFile($templateFile);
            }

            // Copy child files.

        }

        foreach($template->children as $templateChild)
        {
            self::copyTemplateFolderAndDescendants($project, $templateChild, $newFolder);
        }

        return $newFolder;
    }

    /**
     * Copies the contents from the template.
     *
     * @param Project                      $project
     * @param TemplateTenderDocumentFolder $template
     * @param TenderDocumentFolder         $parent
     *
     * @return bool
     * @throws \Exception
     */
    private function copyFromTemplate(Project $project, TemplateTenderDocumentFolder $template, TenderDocumentFolder $parent = null)
    {
        if( $this->exists )
        {
            throw new \Exception('Cannot copy onto existing folder.');
        }

        $lastNode = self::getRootsByProject($project)->last();

        $this->priority                = ( ( $lastNode ) ? $lastNode->priority + 1 : 0 );
        $this->name                    = $template->name;
        $this->project_id              = $project->id;
        $this->system_generated_folder = false;
        $this->folder_type             = $template->folder_type;

        if( $parent )
        {
            $this->root_id   = $parent->root_id;
            $this->parent_id = $parent->id;
            $this->priority  = $parent->priority;
        }

        $success = $this->save();

        if( $template->folder_type == self::TYPE_STRUCTURED_DOCUMENT )
        {
            $structuredDocumentRepo = \App::make('PCK\StructuredDocument\StructuredDocumentRepository');
            $structuredDocumentRepo->createFromTemplate($this->id, $template);
        }

        return $success;
    }

    /**
     * Copies the template's File and Upload resources.
     *
     * @param TemplateTenderDocumentFile $templateFile
     *
     * @throws \Exception
     */
    private function copyTemplateFile(TemplateTenderDocumentFile $templateFile)
    {
        if( $templateFile->fileProperties )
        {
            $currentUser = \Confide::user();
            // Copy physical file.
            $newFileName = Files::generateCopyName($templateFile->fileProperties->physicalPath(), $templateFile->fileProperties->filename, $templateFile->fileProperties->extension);
            $filePath    = $templateFile->fileProperties->physicalPath() . '/' . $templateFile->fileProperties->filename;
            $newFilePath = $templateFile->fileProperties->physicalPath() . '/' . $newFileName;
            Files::copy($filePath, $newFilePath);

            // Copy file properties.
            $newUpload            = $templateFile->fileProperties->replicate();
            $newUpload->user_id   = $currentUser->id;
            $newUpload->filename  = $newFileName;
            $newUpload->parent_id = null;

            $newUpload->save();

            // Create new File Object.
            $newFile = new TenderDocumentFile();

            $newFile->filename                  = $templateFile->filename;
            $newFile->description               = $templateFile->description;
            $newFile->cabinet_file_id           = $newUpload->id;
            $newFile->tender_document_folder_id = $this->id;
            $newFile->revision                  = 0;

            $this->files()->save($newFile);

            $newFile->parent_id = $newFile->id;
            $newFile->save();

            $newFile->fileProperties()->save($newUpload);

            $insertReadOnlyRecords = array();

            foreach($templateFile->readOnlyContractGroups->lists('id') as $contractGroupId)
            {
                $insertReadOnlyRecords[] = array(
                    'tender_document_file_id' => $newFile->id,
                    'contract_group_id'       => $contractGroupId,
                    'created_at'              => new \DateTime(),
                    'updated_at'              => new \DateTime()
                );
            }

            if( ! empty( $insertReadOnlyRecords ) )
                \DB::table('tender_document_files_roles_readonly')->insert($insertReadOnlyRecords);


            // Copy child files.
            $childUploads = Upload::where('parent_id', '=', $templateFile->fileProperties->id)->get();
            foreach($childUploads as $childUpload)
            {
                // Copy physical file.
                $newFileName = Files::generateCopyName($templateFile->fileProperties->physicalPath(), $childUpload->filename, $childUpload->extension);
                $filePath    = $templateFile->fileProperties->physicalPath() . '/' . $templateFile->fileProperties->filename;
                $newFilePath = $templateFile->fileProperties->physicalPath() . '/' . $newFileName;
                Files::copy($filePath, $newFilePath);

                $upload = $childUpload->replicate();

                $upload->filename = $newFileName;

                $upload->path = $newFilePath;

                $upload->user_id = $currentUser->id;

                $upload->parent_id = $newUpload->id;

                $upload->save();
            }
        }
    }

    /**
     * Returns files of the folder.
     *
     * @return array
     */
    public function getFiles()
    {
        $files = array();

        foreach($this->files as $file) $files[] = $file;

        return $files;
    }

    /**
     * Returns files of all folders in a project.
     *
     * @param Project $project
     * @param bool    $includeSystemGeneratedFolders
     *
     * @return array
     */
    public static function getProjectFiles(Project $project, $includeSystemGeneratedFolders = true)
    {
        $files = array();

        foreach($project->tenderDocumentFolders as $folder)
        {
            if( ( ! $includeSystemGeneratedFolders ) && $folder->system_generated_folder ) continue;

            $files = array_merge($files, $folder->getFiles());
        }

        return $files;
    }

}